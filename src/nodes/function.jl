# Function and operator calls.

mutable struct FunctionNode <: AbstractSQLNode
    name::Symbol
    args::Vector{SQLNode}

    FunctionNode(;
             name::Union{Symbol, AbstractString},
             args = SQLNode[]) =
        new(Symbol(name), args)
end

FunctionNode(name; args = SQLNode[]) =
    FunctionNode(name = name, args = args)

FunctionNode(name, args...) =
    FunctionNode(name = name, args = SQLNode[args...])

"""
    Fun(; name, args = [])
    Fun(name; args = [])
    Fun(name, args...)
    Fun.name(args...)

Application of a SQL function or a SQL operator.

A `Fun` node is also generated by broadcasting on `SQLNode` objects.

If the given `name` is a valid identifier, the `Fun` node is translated
to a SQL function; otherwise, it is translated to a SQL operator.
Certain names have a customized translation in order to support SQL functions
and operators with irregular syntax:

| `Fun` node                        | SQL syntax                            |
|:--------------------------------- |:--------------------------------------|
| `x .== y`, `Fun."=="(x, y)`       | `x = y`                               |
| `x .!= y`, `Fun."!="(x, y)`       | `x <> y`                              |
| `Fun.and(p₁, p₂, …)`              | `p₁ AND p₂ AND …`                     |
| `Fun.between(x, y, z)`            | `x BETWEEN y AND z`                   |
| `Fun.case(p, x, …)`               | `CASE WHEN p THEN x … END`            |
| `Fun.cast(x, "TYPE")`             | `CAST(x AS TYPE)`                     |
| `Fun.current_date()`              | `CURRENT_DATE`                        |
| `Fun.current_timestamp()`         | `CURRENT_TIMESTAMP`                   |
| `Fun.exists(q)`                   | `EXISTS q`                            |
| `Fun.extract("FIELD", x)`         | `EXTRACT(FIELD FROM x)`               |
| `Fun.in(x, q)`                    | `x IN q`                              |
| `Fun.in(x, y₁, y₂, …)`            | `x IN (y₁, y₂, …)`                    |
| `Fun."is not null"(x)`            | `x IS NOT NULL`                       |
| `Fun."is null"(x)`                | `x IS NULL`                           |
| `Fun.like(x, y)`                  | `x LIKE y`                            |
| `Fun.not(p)`                      | `NOT p`                               |
| `Fun."not between"(x, y, z)`      | `x NOT BETWEEN y AND z`               |
| `Fun."not in"(x, q)`              | `x NOT IN q`                          |
| `Fun."not in"(x, y₁, y₂, …)`      | `x NOT IN (y₁, y₂, …)`                |
| `Fun.or(p₁, p₂, …)`               | `p₁ OR p₂ OR …`                       |

# Examples

*Show patients born before 2000.*

```jldoctest
julia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia> q = From(:person) |>
           Where(Fun.not(Get.year_of_birth .>= 2000));

julia> print(render(q, tables = [person]))
SELECT
  "person_1"."person_id",
  "person_1"."year_of_birth"
FROM "person" AS "person_1"
WHERE (NOT ("person_1"."year_of_birth" >= 2000))
```
"""
Fun(args...; kws...) =
    FunctionNode(args...; kws...) |> SQLNode

dissect(scr::Symbol, ::typeof(Fun), pats::Vector{Any}) =
    dissect(scr, FunctionNode, pats)

PrettyPrinting.quoteof(n::FunctionNode, ctx::QuoteContext) =
    Expr(:call,
         Expr(:., nameof(Fun),
                  QuoteNode(Base.isidentifier(n.name) ? n.name : string(n.name))),
         quoteof(n.args, ctx)...)

label(n::FunctionNode) =
    Meta.isidentifier(n.name) ? n.name : :_


# Notation for making function nodes.

struct FunClosure
    name::Symbol
end

Base.show(io::IO, f::FunClosure) =
    print(io, Expr(:., nameof(Fun),
                       QuoteNode(Base.isidentifier(f.name) ? f.name : string(f.name))))

Base.getproperty(::typeof(Fun), name::Symbol) =
    FunClosure(name)

Base.getproperty(::typeof(Fun), name::AbstractString) =
    FunClosure(Symbol(name))

(f::FunClosure)(args...) =
    Fun(f.name, args = SQLNode[args...])

(f::FunClosure)(; args = SQLNode[]) =
    Fun(f.name, args = args)


# Broadcasting notation.

struct FunStyle <: Base.BroadcastStyle
end

Base.BroadcastStyle(::Type{<:AbstractSQLNode}) =
    FunStyle()

Base.BroadcastStyle(::FunStyle, ::Base.Broadcast.DefaultArrayStyle{0}) =
    FunStyle()

Base.broadcastable(n::AbstractSQLNode) =
    n

Base.Broadcast.instantiate(bc::Base.Broadcast.Broadcasted{FunStyle}) =
    bc

Base.copy(bc::Base.Broadcast.Broadcasted{FunStyle}) =
    Fun(nameof(bc.f), args = SQLNode[bc.args...])

Base.convert(::Type{AbstractSQLNode}, bc::Base.Broadcast.Broadcasted{FunStyle}) =
    FunctionNode(nameof(bc.f), args = SQLNode[bc.args...])

