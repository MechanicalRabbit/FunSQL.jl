<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · FunSQL.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FunSQL.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Test-Database"><span>Test Database</span></a></li><li><a class="tocitem" href="#Database-Schema"><span>Database Schema</span></a></li><li><a class="tocitem" href="#Using-FunSQL"><span>Using FunSQL</span></a></li><li><a class="tocitem" href="#Tabular-operations"><span>Tabular operations</span></a></li><li><a class="tocitem" href="#Row-operations"><span>Row operations</span></a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li><li><a class="tocitem" href="../test/">Test Suite</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>This tutorial will teach you how to build SQL queries using FunSQL.</p><h2 id="Test-Database"><a class="docs-heading-anchor" href="#Test-Database">Test Database</a><a id="Test-Database-1"></a><a class="docs-heading-anchor-permalink" href="#Test-Database" title="Permalink"></a></h2><p>To demonstrate database queries, we need a test database.  The database we use is a tiny 10 person sample of simulated patient data extracted from a much larger <a href="https://www.cms.gov/Research-Statistics-Data-and-Systems/Downloadable-Public-Use-Files/SynPUFs/DE_Syn_PUF">CMS DE-SynPuf dataset</a>. For a database engine, we picked <a href="https://www.sqlite.org/">SQLite</a>.  Using SQLite in a tutorial is convenient because it does not require a database server to run and allows us to distribute the whole database as a single file. FunSQL supports SQLite and many other database engines.  The techniques discussed here are not specific to SQLite or this particular database.  Once you learn them, you should be able to apply them to your own databases.</p><p>If you wish to follow along with the tutorial and run the examples, download the database file:</p><pre><code class="language-julia hljs">const URL = &quot;https://github.com/MechanicalRabbit/ohdsi-synpuf-demo/releases/download/20210412/synpuf-10p.sqlite&quot;
const DB = download(URL)</code></pre><p>During development, all the code examples here are executed on every update by the <a href="https://github.com/MechanicalRabbit/NarrativeTest.jl">NarrativeTest</a> package.  To avoid downloading the database file more than once, we registered the download URL as an <a href="../Artifacts.toml">artifact</a> and use <a href="http://pkgdocs.julialang.org/v1/artifacts/"><code>Pkg.Artifacts</code></a> API to fetch it:</p><pre><code class="language-julia hljs">using Pkg.Artifacts, LazyArtifacts

const DB = joinpath(artifact&quot;synpuf-10p&quot;, &quot;synpuf-10p.sqlite&quot;)</code></pre><p>To interact with a SQLite database from Julia code, we need to install the <a href="https://github.com/JuliaDatabases/SQLite.jl">SQLite</a> package:</p><pre><code class="language-julia hljs">using Pkg

Pkg.add(&quot;SQLite&quot;)</code></pre><p>Once the package is installed, we can use it to connect to the database:</p><pre><code class="language-julia hljs">using SQLite

const conn = SQLite.DB(DB)</code></pre><p>Later we will use the <code>conn</code> object to execute database queries.</p><h2 id="Database-Schema"><a class="docs-heading-anchor" href="#Database-Schema">Database Schema</a><a id="Database-Schema-1"></a><a class="docs-heading-anchor-permalink" href="#Database-Schema" title="Permalink"></a></h2><p>The data in the test database is stored in the format of the <a href="https://ohdsi.github.io/TheBookOfOhdsi/CommonDataModel.html">OMOP Common Data Model</a>, an open source database schema for observational healthcare data.  In this tutorial, we will only use a small fragment of the Common Data Model.</p><p><img src="../omop-common-data-model.drawio.svg" alt="Fragment of the OMOP Common Data Model"/></p><p>Before we can start assembling queries with FunSQL, we need to make FunSQL aware of the database schema.  For each table in the database, we need to create a corresponding <code>SQLTable</code>(@ref) object, which encapsulates the name of the table and the names of the columns.</p><pre><code class="language-julia hljs">using FunSQL: SQLTable</code></pre><p>The patient data, including basic demographic information, is stored in the table <code>person</code>:</p><pre><code class="language-julia hljs">const person =
    SQLTable(:person,
             columns = [:person_id, :year_of_birth, :location_id])</code></pre><p>Patient addresses are stored in a separate table <code>location</code>, linked to the <code>person</code> table by the key column <code>location_id</code>:</p><pre><code class="language-julia hljs">const location =
    SQLTable(:location,
             columns = [:location_id, :city, :state])</code></pre><p>The bulk of patient data consists of clinical events: visits to healthcare providers, recorded observations, diagnosed conditions, prescribed medications, etc.  In this tutorial we only use two types of events, visits and conditions:</p><pre><code class="language-julia hljs">const visit_occurrence =
    SQLTable(:visit_occurrence,
             columns = [:visit_occurrence_id, :person_id,
                        :visit_concept_id,
                        :visit_start_date, :visit_end_date])

const condition_occurrence =
    SQLTable(:condition_occurrence,
             columns = [:condition_occurrence_id, :person_id,
                        :condition_concept_id,
                        :condition_start_date, :condition_end_date])</code></pre><p>The specific type of the event (e.g., <em>Inpatient</em> visit or <em>Essential hypertension</em> condition) is indicated using a <em>concept id</em> column, which refers to the <code>concept</code> table:</p><pre><code class="language-julia hljs">const concept =
    SQLTable(:concept,
             columns = [:concept_id, :concept_name])</code></pre><p>Different concepts may be related to each other.  For instance, <em>Essential hypertension</em> <strong>is a</strong> <em>Hypertensive disorder</em>, which itself <strong>is a</strong> <em>Disorder of cardiovascular system</em>.  Concept relationships are recorded in the corresponding table:</p><pre><code class="language-julia hljs">const concept_relationship =
    SQLTable(:concept_relationship,
             columns = [:concept_id_1, :concept_id_2, :relationship_id])</code></pre><h2 id="Using-FunSQL"><a class="docs-heading-anchor" href="#Using-FunSQL">Using FunSQL</a><a id="Using-FunSQL-1"></a><a class="docs-heading-anchor-permalink" href="#Using-FunSQL" title="Permalink"></a></h2><p>To retrieve data from the database using FunSQL, we need to perform three steps: assemble a query object, render SQL, and execute SQL.  To demonstrate these steps, let us consider the following question:</p><p><em>Who are the patients born between 1930 and 1940 and what is their current age (by the end of 2020)?</em></p><p>The SQL query that answer this question could be written like this:</p><pre><code class="language-sql hljs">SELECT p.person_id, 2020 - p.year_of_birth AS age
FROM person p
WHERE p.year_of_birth &gt;= 1930 AND p.year_of_birth &lt; 1940</code></pre><p>FunSQL representation of the SQL query mirrors its structure: the structure of the SQL query:</p><pre><code class="language-julia hljs">using FunSQL: From, Fun, Get, Select, Where

q = From(person) |&gt;
    Where(Fun.and(Get.year_of_birth .&gt;= 1930,
                  Get.year_of_birth .&lt; 1940)) |&gt;
    Select(Get.person_id,
           :age =&gt; 2020 .- Get.year_of_birth)</code></pre><p>The next step is to serialize the query object to SQL.  We need to specify the target SQL dialect such as <code>:sqlite</code> or <code>:postgresql</code>:</p><pre><code class="language-julia hljs">using FunSQL: render

sql = render(q, dialect = :sqlite)

print(sql)
#=&gt;
SELECT &quot;person_1&quot;.&quot;person_id&quot;, (2020 - &quot;person_1&quot;.&quot;year_of_birth&quot;) AS &quot;age&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
WHERE ((&quot;person_1&quot;.&quot;year_of_birth&quot; &gt;= 1930) AND (&quot;person_1&quot;.&quot;year_of_birth&quot; &lt; 1940))
=#</code></pre><p>At this point, the job of FunSQL is done.  To submit the SQL query to the database engine, we can use the connection object that we created <a href="#Test-Database">earlier</a>:</p><pre><code class="language-julia hljs">res = DBInterface.execute(conn, sql)
#-&gt; SQLite.Query( … )</code></pre><p>The output of the query could be displayed in a tabular form by converting it to a <a href="https://github.com/JuliaData/DataFrames.jl"><code>DataFrame</code></a> object:</p><pre><code class="language-julia hljs">using DataFrames

res |&gt; DataFrame |&gt; display
#=&gt;
2×2 DataFrame
 Row │ person_id  age
     │ Int64      Int64
─────┼──────────────────
   1 │     30091     88
   2 │     72120     83
=#</code></pre><h2 id="Tabular-operations"><a class="docs-heading-anchor" href="#Tabular-operations">Tabular operations</a><a id="Tabular-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Tabular-operations" title="Permalink"></a></h2><p>Recall the query demonstrated in the <a href="#Using-FunSQL">previous</a> section:</p><pre><code class="language-julia hljs">From(person) |&gt;
Where(Fun.and(Get.year_of_birth .&gt;= 1930, Get.year_of_birth .&lt; 1940)) |&gt;
Select(Get.person_id, :age =&gt; 2020 .- Get.year_of_birth)</code></pre><p>This query is constructed from tabular operations <code>From</code>, <code>Where</code>, and <code>Select</code> arranged in a pipeline using the pipe (<code>|&gt;</code>) operator.</p><p>In SQL, a <em>tabular operation</em> takes a certain number of input datasets and produces an output dataset.  Tabular operations are typically parameterized by <em>row operations</em>, which act on a dataset row and produce a scalar value.</p><p>The <code>From</code> operation outputs the content of a database table.  It takes one argument, a <code>SQLTable</code> object describing the table (see section <a href="#Database-Schema">Database Schema</a> for the definition of <code>person</code>).  In the context of a query expression, a <code>SQLTable</code> object is automatically converted to <code>From</code>; thus this query could condensed to:</p><pre><code class="language-julia hljs">person |&gt;
Where(Fun.and(Get.year_of_birth .&gt;= 1930, Get.year_of_birth .&lt; 1940)) |&gt;
Select(Get.person_id, :age =&gt; 2020 .- Get.year_of_birth)</code></pre><p>The <code>Select</code> operation allows us to customize the output columns.  Column names are specified with <code>=&gt;</code> or using the <code>As</code> constructor, e.g.,</p><pre><code class="language-julia hljs">using FunSQL: As

2020 .- Get.year_of_birth |&gt; As(:age)</code></pre><p>If the column name is not given explicitly, it is derived from the expression that calculates the column value.</p><p>As opposed to SQL, FunSQL does not require that the query has an explicit <code>Select</code>, so that the following expression is a valid and complete query:</p><pre><code class="language-julia hljs">q = From(person) |&gt;
    Where(Fun.and(Get.year_of_birth .&gt;= 1930, Get.year_of_birth .&lt; 1940))</code></pre><p>This query produces all the columns from the <code>person</code> table:</p><pre><code class="language-julia hljs">sql = render(q)

print(sql)
#=&gt;
SELECT &quot;person_1&quot;.&quot;person_id&quot;, &quot;person_1&quot;.&quot;year_of_birth&quot;, &quot;person_1&quot;.&quot;location_id&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
WHERE ((&quot;person_1&quot;.&quot;year_of_birth&quot; &gt;= 1930) AND (&quot;person_1&quot;.&quot;year_of_birth&quot; &lt; 1940))
=#</code></pre><p>Neither <code>From</code> is mandatory.  When a tabular operation, such as <code>Select</code>, that expects an input dataset isn&#39;t provided with one, it is supplied with the <em>unit</em> dataset containing one row and no columns.  This allows us to create queries that do not depend on the content of any database tables and generate one row of output:</p><pre><code class="language-julia hljs">q = Select(Fun.current_timestamp())

sql = render(q)

print(sql)
#-&gt; SELECT CURRENT_TIMESTAMP AS &quot;current_timestamp&quot;</code></pre><h2 id="Row-operations"><a class="docs-heading-anchor" href="#Row-operations">Row operations</a><a id="Row-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Row-operations" title="Permalink"></a></h2><p>Row operations are assembled from literal values, column references, and applications of SQL functions and operators.</p><p>Literal values are created using the <code>Lit</code> constructor, although the values of type <code>Bool</code>, <code>Number</code>, <code>AbstractString</code> and <code>AbstractTime</code> as well as <code>missing</code> are automatically wrapped with <code>Lit</code> when used in a query expression:</p><pre><code class="language-julia hljs">using FunSQL: Lit

Select(Lit(42))
Select(42)</code></pre><p>The SQL value <code>NULL</code> is represented by <code>missing</code>.  FunSQL makes a reasonable attempt to convert Julia values to their respective SQL equivalents.</p><p>Column references are created using the <code>Get</code> constructor, which has several equivalent forms:</p><pre><code class="language-julia hljs">Get.year_of_birth
Get(:year_of_birth)
Get.&quot;year_of_birth&quot;
Get(&quot;year_of_birth&quot;)</code></pre><p>Column references are always resolved at the place of use.  Here, the same reference <code>Get.year_of_birth</code> appears several times:</p><pre><code class="language-julia hljs">From(person) |&gt;
Where(Fun.and(Get.year_of_birth .&gt;= 1930, Get.year_of_birth .&lt; 1940)) |&gt;
Select(Get.person_id, :age =&gt; 2020 .- Get.year_of_birth)</code></pre><p>As a part of <code>Where</code>, it refers to the column produced by the <code>From</code> operation, but inside <code>Select</code> it refers to the output of <code>Where</code>.</p><p>FunSQL provides an alternative notation for column references.</p><pre><code class="language-julia hljs">q1 = From(person)
q2 = q1 |&gt;
     Where(Fun.and(q1.year_of_birth .&gt;= 1930, q1.year_of_birth .&lt; 1940))
q3 = q2 |&gt;
     Select(q1.person_id, :age =&gt; 2020 .- q1.year_of_birth)</code></pre><p>The <em>unbound</em> references <code>Get.year_of_birth</code> and <code>Get.person_id</code> are replaced with <em>bound</em> references <code>q1.year_of_birth</code> and <code>q1.person_id</code>.  If we use a bound reference, the node to which the reference is bound must be a part of the query.  Note that in <code>Select</code>, we could replace <code>q1</code> with <code>q2</code> without changing the meaning of the query:</p><pre><code class="language-julia hljs">q3 = q2 |&gt;
     Select(q2.person_id, :age =&gt; 2020 .- q2.year_of_birth)</code></pre><p>Use of unbound references makes query composition more modular.  For example, we could encapsulate the condition on the birth range in a Julia function as follows:</p><pre><code class="language-julia hljs">BirthRange(start, stop) =
    Fun.and(Get.year_of_birth .&gt;= start, Get.year_of_birth .&lt; stop)

From(person) |&gt; Where(BirthRange(1930, 1940))</code></pre><p>On the other hand, bound references sometimes make it easier to disambiguate columns of different tables.</p><p>SQL functions and operators are represented using the <code>Fun</code> constructor, which, just like <code>Get</code>, has several equivalent forms:</p><pre><code class="language-julia hljs">Fun.and(Get.year_of_birth .&gt;= 1930, Get.year_of_birth .&lt; 1940)
Fun(:and, Get.year_of_birth .&gt;= 1930, Get.year_of_birth .&lt; 1940)
Fun.&quot;and&quot;(Get.year_of_birth .&gt;= 1930, Get.year_of_birth .&lt; 1940)
Fun(&quot;and&quot;, Get.year_of_birth .&gt;= 1930, Get.year_of_birth .&lt; 1940)</code></pre><p>Certain SQL operators, notably comparison operators, also support broadcasting notation:</p><pre><code class="language-julia hljs">Fun.&quot;&gt;=&quot;(Get.year_of_birth, 1930)
Get.year_of_birth .&gt;= 1930</code></pre><p>FunSQL has support for serializing some of the widely used SQL functions and operators with irregular notation.  For example:</p><pre><code class="language-julia hljs">q = From(person) |&gt;
    Select(:generation =&gt; Fun.case(Get.year_of_birth .&lt;= 1960,
                                   &quot;boomer&quot;, &quot;millenial&quot;))

print(render(q))
#=&gt;
SELECT (CASE WHEN (&quot;person_1&quot;.&quot;year_of_birth&quot; &lt;= 1960) THEN &#39;boomer&#39; ELSE &#39;millenial&#39; END) AS &quot;generation&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
=#</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../api/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Thursday 19 August 2021 06:14">Thursday 19 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
