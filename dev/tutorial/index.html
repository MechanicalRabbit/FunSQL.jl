<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · FunSQL.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FunSQL.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Test-Database"><span>Test Database</span></a></li><li><a class="tocitem" href="#Database-Connection"><span>Database Connection</span></a></li><li><a class="tocitem" href="#Database-Schema"><span>Database Schema</span></a></li><li><a class="tocitem" href="#Why-FunSQL?"><span>Why FunSQL?</span></a></li><li><a class="tocitem" href="#Tabular-Operations"><span>Tabular Operations</span></a></li><li><a class="tocitem" href="#From"><span><code>From</code></span></a></li><li><a class="tocitem" href="#Select"><span><code>Select</code></span></a></li><li><a class="tocitem" href="#Join"><span><code>Join</code></span></a></li><li><a class="tocitem" href="#Row-Operations"><span>Row Operations</span></a></li><li><a class="tocitem" href="#Lit"><span><code>Lit</code></span></a></li><li><a class="tocitem" href="#Get"><span><code>Get</code></span></a></li><li><a class="tocitem" href="#Fun"><span><code>Fun</code></span></a></li><li><a class="tocitem" href="#Query-Parameters"><span>Query Parameters</span></a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li><li><a class="tocitem" href="../test/">Test Suite</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>This tutorial will teach you how to build SQL queries using FunSQL.</p><h2 id="Test-Database"><a class="docs-heading-anchor" href="#Test-Database">Test Database</a><a id="Test-Database-1"></a><a class="docs-heading-anchor-permalink" href="#Test-Database" title="Permalink"></a></h2><p>To demonstrate database queries, we need a test database.  The database we use here is a tiny 10 person sample of simulated patient data extracted from a much larger <a href="https://www.cms.gov/Research-Statistics-Data-and-Systems/Downloadable-Public-Use-Files/SynPUFs/DE_Syn_PUF">CMS DE-SynPuf dataset</a>. For a database engine, we picked <a href="https://www.sqlite.org/">SQLite</a>.  Using SQLite in a tutorial is convenient because it does not require a database server to run and allows us to distribute the whole database as a single file. FunSQL supports SQLite and many other database engines.  The techniques discussed here are not specific to SQLite and once you learn them, you will be able to apply them to any SQL database.</p><p>If you wish to follow along with the tutorial and run the examples, download the database file:</p><pre><code class="language-julia hljs">const URL = &quot;https://github.com/MechanicalRabbit/ohdsi-synpuf-demo/releases/download/20210412/synpuf-10p.sqlite&quot;
const DB = download(URL)</code></pre><p>While working on this tutorial, we run all the code examples on every update (using the <a href="https://github.com/MechanicalRabbit/NarrativeTest.jl">NarrativeTest</a> package). To avoid downloading the database file more than once, we registered the download URL as an <a href="../Artifacts.toml">artifact</a> and use <a href="http://pkgdocs.julialang.org/v1/artifacts/"><code>Pkg.Artifacts</code></a> API to fetch it:</p><pre><code class="language-julia hljs">using Pkg.Artifacts, LazyArtifacts

const DB = joinpath(artifact&quot;synpuf-10p&quot;, &quot;synpuf-10p.sqlite&quot;)
#-&gt; ⋮</code></pre><h2 id="Database-Connection"><a class="docs-heading-anchor" href="#Database-Connection">Database Connection</a><a id="Database-Connection-1"></a><a class="docs-heading-anchor-permalink" href="#Database-Connection" title="Permalink"></a></h2><p>To interact with a SQLite database from Julia code, we need to install the <a href="https://github.com/JuliaDatabases/SQLite.jl">SQLite</a> package:</p><pre><code class="language-julia hljs">using Pkg

Pkg.add(&quot;SQLite&quot;)</code></pre><p>Once the package is installed, we can use it to connect to the database:</p><pre><code class="language-julia hljs">using SQLite

const conn = SQLite.DB(DB)</code></pre><p>Later we will use the <code>conn</code> object to execute database queries.</p><h2 id="Database-Schema"><a class="docs-heading-anchor" href="#Database-Schema">Database Schema</a><a id="Database-Schema-1"></a><a class="docs-heading-anchor-permalink" href="#Database-Schema" title="Permalink"></a></h2><p>The data in the test database is stored in the format of the <a href="https://ohdsi.github.io/TheBookOfOhdsi/CommonDataModel.html">OMOP Common Data Model</a>, an open source database schema for observational healthcare data.  In this tutorial, we will only use a small fragment of the Common Data Model.</p><p><img src="../omop-common-data-model.drawio.svg" alt="Fragment of the OMOP Common Data Model"/></p><p>Before we can start assembling queries with FunSQL, we need to make FunSQL aware of the database schema.  For each table in the database, we need to create a corresponding <a href="../api/#FunSQL.SQLTable"><code>SQLTable</code></a> object, which encapsulates the name of the table together with the names of the columns.</p><pre><code class="language-julia hljs">using FunSQL: SQLTable</code></pre><p>The patient data, including basic demographic information, is stored in the table <code>person</code>:</p><pre><code class="language-julia hljs">const person =
    SQLTable(:person,
             columns = [:person_id, :year_of_birth, :location_id])</code></pre><p>Patient addresses are stored in a separate table <code>location</code>, linked to <code>person</code> by the key column <code>location_id</code>:</p><pre><code class="language-julia hljs">const location =
    SQLTable(:location,
             columns = [:location_id, :city, :state])</code></pre><p>The bulk of patient data consists of clinical events: visits to healthcare providers, recorded observations, diagnosed conditions, prescribed medications, etc.  In this tutorial we only use two types of events, visits and conditions:</p><pre><code class="language-julia hljs">const visit_occurrence =
    SQLTable(:visit_occurrence,
             columns = [:visit_occurrence_id, :person_id,
                        :visit_concept_id,
                        :visit_start_date, :visit_end_date])

const condition_occurrence =
    SQLTable(:condition_occurrence,
             columns = [:condition_occurrence_id, :person_id,
                        :condition_concept_id,
                        :condition_start_date, :condition_end_date])</code></pre><p>The specific type of the event (e.g., <em>Inpatient</em> visit or <em>Essential hypertension</em> condition) is indicated using a <em>concept id</em> column, which refers to the <code>concept</code> table:</p><pre><code class="language-julia hljs">const concept =
    SQLTable(:concept,
             columns = [:concept_id, :concept_name])</code></pre><p>Different concepts may be related to each other.  For instance, <em>Essential hypertension</em> <strong>is a</strong> <em>Hypertensive disorder</em>, which itself <strong>is a</strong> <em>Disorder of cardiovascular system</em>.  Concept relationships are recorded in the corresponding table:</p><pre><code class="language-julia hljs">const concept_relationship =
    SQLTable(:concept_relationship,
             columns = [:concept_id_1, :concept_id_2, :relationship_id])</code></pre><h2 id="Why-FunSQL?"><a class="docs-heading-anchor" href="#Why-FunSQL?">Why FunSQL?</a><a id="Why-FunSQL?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-FunSQL?" title="Permalink"></a></h2><p>Let us start with clarifying why you may want to use FunSQL.  Consider a problem:</p><p><em>Find all patients born between 1930 and 1940 and living in Illinois, and for each patient show their current age (by the end of 2020).</em></p><p>The answer can be obtained with the following SQL query:</p><pre><code class="language-sql hljs">SELECT p.person_id, 2020 - p.year_of_birth AS age
FROM person p
JOIN location l ON (p.location_id = l.location_id)
WHERE (p.year_of_birth BETWEEN 1930 AND 1940) AND (l.state = &#39;IL&#39;)</code></pre><p>The simplest way to incorporate this query into Julia code is to embed it as a string literal:</p><pre><code class="language-julia hljs">sql = &quot;&quot;&quot;
SELECT p.person_id, 2020 - p.year_of_birth AS age
FROM person p
JOIN location l ON (p.location_id = l.location_id)
WHERE (p.year_of_birth BETWEEN 1930 AND 1940) AND (l.state = &#39;IL&#39;)
&quot;&quot;&quot;</code></pre><p>Using the appropriate <a href="https://juliadatabases.org/SQLite.jl/stable/#DBInterface.execute">database engine API</a> and the connection object created <a href="#Test-Database">earlier</a>, we can execute this query and get back the answer:</p><pre><code class="language-julia hljs">res = DBInterface.execute(conn, sql)
#-&gt; SQLite.Query( … )</code></pre><p>As an aside, it is convenient to use the <a href="https://github.com/JuliaData/DataFrames.jl">DataFrame</a> interface to show the output of a query in tabular form:</p><pre><code class="language-julia hljs">using DataFrames

res |&gt; DataFrame |&gt; display
#=&gt;
1×2 DataFrame
 Row │ person_id  age
     │ Int64      Int64
─────┼──────────────────
   1 │     72120     83
=#</code></pre><p>FunSQL introduces an extra step to this workflow.  Instead of embedding the SQL query directly into Julia code, we construct a <em>query object</em>:</p><pre><code class="language-julia hljs">using FunSQL: From, Fun, Get, Join, Select, Where

q = From(person) |&gt;
    Where(Fun.between(Get.year_of_birth, 1930, 1940)) |&gt;
    Join(:location =&gt; From(location) |&gt;
                      Where(Get.state .== &quot;IL&quot;),
         on = Get.location_id .== Get.location.location_id) |&gt;
    Select(Get.person_id, :age =&gt; 2020 .- Get.year_of_birth)</code></pre><p>The value of <code>q</code> is a composite object of type <a href="../api/#FunSQL.SQLNode"><code>SQLNode</code></a>.  &quot;Composite&quot; means that <code>q</code> is assembled from components (also of type <code>SQLNode</code>), which themselves are either atomic or assembled from smaller components.  Different kinds of components are created by <code>SQLNode</code> constructors such as <code>From</code>, <code>Where</code>, <code>Fun</code>, <code>Get</code>, etc.</p><p>The actual SQL query is generated by <em>rendering</em> the query object:</p><pre><code class="language-julia hljs">using FunSQL: render

sql = render(q, dialect = :sqlite)

print(sql)
#=&gt;
SELECT &quot;person_2&quot;.&quot;person_id&quot;, (2020 - &quot;person_2&quot;.&quot;year_of_birth&quot;) AS &quot;age&quot;
FROM (
  SELECT &quot;person_1&quot;.&quot;location_id&quot;, &quot;person_1&quot;.&quot;person_id&quot;, &quot;person_1&quot;.&quot;year_of_birth&quot;
  FROM &quot;person&quot; AS &quot;person_1&quot;
  WHERE (&quot;person_1&quot;.&quot;year_of_birth&quot; BETWEEN 1930 AND 1940)
) AS &quot;person_2&quot;
JOIN (
  SELECT &quot;location_1&quot;.&quot;location_id&quot;
  FROM &quot;location&quot; AS &quot;location_1&quot;
  WHERE (&quot;location_1&quot;.&quot;state&quot; = &#39;IL&#39;)
) AS &quot;location_2&quot; ON (&quot;person_2&quot;.&quot;location_id&quot; = &quot;location_2&quot;.&quot;location_id&quot;)
=#</code></pre><p>Notice that the <a href="../api/#FunSQL.render"><code>render</code></a> function takes a parameter called <code>dialect</code>. Although the SQL language is standardized, different implementations of SQL tend to deviate from the standard far enough to make them mutually incompatible.  For this reason, FunSQL lets us select the target SQL dialect.</p><p>At this point, the job of FunSQL is done and, just as before, we can execute the query and display the result:</p><pre><code class="language-julia hljs">res = DBInterface.execute(conn, sql)

DataFrame(res)
#=&gt;
1×2 DataFrame
 Row │ person_id  age
     │ Int64      Int64
─────┼──────────────────
   1 │     72120     83
=#</code></pre><p>Why, instead of embedding a complete SQL query, we may prefer to generate it through a query object?  To justify this extra step, consider that in a real Julia program, any query is likely going to be parameterized:</p><p><em>Find all patients born between <code>$start_year</code> and <code>$end_year</code> and living in <code>$states</code>, and for each patient show the <code>$output_columns</code>.</em></p><p>If this is the case, the SQL query cannot be prepared in advance and must be assembled on the fly.  While it is possible to assemble a SQL query from string fragments, it is tedious, error-prone and definitely not fun.  FunSQL provides a more robust and effective approach: build the query as a composite data structure.</p><p>Here is how a parameterized query may be constructed with FunSQL:</p><pre><code class="language-julia hljs">function FindPatients(; start_year = nothing,
                        end_year = nothing,
                        states = String[])
    q = From(person) |&gt;
        Where(BirthRange(start_year, end_year))
    if !isempty(states)
        q = q |&gt;
            Join(:location =&gt; From(location) |&gt;
                              Where(Fun.in(Get.state, states...)),
                 on = Get.location_id .== Get.location.location_id)
    end
    q
end

function BirthRange(start_year, end_year)
    p = true
    if start_year !== nothing
        p = Fun.and(p, Get.year_of_birth .&gt;= start_year)
    end
    if end_year !== nothing
        p = Fun.and(p, Get.year_of_birth .&lt;= end_year)
    end
    p
end</code></pre><p>The function <code>FindPatients</code> effectively becomes a new <code>SQLNode</code> constructor, which can be used directly or as a component of a larger query.</p><p><em>Show all patients.</em></p><pre><code class="language-julia hljs">q = FindPatients()

print(render(q, dialect = :sqlite))
#=&gt;
SELECT &quot;person_1&quot;.&quot;person_id&quot;, &quot;person_1&quot;.&quot;year_of_birth&quot;, &quot;person_1&quot;.&quot;location_id&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
=#</code></pre><p><em>Show all patients born in or after 1930.</em></p><pre><code class="language-julia hljs">q = FindPatients(start_year = 1930) |&gt;
    Select(Get.person_id)

print(render(q, dialect = :sqlite))
#=&gt;
SELECT &quot;person_1&quot;.&quot;person_id&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
WHERE (&quot;person_1&quot;.&quot;year_of_birth&quot; &gt;= 1930)
=#</code></pre><p><em>Find all patients born between 1930 and 1940 and living in Illinois, and for each patient show their current age.</em></p><pre><code class="language-julia hljs">q = FindPatients(start_year = 1930, end_year = 1940, states = [&quot;IL&quot;]) |&gt;
    Select(Get.person_id, :age =&gt; 2020 .- Get.year_of_birth)

print(render(q, dialect = :sqlite))
#=&gt;
SELECT &quot;person_2&quot;.&quot;person_id&quot;, (2020 - &quot;person_2&quot;.&quot;year_of_birth&quot;) AS &quot;age&quot;
FROM (
  SELECT &quot;person_1&quot;.&quot;location_id&quot;, &quot;person_1&quot;.&quot;person_id&quot;, &quot;person_1&quot;.&quot;year_of_birth&quot;
  FROM &quot;person&quot; AS &quot;person_1&quot;
  WHERE ((&quot;person_1&quot;.&quot;year_of_birth&quot; &gt;= 1930) AND (&quot;person_1&quot;.&quot;year_of_birth&quot; &lt;= 1940))
) AS &quot;person_2&quot;
JOIN (
  SELECT &quot;location_1&quot;.&quot;location_id&quot;
  FROM &quot;location&quot; AS &quot;location_1&quot;
  WHERE (&quot;location_1&quot;.&quot;state&quot; IN (&#39;IL&#39;))
) AS &quot;location_2&quot; ON (&quot;person_2&quot;.&quot;location_id&quot; = &quot;location_2&quot;.&quot;location_id&quot;)
=#</code></pre><h2 id="Tabular-Operations"><a class="docs-heading-anchor" href="#Tabular-Operations">Tabular Operations</a><a id="Tabular-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Tabular-Operations" title="Permalink"></a></h2><p>Recall the query that was demonstrated in the <a href="#Why-FunSQL?">previous section</a>:</p><p><em>Find all patients born between 1930 and 1940 and living in Illinois, and for each patient show their current age.</em></p><pre><code class="language-julia hljs">From(person) |&gt;
Where(Fun.between(Get.year_of_birth, 1930, 1940)) |&gt;
Join(:location =&gt; From(location) |&gt;
                  Where(Get.state .== &quot;IL&quot;),
     on = Get.location_id .== Get.location.location_id) |&gt;
Select(Get.person_id, :age =&gt; 2020 .- Get.year_of_birth)</code></pre><p>At the outer level, this query is constructed from tabular operations <code>From</code>, <code>Where</code>, <code>Join</code>, and <code>Select</code> arranged in a pipeline by the pipe (<code>|&gt;</code>) operator.  In SQL, a <em>tabular operation</em> takes a certain number of input datasets and produces an output dataset.  It is helpful to visualize a tabular operation as a node with a certain number of input arrows and one output arrow.</p><p><img src="../from-where-select-join-nodes.drawio.svg" alt="From, Where, Select, and Join nodes"/></p><p>Then the whole query can be visualized as a pipeline diagram.  Each arrow in this diagram represents a dataset, and each node represents an elementary data processing operation.</p><p><img src="../person-by-birth-year-range-and-state.drawio.svg" alt="Query pipeline"/></p><p>The following tabular operations are available in FunSQL.</p><table><tr><th style="text-align: left">Constructor</th><th style="text-align: left">Function</th></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.Append-Tuple"><code>Append</code></a></td><td style="text-align: left">concatenate datasets</td></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.As-Tuple"><code>As</code></a></td><td style="text-align: left">wrap all columns in a nested record</td></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.Bind-Tuple"><code>Bind</code></a></td><td style="text-align: left">correlate a subquery in a <em>join</em> expression</td></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.Define-Tuple"><code>Define</code></a></td><td style="text-align: left">add an output column</td></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.From-Tuple"><code>From</code></a></td><td style="text-align: left">produce the content of a database table</td></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.Group-Tuple"><code>Group</code></a></td><td style="text-align: left">partition the dataset into disjoint groups</td></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.Join-Tuple"><code>Join</code></a></td><td style="text-align: left">correlate two datasets</td></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.Limit-Tuple"><code>Limit</code></a></td><td style="text-align: left">truncate the dataset</td></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.Order-Tuple"><code>Order</code></a></td><td style="text-align: left">sort the dataset</td></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.Partition-Tuple"><code>Partition</code></a></td><td style="text-align: left">add a window to the dataset</td></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.Select-Tuple"><code>Select</code></a></td><td style="text-align: left">specify output columns</td></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.Where-Tuple"><code>Where</code></a></td><td style="text-align: left">filter the dataset by the given condition</td></tr></table><p>Next, we will take a closer look at three of them: <code>From</code>, <code>Select</code>, and <code>Join</code>.</p><h2 id="From"><a class="docs-heading-anchor" href="#From"><code>From</code></a><a id="From-1"></a><a class="docs-heading-anchor-permalink" href="#From" title="Permalink"></a></h2><p>The <code>From</code> node outputs the content of a database table.  The constructor takes one argument, a <code>SQLTable</code> object (see the section <a href="#Database-Schema">Database Schema</a>).  In a query, a bare <code>SQLTable</code> object is automatically converted to a <code>From</code> node, so one could write more compactly:</p><p><em>For each patient, show their current age.</em></p><pre><code class="language-julia hljs">person |&gt;
Select(Get.person_id, :age =&gt; 2020 .- Get.year_of_birth)</code></pre><p>It is possible for a query not to have a <code>From</code> node:</p><p><em>Show the current date and time.</em></p><pre><code class="language-julia hljs">q = Select(Fun.current_timestamp())

sql = render(q)

print(sql)
#-&gt; SELECT CURRENT_TIMESTAMP AS &quot;current_timestamp&quot;</code></pre><p>In this query, the <code>Select</code> node is not connected to any source of data.  In such a case, it is supplied with a <em>unit dataset</em> containing one row and no columns.  Hence this query will generate one row of output.</p><h2 id="Select"><a class="docs-heading-anchor" href="#Select"><code>Select</code></a><a id="Select-1"></a><a class="docs-heading-anchor-permalink" href="#Select" title="Permalink"></a></h2><p>In general, the <code>Select</code> node is used to specify the output columns.  The name of the column is either derived from the expression or set explicitly with <code>As</code> (or its shorthand, the arrow (<code>=&gt;</code>) operator).</p><p>As opposed to SQL, FunSQL does not demand that all queries have an explicit <code>Select</code>.  The following query will produce all columns of the table:</p><p><em>Show all patients.</em></p><pre><code class="language-julia hljs">q = From(person)

sql = render(q)

print(sql)
#=&gt;
SELECT &quot;person_1&quot;.&quot;person_id&quot;, &quot;person_1&quot;.&quot;year_of_birth&quot;, &quot;person_1&quot;.&quot;location_id&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
=#</code></pre><h2 id="Join"><a class="docs-heading-anchor" href="#Join"><code>Join</code></a><a id="Join-1"></a><a class="docs-heading-anchor-permalink" href="#Join" title="Permalink"></a></h2><p>The <code>Join</code> node correlates the rows of two input datasets.  Predominantly, <code>Join</code> is used for looking up table records by key.  In the following example, <code>Join</code> associates each <code>person</code> record with their <code>location</code> using the key column <code>location_id</code> that uniquely identifies a <code>location</code> record:</p><p><em>Show all patients together with their state of residence.</em></p><pre><code class="language-julia hljs">person |&gt;
Join(:location =&gt; location,
     Get.location_id .== Get.location.location_id,
     left = true) |&gt;
Select(Get.person_id, Get.location.state)</code></pre><p>The modifier <code>left = true</code> tells <code>Join</code> that it must output all <code>person</code> records including those without the corresponding <code>location</code>.  Since this is a very common requirement, FunSQL provides an alias:</p><pre><code class="language-julia hljs">using FunSQL: LeftJoin

person |&gt;
LeftJoin(:location =&gt; location,
         Get.location_id .== Get.location.location_id) |&gt;
Select(Get.person_id, Get.location.state)</code></pre><p>Since <code>Join</code> needs two input datasets, it must be attached to two input pipelines.  The first pipeline is attached using the <code>|&gt;</code> operator and the second one is provided as an argument to the <code>Join</code> constructor. Alternatively, both input pipelines can be specified as keyword arguments:</p><pre><code class="language-julia hljs">Join(over = person,
     joinee = :location =&gt; location,
     on = Get.location_id .== Get.location.location_id,
     left = true) |&gt;
Select(Get.person_id, Get.location.state)</code></pre><p>The output of <code>Join</code> combines columns of both input datasets, which will cause ambiguity if both datasets have a column with the same name.  Such is the case in the previous example since both tables, <code>person</code> and <code>location</code>, have a column called <code>location_id</code>.  To disambiguate them, we can place all columns of one of the datasets into a nested record.  This is the action of the arrow (<code>=&gt;</code>) operator or its full form, the <code>As</code> node:</p><pre><code class="language-julia hljs">using FunSQL: As

From(person) |&gt;
LeftJoin(From(location) |&gt;
         As(:location),
         on = Get.location_id .== Get.location.location_id) |&gt;
Select(Get.person_id, Get.location.state)</code></pre><p>Alternatively, we could use <em>bound column references</em>, which are described in a <a href="#Get">later section</a>.</p><h2 id="Row-Operations"><a class="docs-heading-anchor" href="#Row-Operations">Row Operations</a><a id="Row-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#Row-Operations" title="Permalink"></a></h2><p>Many tabular operations including <code>Join</code>, <code>Select</code> and <code>Where</code> are parameterized with row operations.  A <em>row operation</em> acts on an individual row of a dataset and produces a scalar value.  Row operations are assembled from literal values, column references, and applications of SQL functions and operators.  Below is a list of row operations available in FunSQL.</p><table><tr><th style="text-align: left">Constructor</th><th style="text-align: left">Function</th></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.Agg-Tuple"><code>Agg</code></a></td><td style="text-align: left">apply an aggregate function</td></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.As-Tuple"><code>As</code></a></td><td style="text-align: left">assign a column alias</td></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.Bind-Tuple"><code>Bind</code></a></td><td style="text-align: left">correlate a subquery</td></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.Fun-Tuple"><code>Fun</code></a></td><td style="text-align: left">apply a scalar function or a scalar operator</td></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.Get-Tuple"><code>Get</code></a></td><td style="text-align: left">produce the value of a column</td></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.Lit-Tuple"><code>Lit</code></a></td><td style="text-align: left">produce a constant value</td></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.Sort-Tuple"><code>Sort</code></a></td><td style="text-align: left">indicate the sort order</td></tr><tr><td style="text-align: left"><a href="../api/#FunSQL.Var-Tuple"><code>Var</code></a></td><td style="text-align: left">produce the value of a query parameter</td></tr></table><h2 id="Lit"><a class="docs-heading-anchor" href="#Lit"><code>Lit</code></a><a id="Lit-1"></a><a class="docs-heading-anchor-permalink" href="#Lit" title="Permalink"></a></h2><p>The <code>Lit</code> constructor creates a literal value, although we could usually omit the constructor:</p><pre><code class="language-julia hljs">using FunSQL: Lit

Select(Lit(42))
Select(42)</code></pre><p>The SQL value <code>NULL</code> is represented by the Julia constant <code>missing</code>:</p><pre><code class="language-julia hljs">q = Select(missing)

sql = render(q, dialect = :sqlite)

print(sql)
#-&gt; SELECT NULL AS &quot;_&quot;</code></pre><h2 id="Get"><a class="docs-heading-anchor" href="#Get"><code>Get</code></a><a id="Get-1"></a><a class="docs-heading-anchor-permalink" href="#Get" title="Permalink"></a></h2><p>The <code>Get</code> constructor creates a column reference.  <code>Get</code> admits several equivalent forms:</p><pre><code class="language-julia hljs">Get.year_of_birth
Get(:year_of_birth)
Get.&quot;year_of_birth&quot;
Get(&quot;year_of_birth&quot;)</code></pre><p>Such column references are resolved at the place of use against the input dataset.  As we mentioned earlier, sometimes column references cannot be resolved unambiguously.  To alleviate this problem, we can bind the column reference to the node that produces it:</p><p><em>Show all patients with their state of residence.</em></p><pre><code class="language-julia hljs">qₚ = From(person)
qₗ = From(location)
q = qₚ |&gt;
    LeftJoin(qₗ, on = qₚ.location_id .== qₗ.location_id) |&gt;
    Select(qₚ.person_id, qₗ.state)</code></pre><p>The notation <code>qₚ.location_id</code> and <code>qₗ.location_id</code> is just syntax sugar for</p><pre><code class="language-julia hljs">qₚ |&gt; Get(:location_id)
qₗ |&gt; Get(:location_id)</code></pre><h2 id="Fun"><a class="docs-heading-anchor" href="#Fun"><code>Fun</code></a><a id="Fun-1"></a><a class="docs-heading-anchor-permalink" href="#Fun" title="Permalink"></a></h2><p>SQL functions and operators are represented using the <code>Fun</code> constructor, which also has several equivalent forms:</p><pre><code class="language-julia hljs">Fun.between(Get.year_of_birth, 1930, 1940)
Fun(:between, Get.year_of_birth, 1930, 1940)
Fun.&quot;between&quot;(Get.year_of_birth, 1930, 1940)
Fun(&quot;between&quot;, Get.year_of_birth, 1930, 1940)</code></pre><p>Certain SQL operators, notably comparison operators, can be represented using Julia broadcasting notation:</p><pre><code class="language-julia hljs">Fun.&quot;&gt;=&quot;(Get.year_of_birth, 1930)
Get.year_of_birth .&gt;= 1930</code></pre><p>We should note that FunSQL does not verify if a SQL function or an operator is used correctly or even whether it exists or not.  In such a case, FunSQL will generate a SQL query that fails to execute:</p><pre><code class="language-julia hljs">q = From(person) |&gt;
    Select(Fun.frobnicate(Get.year_of_birth))

sql = render(q, dialect = :sqlite)

print(sql)
#=&gt;
SELECT FROBNICATE(&quot;person_1&quot;.&quot;year_of_birth&quot;) AS &quot;frobnicate&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
=#

DBInterface.execute(conn, sql)
#-&gt; ERROR: SQLite.SQLiteException(&quot;no such function: FROBNICATE&quot;)</code></pre><p>On the other hand, FunSQL will correctly serialize many SQL functions and operators that have irregular syntax including <code>AND</code>, <code>OR</code>, <code>NOT</code>, <code>IN</code>, <code>EXISTS</code>, <code>CASE</code>, and others:</p><p><em>Show the demographic cohort of each patient.</em></p><pre><code class="language-julia hljs">q = From(person) |&gt;
    Select(Fun.case(Get.year_of_birth .&lt;= 1960, &quot;boomer&quot;, &quot;millenial&quot;))

sql = render(q, dialect = :sqlite)

print(sql)
#=&gt;
SELECT (CASE WHEN (&quot;person_1&quot;.&quot;year_of_birth&quot; &lt;= 1960) THEN &#39;boomer&#39; ELSE &#39;millenial&#39; END) AS &quot;case&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
=#</code></pre><h2 id="Query-Parameters"><a class="docs-heading-anchor" href="#Query-Parameters">Query Parameters</a><a id="Query-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Query-Parameters" title="Permalink"></a></h2><p>A SQL query may include a reference to a <em>query parameter</em>.  When we execute such a query, we must supply the actual values for all parameters used in the query.  This is a restricted form of dynamic query construction directly supported by SQL syntax.</p><p><em>Show all patients born between <code>$start_year</code> and <code>$end_year</code>.</em></p><pre><code class="language-julia hljs">sql = &quot;&quot;&quot;
SELECT p.person_id
FROM person p
WHERE p.year_of_birth BETWEEN ? AND ?
&quot;&quot;&quot;

res = DBInterface.execute(conn, sql, (1930, 1940))

DataFrame(res)
#=&gt;
3×1 DataFrame
 Row │ person_id
     │ Int64
─────┼───────────
   1 │      1780
   2 │     30091
   3 │     72120
=#</code></pre><p>FunSQL can be used to construct a query with parameters.  Similar to <code>Get</code>, parameter references are created using the constructor <code>Var</code>.</p><pre><code class="language-julia hljs">using FunSQL: Var

q = From(person) |&gt;
    Where(Fun.between(Get.year_of_birth, Var.start_year, Var.end_year)) |&gt;
    Select(Get.person_id)

sql = render(q, dialect = :sqlite)

print(sql)
#=&gt;
SELECT &quot;person_1&quot;.&quot;person_id&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
WHERE (&quot;person_1&quot;.&quot;year_of_birth&quot; BETWEEN ?1 AND ?2)
=#</code></pre><p>While we specified parameters by name, in the generated SQL query the same parameters are numbered.  If we know the values of the parameters and we wish to execute the query with them, we need to pack the values in the order in which parameters appear in the SQL query:</p><pre><code class="language-julia hljs">using FunSQL: pack

params = pack(sql, (start_year = 1930, end_year = 1940))
#-&gt; Any[1930, 1940]

res = DBInterface.execute(conn, sql, params)

DataFrame(res)
#=&gt;
3×1 DataFrame
 Row │ person_id
     │ Int64
─────┼───────────
   1 │      1780
   2 │     30091
   3 │     72120
=#</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../api/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Wednesday 20 October 2021 16:07">Wednesday 20 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
