<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SQL Clauses · FunSQL.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FunSQL.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../api/">API Reference</a></li><li><a class="tocitem" href="../">Test Suite</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>SQL Clauses</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SQL Clauses</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/master/docs/src/test/clauses.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SQL-Clauses"><a class="docs-heading-anchor" href="#SQL-Clauses">SQL Clauses</a><a id="SQL-Clauses-1"></a><a class="docs-heading-anchor-permalink" href="#SQL-Clauses" title="Permalink"></a></h1><pre><code class="language-julia">using FunSQL: AS, CASE, ID, KW, LIT, FROM, FUN, OP, SELECT, WHERE, render</code></pre><p>The syntactic structure of a SQL query is represented as a tree of <code>SQLClause</code> objects.  Different types of clauses are created by specialized constructors and connected using the chain (<code>|&gt;</code>) operator.</p><pre><code class="language-julia">c = FROM(:person) |&gt;
    SELECT(:person_id, :year_of_birth)
#-&gt; (…) |&gt; SELECT(…)</code></pre><p>Displaying a <code>SQLClause</code> object shows how it was constructed.</p><pre><code class="language-julia">display(c)
#-&gt; ID(:person) |&gt; FROM() |&gt; SELECT(ID(:person_id), ID(:year_of_birth))</code></pre><p>A <code>SQLClause</code> object wraps a concrete clause object, which can be accessed using the indexing operator.</p><pre><code class="language-julia">c[]
#-&gt; ((…) |&gt; SELECT(…))[]

display(c[])
#-&gt; (ID(:person) |&gt; FROM() |&gt; SELECT(ID(:person_id), ID(:year_of_birth)))[]</code></pre><p>To generate SQL, we use function <code>render()</code>.</p><pre><code class="language-julia">print(render(c))
#=&gt;
SELECT &quot;person_id&quot;, &quot;year_of_birth&quot;
FROM &quot;person&quot;
=#</code></pre><h2 id="SQL-Literals"><a class="docs-heading-anchor" href="#SQL-Literals">SQL Literals</a><a id="SQL-Literals-1"></a><a class="docs-heading-anchor-permalink" href="#SQL-Literals" title="Permalink"></a></h2><p>A SQL literal is created using a <code>LIT()</code> constructor.</p><pre><code class="language-julia">c = LIT(&quot;SQL is fun!&quot;)
#-&gt; LIT(&quot;SQL is fun!&quot;)</code></pre><p>Values of certain Julia data types are automatically converted to SQL literals when they are used in the context of a SQL clause.</p><pre><code class="language-julia">using Dates

c = SELECT(missing, true, 42, &quot;SQL is fun!&quot;, Date(2000))

#? VERSION &gt;= v&quot;1.5.0&quot;
display(c)
#=&gt;
SELECT(LIT(missing),
       LIT(true),
       LIT(42),
       LIT(&quot;SQL is fun!&quot;),
       LIT(Dates.Date(&quot;2000-01-01&quot;)))
=#

print(render(c))
#-&gt; SELECT NULL, TRUE, 42, &#39;SQL is fun!&#39;, &#39;2000-01-01&#39;</code></pre><h2 id="SQL-Identifiers"><a class="docs-heading-anchor" href="#SQL-Identifiers">SQL Identifiers</a><a id="SQL-Identifiers-1"></a><a class="docs-heading-anchor-permalink" href="#SQL-Identifiers" title="Permalink"></a></h2><p>A SQL identifier is created with <code>ID()</code> constructor.</p><pre><code class="language-julia">c = ID(:person)
#-&gt; ID(:person)

display(c)
#-&gt; ID(:person)

print(render(c))
#-&gt; &quot;person&quot;</code></pre><p>A quoted identifier is created using pipeline notation.</p><pre><code class="language-julia">c = ID(:person) |&gt; ID(:year_of_birth)
#-&gt; (…) |&gt; ID(:year_of_birth)

display(c)
#-&gt; ID(:person) |&gt; ID(:year_of_birth)

print(render(c))
#-&gt; &quot;person&quot;.&quot;year_of_birth&quot;</code></pre><p>Symbols and pairs of symbols are automatically converted to SQL identifiers when they are used in the context of a SQL clause.</p><pre><code class="language-julia">c = FROM(:p =&gt; :person) |&gt; SELECT((:p, :person_id))
display(c)
#-&gt; ID(:person) |&gt; AS(:p) |&gt; FROM() |&gt; SELECT(ID(:p) |&gt; ID(:person_id))

print(render(c))
#=&gt;
SELECT &quot;p&quot;.&quot;person_id&quot;
FROM &quot;person&quot; AS &quot;p&quot;
=#</code></pre><h2 id="SQL-Functions"><a class="docs-heading-anchor" href="#SQL-Functions">SQL Functions</a><a id="SQL-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#SQL-Functions" title="Permalink"></a></h2><p>An application of a SQL function is created with <code>FUN()</code> constructor.</p><pre><code class="language-julia">c = FUN(&quot;CONCAT&quot;, :city, &quot;, &quot;, :state)
#-&gt; FUN(&quot;CONCAT&quot;, …)

display(c)
#-&gt; FUN(&quot;CONCAT&quot;, ID(:city), LIT(&quot;, &quot;), ID(:state))

print(render(c))
#-&gt; CONCAT(&quot;city&quot;, &#39;, &#39;, &quot;state&quot;)</code></pre><p>A function with special separators can be constructed using <code>KW()</code> clause.</p><pre><code class="language-julia">c = FUN(&quot;SUBSTRING&quot;, :zip, KW(&quot;FROM&quot;, 1), KW(&quot;FOR&quot;, 3))
#-&gt; FUN(&quot;SUBSTRING&quot;, …)

display(c)
#-&gt; FUN(&quot;SUBSTRING&quot;, ID(:zip), LIT(1) |&gt; KW(:FROM), LIT(3) |&gt; KW(:FOR))

print(render(c))
#-&gt; SUBSTRING(&quot;zip&quot; FROM 1 FOR 3)</code></pre><p>Functions without arguments are permitted.</p><pre><code class="language-julia">c = FUN(&quot;NOW&quot;)
#-&gt; FUN(&quot;NOW&quot;)

print(render(c))
#-&gt; NOW()</code></pre><h2 id="SQL-Operators"><a class="docs-heading-anchor" href="#SQL-Operators">SQL Operators</a><a id="SQL-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#SQL-Operators" title="Permalink"></a></h2><p>An application of a SQL operator is created with <code>OP()</code> constructor.</p><pre><code class="language-julia">c = OP(&quot;NOT&quot;, OP(&quot;=&quot;, :zip, &quot;60614&quot;))
#-&gt; OP(&quot;NOT&quot;, …)

display(c)
#-&gt; OP(&quot;NOT&quot;, OP(&quot;=&quot;, ID(:zip), LIT(&quot;60614&quot;)))

print(render(c))
#-&gt; (NOT (&quot;zip&quot; = &#39;60614&#39;))</code></pre><p>An operator without arguments can be constructed, if necessary.</p><pre><code class="language-julia">c = OP(&quot;CURRENT_TIMESTAMP&quot;)
#-&gt; OP(&quot;CURRENT_TIMESTAMP&quot;)

print(render(c))
#-&gt; CURRENT_TIMESTAMP</code></pre><p>A composite operator can be constructed with the help of <code>KW()</code> clause.</p><pre><code class="language-julia">c = OP(&quot;BETWEEN&quot;, :year_of_birth, 2000, KW(:AND, 2020))

print(render(c))
#-&gt; (&quot;year_of_birth&quot; BETWEEN 2000 AND 2020)</code></pre><h2 id="CASE-Expression"><a class="docs-heading-anchor" href="#CASE-Expression"><code>CASE</code> Expression</a><a id="CASE-Expression-1"></a><a class="docs-heading-anchor-permalink" href="#CASE-Expression" title="Permalink"></a></h2><p>A <code>CASE</code> expression is created with <code>CASE()</code> constructor.</p><pre><code class="language-julia">c = CASE(OP(&quot;&lt;&quot;, :year_of_birth, 1970), &quot;boomer&quot;)
#-&gt; CASE(…)

display(c)
#-&gt; CASE(OP(&quot;&lt;&quot;, ID(:year_of_birth), LIT(1970)), LIT(&quot;boomer&quot;))

print(render(c))
#-&gt; (CASE WHEN (&quot;year_of_birth&quot; &lt; 1970) THEN &#39;boomer&#39; END)</code></pre><p>The arguments of <code>CASE</code> form an interleaving sequence of conditions and the corresponding values.  When <code>CASE</code> has an odd number of arguments, the last argument provides the default value.</p><pre><code class="language-julia">c = CASE(OP(&quot;&lt;&quot;, :year_of_birth, 1970), &quot;boomer&quot;, &quot;millenial&quot;)

print(render(c))
#-&gt; (CASE WHEN (&quot;year_of_birth&quot; &lt; 1970) THEN &#39;boomer&#39; ELSE &#39;millenial&#39; END)</code></pre><p>An invalid <code>CASE</code> expression can be constructed.</p><pre><code class="language-julia">c = CASE(args = [])
#-&gt; CASE(args = [])</code></pre><h2 id="AS-Clause"><a class="docs-heading-anchor" href="#AS-Clause"><code>AS</code> Clause</a><a id="AS-Clause-1"></a><a class="docs-heading-anchor-permalink" href="#AS-Clause" title="Permalink"></a></h2><p>An <code>AS</code> clause is created with <code>AS()</code> constructor.</p><pre><code class="language-julia">c = ID(:person) |&gt; AS(:p)
#-&gt; (…) |&gt; AS(:p)

display(c)
#-&gt; ID(:person) |&gt; AS(:p)

print(render(c))
#-&gt; &quot;person&quot; AS &quot;p&quot;</code></pre><p>A pair expression is automatically converted to an <code>AS</code> clause.</p><pre><code class="language-julia">c = FROM(:p =&gt; :person)
display(c)
#-&gt; ID(:person) |&gt; AS(:p) |&gt; FROM()

print(render(c |&gt; SELECT((:p, :person_id))))
#=&gt;
SELECT &quot;p&quot;.&quot;person_id&quot;
FROM &quot;person&quot; AS &quot;p&quot;
=#</code></pre><h2 id="FROM-Clause"><a class="docs-heading-anchor" href="#FROM-Clause"><code>FROM</code> Clause</a><a id="FROM-Clause-1"></a><a class="docs-heading-anchor-permalink" href="#FROM-Clause" title="Permalink"></a></h2><p>A <code>FROM</code> clause is created with <code>FROM()</code> constructor.</p><pre><code class="language-julia">c = FROM(:person)
#-&gt; (…) |&gt; FROM()

display(c)
#-&gt; ID(:person) |&gt; FROM()

print(render(c |&gt; SELECT(:person_id)))
#=&gt;
SELECT &quot;person_id&quot;
FROM &quot;person&quot;
=#</code></pre><h2 id="SELECT-Clause"><a class="docs-heading-anchor" href="#SELECT-Clause"><code>SELECT</code> Clause</a><a id="SELECT-Clause-1"></a><a class="docs-heading-anchor-permalink" href="#SELECT-Clause" title="Permalink"></a></h2><p>A <code>SELECT</code> clause is created with <code>SELECT()</code> constructor.  While in SQL, <code>SELECT</code> typically opens a query, in FunSQL, <code>SELECT()</code> should be placed at the end of a clause chain.</p><pre><code class="language-julia">c = :person |&gt; FROM() |&gt; SELECT(:person_id, :year_of_birth)
#-&gt; (…) |&gt; SELECT(…)

display(c)
#-&gt; ID(:person) |&gt; FROM() |&gt; SELECT(ID(:person_id), ID(:year_of_birth))

print(render(c))
#=&gt;
SELECT &quot;person_id&quot;, &quot;year_of_birth&quot;
FROM &quot;person&quot;
=#</code></pre><p>The <code>DISTINCT</code> modifier can be added from the constructor.</p><pre><code class="language-julia">c = FROM(:location) |&gt; SELECT(distinct = true, :zip)
#-&gt; (…) |&gt; SELECT(…)

display(c)
#-&gt; ID(:location) |&gt; FROM() |&gt; SELECT(distinct = true, ID(:zip))

print(render(c))
#=&gt;
SELECT DISTINCT &quot;zip&quot;
FROM &quot;location&quot;
=#</code></pre><p>A <code>SELECT</code> clause with an empty list can be created explicitly.</p><pre><code class="language-julia">c = SELECT(list = [])
#-&gt; SELECT(…)</code></pre><p>Rendering a nested <code>SELECT</code> clause adds parentheses around it.</p><pre><code class="language-julia">c = :location |&gt; FROM() |&gt; SELECT(:state, :zip) |&gt; FROM() |&gt; SELECT(:zip)

print(render(c))
#=&gt;
SELECT &quot;zip&quot;
FROM (
  SELECT &quot;state&quot;, &quot;zip&quot;
  FROM &quot;location&quot;
)
=#</code></pre><h2 id="WHERE-Clause"><a class="docs-heading-anchor" href="#WHERE-Clause"><code>WHERE</code> Clause</a><a id="WHERE-Clause-1"></a><a class="docs-heading-anchor-permalink" href="#WHERE-Clause" title="Permalink"></a></h2><p>A <code>WHERE</code> clause is created with <code>WHERE()</code> constructor.</p><pre><code class="language-julia">c = FROM(:person) |&gt; WHERE(OP(&quot;&gt;&quot;, :year_of_birth, 2000))
#-&gt; (…) |&gt; WHERE(…)

display(c)
#-&gt; ID(:person) |&gt; FROM() |&gt; WHERE(OP(&quot;&gt;&quot;, ID(:year_of_birth), LIT(2000)))

print(render(c |&gt; SELECT(:person_id)))
#=&gt;
SELECT &quot;person_id&quot;
FROM &quot;person&quot;
WHERE (&quot;year_of_birth&quot; &gt; 2000)
=#</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 13 April 2021 15:27">Tuesday 13 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
