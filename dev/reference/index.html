<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · FunSQL.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FunSQL.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guide/">Usage Guide</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#SQL-Dialects"><span>SQL Dialects</span></a></li><li><a class="tocitem" href="#SQL-Entities"><span>SQL Entities</span></a></li><li><a class="tocitem" href="#SQL-Statements"><span>SQL Statements</span></a></li><li><a class="tocitem" href="#Semantic-Structure"><span>Semantic Structure</span></a></li><li><a class="tocitem" href="#Syntactic-Structure"><span>Syntactic Structure</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../test/">Test Suite</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="FunSQL.FunSQLError" href="#FunSQL.FunSQLError"><code>FunSQL.FunSQLError</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Base error class for all errors raised by FunSQL.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/FunSQL.jl#L20-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.render" href="#FunSQL.render"><code>FunSQL.render</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">render(node::Union{SQLNode, SQLClause}; dialect = :default)::SQLStatement</code></pre><p>Convert the given SQL node or clause object to a SQL string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/FunSQL.jl#L12-L16">source</a></section></article><h2 id="SQL-Dialects"><a class="docs-heading-anchor" href="#SQL-Dialects">SQL Dialects</a><a id="SQL-Dialects-1"></a><a class="docs-heading-anchor-permalink" href="#SQL-Dialects" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FunSQL.SQLDialect" href="#FunSQL.SQLDialect"><code>FunSQL.SQLDialect</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SQLDialect(; name = :default,
             variable_style = :named,
             variable_prefix = &#39;:&#39;,
             identifier_quotes = (&#39;&quot;&#39;, &#39;&quot;&#39;),
             has_boolean_literals = true,
             limit_style = :ansi)
SQLDialect(template::SQLDialect; kws...)
SQLDialect(name::Symbol, kws...)</code></pre><p>Properties and capabilities of a particular SQL dialect.</p><p>Use the constructor <code>SQLDialect(name::Symbol)</code> to create one of the known dialects: <code>:postgresql</code>, <code>:sqlite</code>, <code>:mysql</code>, <code>:redshift</code>, <code>:sqlserver</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/dialects.jl#L47-L61">source</a></section></article><h2 id="SQL-Entities"><a class="docs-heading-anchor" href="#SQL-Entities">SQL Entities</a><a id="SQL-Entities-1"></a><a class="docs-heading-anchor-permalink" href="#SQL-Entities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FunSQL.SQLTable" href="#FunSQL.SQLTable"><code>FunSQL.SQLTable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SQLTable(; schema = nothing, name, columns)
SQLTable(name; schema = nothing, columns)
SQLTable(name, columns...; schema = nothing)</code></pre><p>The structure of a SQL table or a table-like entity (TEMP TABLE, VIEW, etc) for use as a reference in assembling SQL queries.</p><p>The <code>SQLTable</code> constructor expects the table <code>name</code>, a vector <code>columns</code> of column names, and, optionally, the name of the table <code>schema</code>.  A name can be provided as a <code>Symbol</code> or <code>String</code> value.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = SQLTable(:location,
                    :location_id, :address_1, :address_2, :city, :state, :zip);


julia&gt; show(t.name)
:location

julia&gt; show(t.columns)
[:location_id, :address_1, :address_2, :city, :state, :zip]</code></pre><pre><code class="language-julia-repl hljs">julia&gt; t = SQLTable(schema = &quot;public&quot;,
                    name = &quot;person&quot;,
                    columns = [&quot;person_id&quot;, &quot;birth_datetime&quot;, &quot;location_id&quot;]);

julia&gt; show(t.schema)
:public

julia&gt; show(t.name)
:person

julia&gt; show(t.columns)
[:person_id, :birth_datetime, :location_id]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/entities.jl#L3-L43">source</a></section></article><h2 id="SQL-Statements"><a class="docs-heading-anchor" href="#SQL-Statements">SQL Statements</a><a id="SQL-Statements-1"></a><a class="docs-heading-anchor-permalink" href="#SQL-Statements" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FunSQL.SQLStatement" href="#FunSQL.SQLStatement"><code>FunSQL.SQLStatement</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Prepared SQL statement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/statements.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.pack" href="#FunSQL.pack"><code>FunSQL.pack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pack(stmt::SQLStatement, vars::Union{Dict, NamedTuple}) :: Vector{Any}</code></pre><p>Convert named parameters to positional form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/statements.jl#L36-L40">source</a></section></article><h2 id="Semantic-Structure"><a class="docs-heading-anchor" href="#Semantic-Structure">Semantic Structure</a><a id="Semantic-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Semantic-Structure" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FunSQL.AbstractSQLNode" href="#FunSQL.AbstractSQLNode"><code>FunSQL.AbstractSQLNode</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A SQL expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.SQLNode" href="#FunSQL.SQLNode"><code>FunSQL.SQLNode</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An opaque wrapper over an arbitrary SQL node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes.jl#L25-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Agg-Tuple" href="#FunSQL.Agg-Tuple"><code>FunSQL.Agg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Agg(; over = nothing, name, distinct = false, args = [], filter = nothing)
Agg(name; over = nothing, distinct = false, args = [], filter = nothing)
Agg(name, args...; over = nothing, distinct = false, filter = nothing)</code></pre><p>An application of an aggregate function.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Group(Get.year_of_birth) |&gt;
           Select(Get.year_of_birth, Agg.count());

julia&gt; print(render(q))
SELECT
  &quot;person_1&quot;.&quot;year_of_birth&quot;,
  COUNT(*) AS &quot;count&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
GROUP BY &quot;person_1&quot;.&quot;year_of_birth&quot;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Group() |&gt;
           Select(Agg.count(distinct = true, Get.year_of_birth));

julia&gt; print(render(q))
SELECT COUNT(DISTINCT &quot;person_1&quot;.&quot;year_of_birth&quot;) AS &quot;count&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id]);

julia&gt; visit_occurrence =
           SQLTable(:visit_occurrence, columns = [:visit_occurrence_id, :person_id, :visit_start_date]);

julia&gt; q = From(person) |&gt;
           LeftJoin(:visit_group =&gt; From(visit_occurrence) |&gt;
                                    Group(Get.person_id),
                    on = (Get.person_id .== Get.visit_group.person_id)) |&gt;
           Select(Get.person_id,
                  :max_visit_start_date =&gt;
                      Get.visit_group |&gt; Agg.max(Get.visit_start_date));

julia&gt; print(render(q))
SELECT
  &quot;person_1&quot;.&quot;person_id&quot;,
  &quot;visit_group_1&quot;.&quot;max&quot; AS &quot;max_visit_start_date&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
LEFT JOIN (
  SELECT
    &quot;visit_occurrence_1&quot;.&quot;person_id&quot;,
    MAX(&quot;visit_occurrence_1&quot;.&quot;visit_start_date&quot;) AS &quot;max&quot;
  FROM &quot;visit_occurrence&quot; AS &quot;visit_occurrence_1&quot;
  GROUP BY &quot;visit_occurrence_1&quot;.&quot;person_id&quot;
) AS &quot;visit_group_1&quot; ON (&quot;person_1&quot;.&quot;person_id&quot; = &quot;visit_group_1&quot;.&quot;person_id&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/aggregate.jl#L25-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Append-Tuple" href="#FunSQL.Append-Tuple"><code>FunSQL.Append</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Append(; over = nothing, args)
Append(args...; over = nothing)</code></pre><p><code>Append</code> concatenates input datasets.</p><pre><code class="language-sql hljs">SELECT ...
FROM $over
UNION ALL
SELECT ...
FROM $(args[1])
UNION ALL
...</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; measurement = SQLTable(:measurement, columns = [:measurement_id, :person_id, :measurement_date]);

julia&gt; observation = SQLTable(:observation, columns = [:observation_id, :person_id, :observation_date]);

julia&gt; q = From(measurement) |&gt;
           Define(:date =&gt; Get.measurement_date) |&gt;
           Append(From(observation) |&gt;
                  Define(:date =&gt; Get.observation_date)) |&gt;
           Select(Get.person_id, Get.date);

julia&gt; print(render(q))
SELECT
  &quot;union_1&quot;.&quot;person_id&quot;,
  &quot;union_1&quot;.&quot;date&quot;
FROM (
  SELECT
    &quot;measurement_1&quot;.&quot;person_id&quot;,
    &quot;measurement_1&quot;.&quot;measurement_date&quot; AS &quot;date&quot;
  FROM &quot;measurement&quot; AS &quot;measurement_1&quot;
  UNION ALL
  SELECT
    &quot;observation_1&quot;.&quot;person_id&quot;,
    &quot;observation_1&quot;.&quot;observation_date&quot; AS &quot;date&quot;
  FROM &quot;observation&quot; AS &quot;observation_1&quot;
) AS &quot;union_1&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/append.jl#L14-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.As-Tuple" href="#FunSQL.As-Tuple"><code>FunSQL.As</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">As(; over = nothing, name)
As(name; over = nothing)
name =&gt; over</code></pre><p>In a scalar context, <code>As</code> specifies the name of the output column.  When applied to a tabular node, <code>As</code> wraps the output of the node in a nested record.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           As(:p) |&gt;
           Select(:birth_year =&gt; Get.p.year_of_birth);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/as.jl#L16-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Bind-Tuple" href="#FunSQL.Bind-Tuple"><code>FunSQL.Bind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Bind(; over = nothing; args)
Bind(args...; over = nothing)</code></pre><p>The <code>Bind</code> node binds the query parameters in an inner query to make it a correlated subquery.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id]);

julia&gt; visit_occurrence = SQLTable(:visit_occurrence, columns = [:visit_occurrence_id, :person_id]);

julia&gt; q = From(person) |&gt;
           Where(Fun.exists(From(visit_occurrence) |&gt;
                            Where(Get.person_id .== Var.person_id) |&gt;
                            Bind(Get.person_id)));

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;person_id&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
WHERE (EXISTS (
  SELECT NULL
  FROM &quot;visit_occurrence&quot; AS &quot;visit_occurrence_1&quot;
  WHERE (&quot;visit_occurrence_1&quot;.&quot;person_id&quot; = &quot;person_1&quot;.&quot;person_id&quot;)
))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/bind.jl#L22-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Define-Tuple" href="#FunSQL.Define-Tuple"><code>FunSQL.Define</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Define(; over; args = [])
Define(args...; over)</code></pre><p><code>Define</code> adds a column to the output.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :birth_datetime]);

julia&gt; q = From(person) |&gt;
           Define(:age =&gt; Fun.now() .- Get.birth_datetime) |&gt;
           Where(Get.age .&gt; &quot;16 years&quot;);

julia&gt; print(render(q))
SELECT
  &quot;person_1&quot;.&quot;person_id&quot;,
  &quot;person_1&quot;.&quot;birth_datetime&quot;,
  (NOW() - &quot;person_1&quot;.&quot;birth_datetime&quot;) AS &quot;age&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
WHERE ((NOW() - &quot;person_1&quot;.&quot;birth_datetime&quot;) &gt; &#39;16 years&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/define.jl#L22-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.From-Tuple" href="#FunSQL.From-Tuple"><code>FunSQL.From</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">From(; source)
From(source)</code></pre><p><code>From</code> outputs the content of a database table.  The parameter <code>source</code> could be a <a href="#FunSQL.SQLTable"><code>SQLTable</code></a> object, a symbol (for use with <a href="#FunSQL.With-Tuple"><code>With</code></a>), or <code>nothing</code>.</p><pre><code class="language-sql hljs">SELECT ...
FROM $source</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person);

julia&gt; print(render(q))
SELECT
  &quot;person_1&quot;.&quot;person_id&quot;,
  &quot;person_1&quot;.&quot;year_of_birth&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; condition_occurrence =
           SQLTable(:condition_occurrence, columns = [:condition_occurrence_id,
                                                      :person_id,
                                                      :condition_concept_id]);

julia&gt; q = From(person) |&gt;
           Where(Fun.in(Get.person_id, From(:essential_hypertension) |&gt;
                                       Select(Get.person_id))) |&gt;
           With(:essential_hypertension =&gt;
                    From(condition_occurrence) |&gt;
                    Where(Get.condition_concept_id .== 320128));

julia&gt; print(render(q))
WITH &quot;essential_hypertension_1&quot; (&quot;person_id&quot;) AS (
  SELECT &quot;condition_occurrence_1&quot;.&quot;person_id&quot;
  FROM &quot;condition_occurrence&quot; AS &quot;condition_occurrence_1&quot;
  WHERE (&quot;condition_occurrence_1&quot;.&quot;condition_concept_id&quot; = 320128)
)
SELECT
  &quot;person_1&quot;.&quot;person_id&quot;,
  &quot;person_1&quot;.&quot;year_of_birth&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
WHERE (&quot;person_1&quot;.&quot;person_id&quot; IN (
  SELECT &quot;essential_hypertension_1&quot;.&quot;person_id&quot;
  FROM &quot;essential_hypertension_1&quot;
))</code></pre><pre><code class="language-julia-repl hljs">julia&gt; q = From(nothing);

julia&gt; print(render(q))
SELECT NULL</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/from.jl#L13-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Fun-Tuple" href="#FunSQL.Fun-Tuple"><code>FunSQL.Fun</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Fun(; name, args = [])
Fun(name; args = [])
Fun(name, args...)</code></pre><p>A function or an operator invocation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Where(Fun.not(Get.person_id .&gt; 2000));

julia&gt; print(render(q))
SELECT
  &quot;person_1&quot;.&quot;person_id&quot;,
  &quot;person_1&quot;.&quot;year_of_birth&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
WHERE (NOT (&quot;person_1&quot;.&quot;person_id&quot; &gt; 2000))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/function.jl#L19-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Get-Tuple" href="#FunSQL.Get-Tuple"><code>FunSQL.Get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Get(; over, name)
Get(name; over)
Get.name        Get.&quot;name&quot;      Get[name]       Get[&quot;name&quot;]
over.name       over.&quot;name&quot;     over[name]      over[&quot;name&quot;]</code></pre><p>A reference to a table column.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           As(:p) |&gt;
           Select(Get.p.person_id);</code></pre><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person);

julia&gt; q = q |&gt; Select(q.person_id);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/get.jl#L16-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Group-Tuple" href="#FunSQL.Group-Tuple"><code>FunSQL.Group</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Group(; over; by = [])
Group(by...; over)</code></pre><p>The <code>Group</code> node partitions the input rows into disjoint groups <code>by</code> the given grouping key and outputs all unique values of the key.  Aggregate functions applied to the output of <code>Group</code> summarize the values from the rows of each group.</p><pre><code class="language-sql hljs">SELECT ...
FROM $over
GROUP BY $by...</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Group(Get.year_of_birth) |&gt;
           Select(Get.year_of_birth, Agg.count());

julia&gt; print(render(q))
SELECT
  &quot;person_1&quot;.&quot;year_of_birth&quot;,
  COUNT(*) AS &quot;count&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
GROUP BY &quot;person_1&quot;.&quot;year_of_birth&quot;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Group() |&gt;
           Select(Agg.count(distinct = true, Get.year_of_birth));

julia&gt; print(render(q))
SELECT COUNT(DISTINCT &quot;person_1&quot;.&quot;year_of_birth&quot;) AS &quot;count&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/group.jl#L22-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Highlight-Tuple" href="#FunSQL.Highlight-Tuple"><code>FunSQL.Highlight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Highlight(; over = nothing; color)
Highlight(color; over = nothing)</code></pre><p>Highlight <code>over</code> with the given <code>color</code>.</p><p>Available colors can be found in <code>Base.text_colors</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Get.person_id |&gt; Highlight(:bold);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/highlight.jl#L41-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Iterate-Tuple" href="#FunSQL.Iterate-Tuple"><code>FunSQL.Iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Iterate(; over = nothing, iterator)
Iterate(iterator; over = nothing)</code></pre><p><code>Iterate</code> generates the concatenated output of an iterated query.</p><p>The <code>over</code> query is evaluated first.  Then the <code>iterator</code> query is repeatedly applied: to the output of <code>over</code>, then to the output of its previous run, and so on, until the iterator produces no data.  All these outputs are concatenated to generate the output of <code>Iterate</code>.</p><p>The <code>iterator</code> query should have an alias specified with <a href="#FunSQL.As-Tuple"><code>As</code></a>; it can refer to the output of the previous iteration using <a href="#FunSQL.From-Tuple"><code>From</code></a> with the same alias.</p><pre><code class="language-sql hljs">WITH RECURSIVE iterator AS (
  SELECT ...
  FROM $over
  UNION ALL
  SELECT ...
  FROM $iterator
)
SELECT ...
FROM iterator</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Define(:n =&gt; 1, :f =&gt; 1) |&gt;
           Iterate(
               From(:factorial) |&gt;
               Define(:n =&gt; Get.n .+ 1) |&gt;
               Define(:f =&gt; Get.f .* Get.n) |&gt;
               Where(Get.n .&lt;= 10) |&gt;
               As(:factorial));

julia&gt; print(render(q))
WITH RECURSIVE &quot;factorial_1&quot; (&quot;n&quot;, &quot;f&quot;) AS (
  SELECT
    1 AS &quot;n&quot;,
    1 AS &quot;f&quot;
  UNION ALL
  SELECT
    (&quot;factorial_1&quot;.&quot;n&quot; + 1) AS &quot;n&quot;,
    (&quot;factorial_1&quot;.&quot;f&quot; * (&quot;factorial_1&quot;.&quot;n&quot; + 1)) AS &quot;f&quot;
  FROM &quot;factorial_1&quot;
  WHERE ((&quot;factorial_1&quot;.&quot;n&quot; + 1) &lt;= 10)
)
SELECT
  &quot;factorial_1&quot;.&quot;n&quot;,
  &quot;factorial_1&quot;.&quot;f&quot;
FROM &quot;factorial_1&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/iterate.jl#L14-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Join-Tuple" href="#FunSQL.Join-Tuple"><code>FunSQL.Join</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Join(; over = nothing, joinee, on, left = false, right = false, optional = optional)
Join(joinee; over = nothing, on, left = false, right = false, optional = optional)
Join(joinee, on; over = nothing, left = false, right = false, optional = optional)</code></pre><p><code>Join</code> correlates two input datasets.</p><p>When <code>optional</code> is set, the <code>JOIN</code> clause is omitted if the output contains no data from the <code>joinee</code> branch.</p><pre><code class="language-sql hljs">SELECT ...
FROM $over
JOIN $joinee ON $on</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :location_id]);

julia&gt; location = SQLTable(:location, columns = [:location_id, :state]);

julia&gt; q = person |&gt;
           Join(:location =&gt; location,
                Get.location_id .== Get.location.location_id) |&gt;
           Select(Get.person_id, Get.location.state);

julia&gt; print(render(q))
SELECT
  &quot;person_1&quot;.&quot;person_id&quot;,
  &quot;location_1&quot;.&quot;state&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
JOIN &quot;location&quot; AS &quot;location_1&quot; ON (&quot;person_1&quot;.&quot;location_id&quot; = &quot;location_1&quot;.&quot;location_id&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/join.jl#L21-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.LeftJoin-Tuple" href="#FunSQL.LeftJoin-Tuple"><code>FunSQL.LeftJoin</code></a> — <span class="docstring-category">Method</span></header><section><div><p>An alias for <code>Join(...; ..., left = true)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/join.jl#L60-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Limit-Tuple" href="#FunSQL.Limit-Tuple"><code>FunSQL.Limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Limit(; over = nothing, offset = nothing, limit = nothing)
Limit(limit; over = nothing, offset = nothing)
Limit(offset, limit; over = nothing)
Limit(start:stop; over = nothing)</code></pre><p>The <code>Limit</code> node skips the first <code>offset</code> rows and then emits the next <code>limit</code> rows.</p><pre><code class="language-sql hljs">SELECT ...
FROM $over
OFFSET $offset ROWS
FETCH NEXT $limit ROWS ONLY</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id]);

julia&gt; q = From(person) |&gt;
           Limit(1);

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;person_id&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
FETCH FIRST 1 ROW ONLY</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/limit.jl#L21-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Lit-Tuple" href="#FunSQL.Lit-Tuple"><code>FunSQL.Lit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Lit(; val)
Lit(val)</code></pre><p>A SQL literal.</p><p>In a scalar context, <code>missing</code>, numbers, strings and datetime values are automatically converted to SQL literals.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Select(:null =&gt; missing,
                  :boolean =&gt; true,
                  :integer =&gt; 42,
                  :text =&gt; &quot;SQL is fun!&quot;,
                  :date =&gt; Date(2000));

julia&gt; print(render(q))
SELECT
  NULL AS &quot;null&quot;,
  TRUE AS &quot;boolean&quot;,
  42 AS &quot;integer&quot;,
  &#39;SQL is fun!&#39; AS &quot;text&quot;,
  &#39;2000-01-01&#39; AS &quot;date&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/literal.jl#L13-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Order-Tuple" href="#FunSQL.Order-Tuple"><code>FunSQL.Order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Order(; over = nothing, by)
Order(by...; over = nothing)</code></pre><p><code>Order</code> sorts the input rows <code>by</code> the given key.</p><pre><code class="language-sql hljs">SELECT ...
FROM $over
ORDER BY $by...</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Order(Get.year_of_birth);

julia&gt; print(render(q))
SELECT
  &quot;person_1&quot;.&quot;person_id&quot;,
  &quot;person_1&quot;.&quot;year_of_birth&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
ORDER BY &quot;person_1&quot;.&quot;year_of_birth&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/order.jl#L14-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Partition-Tuple" href="#FunSQL.Partition-Tuple"><code>FunSQL.Partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Partition(; over, by = [], order_by = [], frame = nothing)
Partition(by...; over, order_by = [], frame = nothing)</code></pre><p>The <code>Partition</code> node specifies how to relate each row to the adjacent rows in the same dataset.  Aggregate functions applied to the output of <code>Partition</code> summarize the values of the related rows.</p><pre><code class="language-sql hljs">SELECT ...
FROM $over
WINDOW w AS (PARTITION BY $by... ORDER BY $order_by...)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Partition(Get.year_of_birth) |&gt;
           Select(Get.year_of_birth, Agg.row_number());

julia&gt; print(render(q))
SELECT
  &quot;person_1&quot;.&quot;year_of_birth&quot;,
  (ROW_NUMBER() OVER (PARTITION BY &quot;person_1&quot;.&quot;year_of_birth&quot;)) AS &quot;row_number&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Group(Get.year_of_birth) |&gt;
           Partition(order_by = [Get.year_of_birth],
                     frame = (mode = :range, start = -1, finish = 1)) |&gt;
           Select(Get.year_of_birth, Agg.avg(Agg.count()));

julia&gt; print(render(q))
SELECT
  &quot;person_1&quot;.&quot;year_of_birth&quot;,
  (AVG(COUNT(*)) OVER (ORDER BY &quot;person_1&quot;.&quot;year_of_birth&quot; RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING)) AS &quot;avg&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
GROUP BY &quot;person_1&quot;.&quot;year_of_birth&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/partition.jl#L16-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Select-Tuple" href="#FunSQL.Select-Tuple"><code>FunSQL.Select</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Select(; over; args)
Select(args...; over)</code></pre><p>The <code>Select</code> node specifies the output columns.</p><pre><code class="language-sql hljs">SELECT $args...
FROM $over</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Select(Get.person_id);

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;person_id&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/select.jl#L22-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Asc-Tuple{}" href="#FunSQL.Asc-Tuple{}"><code>FunSQL.Asc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Asc(; over = nothing, nulls = nothing)</code></pre><p>Ascending order indicator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/sort.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Desc-Tuple{}" href="#FunSQL.Desc-Tuple{}"><code>FunSQL.Desc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Desc(; over = nothing, nulls = nothing)</code></pre><p>Descending order indicator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/sort.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Sort-Tuple" href="#FunSQL.Sort-Tuple"><code>FunSQL.Sort</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Sort(; over = nothing, value, nulls = nothing)
Sort(value; over = nothing, nulls = nothing)
Asc(; over = nothing, nulls = nothing)
Desc(; over = nothing, nulls = nothing)</code></pre><p>Sort order indicator.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Order(Get.year_of_birth |&gt; Desc());

julia&gt; print(render(q))
SELECT
  &quot;person_1&quot;.&quot;person_id&quot;,
  &quot;person_1&quot;.&quot;year_of_birth&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
ORDER BY &quot;person_1&quot;.&quot;year_of_birth&quot; DESC</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/sort.jl#L18-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Var-Tuple" href="#FunSQL.Var-Tuple"><code>FunSQL.Var</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Var(; name)
Var(name)
Var.name        Var.&quot;name&quot;      Var[name]       Var[&quot;name&quot;]</code></pre><p>A reference to a query parameter.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Where(Get.year_of_birth .&gt; Var.year);

julia&gt; print(render(q))
SELECT
  &quot;person_1&quot;.&quot;person_id&quot;,
  &quot;person_1&quot;.&quot;year_of_birth&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
WHERE (&quot;person_1&quot;.&quot;year_of_birth&quot; &gt; :year)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/variable.jl#L13-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Where-Tuple" href="#FunSQL.Where-Tuple"><code>FunSQL.Where</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Where(; over = nothing, condition)
Where(condition; over = nothing)</code></pre><p>The <code>Where</code> node filters the input rows by the given <code>condition</code>.</p><pre><code class="language-sql hljs">SELECT ...
FROM $over
WHERE $condition</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Where(Fun(&quot;&gt;&quot;, Get.year_of_birth, 2000));

julia&gt; print(render(q))
SELECT
  &quot;person_1&quot;.&quot;person_id&quot;,
  &quot;person_1&quot;.&quot;year_of_birth&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
WHERE (&quot;person_1&quot;.&quot;year_of_birth&quot; &gt; 2000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/where.jl#L14-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.With-Tuple" href="#FunSQL.With-Tuple"><code>FunSQL.With</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">With(; over = nothing, args, materialized = nothing)
With(args...; over = nothing, materialized = nothing)</code></pre><p><code>With</code> assigns a name to a temporary dataset.  This dataset could be referred to by name in the <code>over</code> query.</p><pre><code class="nohighlight hljs">WITH $args...
SELECT ...
FROM $over</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; condition_occurrence =
           SQLTable(:condition_occurrence, columns = [:condition_occurrence_id,
                                                      :person_id,
                                                      :condition_concept_id]);

julia&gt; q = From(person) |&gt;
           Where(Fun.in(Get.person_id, From(:essential_hypertension) |&gt;
                                       Select(Get.person_id))) |&gt;
           With(:essential_hypertension =&gt;
                    From(condition_occurrence) |&gt;
                    Where(Get.condition_concept_id .== 320128));

julia&gt; print(render(q))
WITH &quot;essential_hypertension_1&quot; (&quot;person_id&quot;) AS (
  SELECT &quot;condition_occurrence_1&quot;.&quot;person_id&quot;
  FROM &quot;condition_occurrence&quot; AS &quot;condition_occurrence_1&quot;
  WHERE (&quot;condition_occurrence_1&quot;.&quot;condition_concept_id&quot; = 320128)
)
SELECT
  &quot;person_1&quot;.&quot;person_id&quot;,
  &quot;person_1&quot;.&quot;year_of_birth&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
WHERE (&quot;person_1&quot;.&quot;person_id&quot; IN (
  SELECT &quot;essential_hypertension_1&quot;.&quot;person_id&quot;
  FROM &quot;essential_hypertension_1&quot;
))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/with.jl#L23-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.WithExternal-Tuple" href="#FunSQL.WithExternal-Tuple"><code>FunSQL.WithExternal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">WithExternal(; over = nothing, args, schema = nothing, handler = nothing)
WithExternal(args...; over = nothing, schema = nothing, handler = nothing)</code></pre><p><code>WithExternal</code> assigns a name to a temporary dataset.  The dataset could be referred to by name in the <code>over</code> query.</p><p>The definition of the dataset is converted to a <code>Pair{SQLTable, SQLClause}</code> object and sent to <code>handler</code>, which can use it, for instance, to construct a <code>SELECT INTO</code> statement.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; condition_occurrence =
           SQLTable(:condition_occurrence, columns = [:condition_occurrence_id,
                                                      :person_id,
                                                      :condition_concept_id]);

julia&gt; handler((tbl, def)) =
           println(&quot;CREATE TEMP TABLE &quot;, render(ID(tbl.name)), &quot; AS\n&quot;,
                   render(def), &quot;;&quot;);

julia&gt; q = From(person) |&gt;
           Where(Fun.in(Get.person_id, From(:essential_hypertension) |&gt;
                                       Select(Get.person_id))) |&gt;
           WithExternal(:essential_hypertension =&gt;
                            From(condition_occurrence) |&gt;
                            Where(Get.condition_concept_id .== 320128),
                        handler = handler);

julia&gt; print(render(q))
CREATE TEMP TABLE &quot;essential_hypertension&quot; AS
SELECT &quot;condition_occurrence_1&quot;.&quot;person_id&quot;
FROM &quot;condition_occurrence&quot; AS &quot;condition_occurrence_1&quot;
WHERE (&quot;condition_occurrence_1&quot;.&quot;condition_concept_id&quot; = 320128);
SELECT
  &quot;person_1&quot;.&quot;person_id&quot;,
  &quot;person_1&quot;.&quot;year_of_birth&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
WHERE (&quot;person_1&quot;.&quot;person_id&quot; IN (
  SELECT &quot;essential_hypertension&quot;.&quot;person_id&quot;
  FROM &quot;essential_hypertension&quot;
))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/nodes/with_external.jl#L24-L71">source</a></section></article><h2 id="Syntactic-Structure"><a class="docs-heading-anchor" href="#Syntactic-Structure">Syntactic Structure</a><a id="Syntactic-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Syntactic-Structure" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FunSQL.AbstractSQLClause" href="#FunSQL.AbstractSQLClause"><code>FunSQL.AbstractSQLClause</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A part of a SQL query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.SQLClause" href="#FunSQL.SQLClause"><code>FunSQL.SQLClause</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An opaque wrapper over an arbitrary SQL clause.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses.jl#L21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.AGG-Tuple" href="#FunSQL.AGG-Tuple"><code>FunSQL.AGG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AGG(; name, distinct = false, args = [], filter = nothing, over = nothing)
AGG(name; distinct = false, args = [], filter = nothing, over = nothing)
AGG(name, args...; distinct = false, filter = nothing, over = nothing)</code></pre><p>An application of an aggregate function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = AGG(:COUNT, OP(&quot;*&quot;));

julia&gt; print(render(c))
COUNT(*)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = AGG(:COUNT, distinct = true, :year_of_birth);

julia&gt; print(render(c))
COUNT(DISTINCT &quot;year_of_birth&quot;)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = AGG(:COUNT, OP(&quot;*&quot;), filter = OP(&quot;&gt;&quot;, :year_of_birth, 1970));

julia&gt; print(render(c))
(COUNT(*) FILTER (WHERE (&quot;year_of_birth&quot; &gt; 1970)))</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = AGG(:ROW_NUMBER, over = PARTITION(:year_of_birth));

julia&gt; print(render(c))
(ROW_NUMBER() OVER (PARTITION BY &quot;year_of_birth&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/aggregate.jl#L25-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.AS-Tuple" href="#FunSQL.AS-Tuple"><code>FunSQL.AS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AS(; over = nothing, name, columns = nothing)
AS(name; over = nothing, columns = nothing)</code></pre><p>An <code>AS</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = ID(:person) |&gt; AS(:p);

julia&gt; print(render(c))
&quot;person&quot; AS &quot;p&quot;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = ID(:person) |&gt; AS(:p, columns = [:person_id, :year_of_birth]);

julia&gt; print(render(c))
&quot;person&quot; AS &quot;p&quot; (&quot;person_id&quot;, &quot;year_of_birth&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/as.jl#L21-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.CASE-Tuple" href="#FunSQL.CASE-Tuple"><code>FunSQL.CASE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CASE(; args)
CASE(args...)</code></pre><p>A <code>CASE</code> expression.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = CASE(OP(&quot;&lt;&quot;, :year_of_birth, 1970), &quot;boomer&quot;, &quot;millenial&quot;);

julia&gt; print(render(c))
(CASE WHEN (&quot;year_of_birth&quot; &lt; 1970) THEN &#39;boomer&#39; ELSE &#39;millenial&#39; END)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/case.jl#L13-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.FROM-Tuple" href="#FunSQL.FROM-Tuple"><code>FunSQL.FROM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FROM(; over = nothing)
FROM(over)</code></pre><p>A <code>FROM</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = ID(:person) |&gt; AS(:p) |&gt; FROM() |&gt; SELECT((:p, :person_id));

julia&gt; print(render(c))
SELECT &quot;p&quot;.&quot;person_id&quot;
FROM &quot;person&quot; AS &quot;p&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/from.jl#L13-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.FUN-Tuple" href="#FunSQL.FUN-Tuple"><code>FunSQL.FUN</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FUN(; name, args = [])
FUN(name; args = [])
FUN(name, args...)</code></pre><p>An invocation of a SQL function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FUN(:EXTRACT, OP(:YEAR), KW(:FROM, FUN(:NOW)));

julia&gt; print(render(c))
EXTRACT(YEAR FROM NOW())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/function.jl#L19-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.GROUP-Tuple" href="#FunSQL.GROUP-Tuple"><code>FunSQL.GROUP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GROUP(; over = nothing, by = [])
GROUP(by...; over = nothing)</code></pre><p>A <code>GROUP BY</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           GROUP(:year_of_birth) |&gt;
           SELECT(:year_of_birth, AGG(&quot;COUNT&quot;, OP(&quot;*&quot;)));

julia&gt; print(render(c))
SELECT
  &quot;year_of_birth&quot;,
  COUNT(*)
FROM &quot;person&quot;
GROUP BY &quot;year_of_birth&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/group.jl#L16-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.HAVING-Tuple" href="#FunSQL.HAVING-Tuple"><code>FunSQL.HAVING</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HAVING(; over = nothing, condition)
HAVING(condition; over = nothing)</code></pre><p>A <code>HAVING</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           GROUP(:year_of_birth) |&gt;
           HAVING(OP(&quot;&gt;&quot;, AGG(&quot;COUNT&quot;, OP(&quot;*&quot;)), 10)) |&gt;
           SELECT(:person_id);

julia&gt; print(render(c))
SELECT &quot;person_id&quot;
FROM &quot;person&quot;
GROUP BY &quot;year_of_birth&quot;
HAVING (COUNT(*) &gt; 10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/having.jl#L16-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.ID-Tuple" href="#FunSQL.ID-Tuple"><code>FunSQL.ID</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ID(; over = nothing, name)
ID(name; over = nothing)</code></pre><p>A SQL identifier.  Specify <code>over</code> or use the <code>|&gt;</code> operator to make a qualified identifier.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = ID(:person);

julia&gt; print(render(c))
&quot;person&quot;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = ID(:p) |&gt; ID(:birth_datetime);

julia&gt; print(render(c))
&quot;p&quot;.&quot;birth_datetime&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/identifier.jl#L16-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.JOIN-Tuple" href="#FunSQL.JOIN-Tuple"><code>FunSQL.JOIN</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">JOIN(; over = nothing, joinee, on, left = false, right = false, lateral = false)
JOIN(joinee; over = nothing, on, left = false, right = false, lateral = false)
JOIN(joinee, on; over = nothing, left = false, right = false, lateral = false)</code></pre><p>A <code>JOIN</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:p =&gt; :person) |&gt;
           JOIN(:l =&gt; :location,
                on = OP(&quot;=&quot;, (:p, :location_id), (:l, :location_id)),
                left = true) |&gt;
           SELECT((:p, :person_id), (:l, :state));

julia&gt; print(render(c))
SELECT
  &quot;p&quot;.&quot;person_id&quot;,
  &quot;l&quot;.&quot;state&quot;
FROM &quot;person&quot; AS &quot;p&quot;
LEFT JOIN &quot;location&quot; AS &quot;l&quot; ON (&quot;p&quot;.&quot;location_id&quot; = &quot;l&quot;.&quot;location_id&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/join.jl#L27-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.KW-Tuple" href="#FunSQL.KW-Tuple"><code>FunSQL.KW</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KW(; over = nothing, name)
KW(name; over = nothing)
KW(over, name)</code></pre><p>A keyword argument of a function or an operator.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FUN(:SUBSTRING, :zip, KW(:FROM, 1), KW(:FOR, 3));

julia&gt; print(render(c))
SUBSTRING(&quot;zip&quot; FROM 1 FOR 3)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = OP(:BETWEEN, :year_of_birth, 2000, KW(:AND, 2010));

julia&gt; print(render(c))
(&quot;year_of_birth&quot; BETWEEN 2000 AND 2010)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/keyword.jl#L19-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.LIMIT-Tuple" href="#FunSQL.LIMIT-Tuple"><code>FunSQL.LIMIT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LIMIT(; over = nothing, offset = nothing, limit = nothing, with_ties = false)
LIMIT(limit; over = nothing, offset = nothing, with_ties = false)
LIMIT(offset, limit; over = nothing, with_ties = false)
LIMIT(start:stop; over = nothing, with_ties = false)</code></pre><p>A <code>LIMIT</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           LIMIT(1) |&gt;
           SELECT(:person_id);

julia&gt; print(render(c))
SELECT &quot;person_id&quot;
FROM &quot;person&quot;
FETCH FIRST 1 ROW ONLY</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/limit.jl#L26-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.LIT-Tuple" href="#FunSQL.LIT-Tuple"><code>FunSQL.LIT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LIT(; val)
LIT(val)</code></pre><p>A SQL literal.</p><p>In a context of a SQL clause, <code>missing</code>, numbers, strings and datetime values are automatically converted to SQL literals.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = LIT(missing);


julia&gt; print(render(c))
NULL</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = LIT(&quot;SQL is fun!&quot;);

julia&gt; print(render(c))
&#39;SQL is fun!&#39;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/literal.jl#L13-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.NOTE-Tuple" href="#FunSQL.NOTE-Tuple"><code>FunSQL.NOTE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NOTE(; over = nothing, text, postfix = false)
NOTE(text; over = nothing, postfix = false)</code></pre><p>A free-form prefix of postfix annotation. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/note.jl#L15-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.OP-Tuple" href="#FunSQL.OP-Tuple"><code>FunSQL.OP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OP(; name, args = [])
OP(name; args = [])
OP(name, args...)</code></pre><p>An application of a SQL operator.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = OP(&quot;NOT&quot;, OP(&quot;=&quot;, :zip, &quot;60614&quot;));

julia&gt; print(render(c))
(NOT (&quot;zip&quot; = &#39;60614&#39;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/operator.jl#L19-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.ORDER-Tuple" href="#FunSQL.ORDER-Tuple"><code>FunSQL.ORDER</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ORDER(; over = nothing, by = [])
ORDER(by...; over = nothing)</code></pre><p>A <code>ORDER BY</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           ORDER(:year_of_birth) |&gt;
           SELECT(:person_id);

julia&gt; print(render(c))
SELECT &quot;person_id&quot;
FROM &quot;person&quot;
ORDER BY &quot;year_of_birth&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/order.jl#L16-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.PARTITION-Tuple" href="#FunSQL.PARTITION-Tuple"><code>FunSQL.PARTITION</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PARTITION(; over = nothing, by = [], order_by = [], frame = nothing)
PARTITION(by...; over = nothing, order_by = [], frame = nothing)</code></pre><p>A window definition clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           SELECT(:person_id,
                  AGG(&quot;ROW_NUMBER&quot;, over = PARTITION(:year_of_birth)));

julia&gt; print(render(c))
SELECT
  &quot;person_id&quot;,
  (ROW_NUMBER() OVER (PARTITION BY &quot;year_of_birth&quot;))
FROM &quot;person&quot;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           WINDOW(:w1 =&gt; PARTITION(:year_of_birth),
                  :w2 =&gt; :w1 |&gt; PARTITION(order_by = [:month_of_birth, :day_of_birth])) |&gt;
           SELECT(:person_id, AGG(&quot;ROW_NUMBER&quot;, over = :w2));

julia&gt; print(render(c))
SELECT
  &quot;person_id&quot;,
  (ROW_NUMBER() OVER (&quot;w2&quot;))
FROM &quot;person&quot;
WINDOW
  &quot;w1&quot; AS (PARTITION BY &quot;year_of_birth&quot;),
  &quot;w2&quot; AS (&quot;w1&quot; ORDER BY &quot;month_of_birth&quot;, &quot;day_of_birth&quot;)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           GROUP(:year_of_birth) |&gt;
           SELECT(:year_of_birth,
                  AGG(&quot;AVG&quot;,
                      AGG(&quot;COUNT&quot;, OP(&quot;*&quot;)),
                      over = PARTITION(order_by = [:year_of_birth],
                                       frame = (mode = :range, start = -1, finish = 1))));

julia&gt; print(render(c))
SELECT
  &quot;year_of_birth&quot;,
  (AVG(COUNT(*)) OVER (ORDER BY &quot;year_of_birth&quot; RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING))
FROM &quot;person&quot;
GROUP BY &quot;year_of_birth&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/partition.jl#L96-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.SELECT-Tuple" href="#FunSQL.SELECT-Tuple"><code>FunSQL.SELECT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SELECT(; over = nothing, top = nothing, distinct = false, args)
SELECT(args...; over = nothing, top = nothing, distinct = false)</code></pre><p>A <code>SELECT</code> clause.  Unlike raw SQL, <code>SELECT()</code> should be placed at the end of a clause chain.</p><p>Set <code>distinct</code> to <code>true</code> to add a <code>DISTINCT</code> modifier.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = SELECT(true, false);

julia&gt; print(render(c))
SELECT
  TRUE,
  FALSE</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:location) |&gt;
           SELECT(distinct = true, :zip);

julia&gt; print(render(c))
SELECT DISTINCT &quot;zip&quot;
FROM &quot;location&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/select.jl#L43-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.ASC-Tuple{}" href="#FunSQL.ASC-Tuple{}"><code>FunSQL.ASC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ASC(; over = nothing, nulls = nothing)</code></pre><p>Ascending order indicator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/sort.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.DESC-Tuple{}" href="#FunSQL.DESC-Tuple{}"><code>FunSQL.DESC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DESC(; over = nothing, nulls = nothing)</code></pre><p>Descending order indicator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/sort.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.SORT-Tuple" href="#FunSQL.SORT-Tuple"><code>FunSQL.SORT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SORT(; over = nothing, value, nulls = nothing)
SORT(value; over = nothing, nulls = nothing)
ASC(; over = nothing, nulls = nothing)
DESC(; over = nothing, nulls = nothing)</code></pre><p>Sort order options.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           ORDER(:year_of_birth |&gt; DESC()) |&gt;
           SELECT(:person_id);

julia&gt; print(render(c))
SELECT &quot;person_id&quot;
FROM &quot;person&quot;
ORDER BY &quot;year_of_birth&quot; DESC</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/sort.jl#L56-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.UNION-Tuple" href="#FunSQL.UNION-Tuple"><code>FunSQL.UNION</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UNION(; over = nothing, all = false, args)
UNION(args...; over = nothing, all = false)</code></pre><p>A <code>UNION</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:measurement) |&gt;
           SELECT(:person_id, :date =&gt; :measurement_date) |&gt;
           UNION(all = true,
                 FROM(:observation) |&gt;
                 SELECT(:person_id, :date =&gt; :observation_date));

julia&gt; print(render(c))
SELECT
  &quot;person_id&quot;,
  &quot;measurement_date&quot; AS &quot;date&quot;
FROM &quot;measurement&quot;
UNION ALL
SELECT
  &quot;person_id&quot;,
  &quot;observation_date&quot; AS &quot;date&quot;
FROM &quot;observation&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/union.jl#L18-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.VAR-Tuple" href="#FunSQL.VAR-Tuple"><code>FunSQL.VAR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VAR(; name)
VAR(name)</code></pre><p>A placeholder in a parameterized query.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = VAR(:year);

julia&gt; print(render(c))
:year</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/variable.jl#L13-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.WHERE-Tuple" href="#FunSQL.WHERE-Tuple"><code>FunSQL.WHERE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">WHERE(; over = nothing, condition)
WHERE(condition; over = nothing)</code></pre><p>A <code>WHERE</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:location) |&gt;
           WHERE(OP(&quot;=&quot;, :zip, &quot;60614&quot;)) |&gt;
           SELECT(:location_id);

julia&gt; print(render(c))
SELECT &quot;location_id&quot;
FROM &quot;location&quot;
WHERE (&quot;zip&quot; = &#39;60614&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/where.jl#L16-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.WINDOW-Tuple" href="#FunSQL.WINDOW-Tuple"><code>FunSQL.WINDOW</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">WINDOW(; over = nothing, args)
WINDOW(args...; over = nothing)</code></pre><p>A <code>WINDOW</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           WINDOW(:w1 =&gt; PARTITION(:year_of_birth),
                  :w2 =&gt; :w1 |&gt; PARTITION(order_by = [:month_of_birth, :day_of_birth])) |&gt;
           SELECT(:person_id, AGG(&quot;ROW_NUMBER&quot;, over = :w2));

julia&gt; print(render(c))
SELECT
  &quot;person_id&quot;,
  (ROW_NUMBER() OVER (&quot;w2&quot;))
FROM &quot;person&quot;
WINDOW
  &quot;w1&quot; AS (PARTITION BY &quot;year_of_birth&quot;),
  &quot;w2&quot; AS (&quot;w1&quot; ORDER BY &quot;month_of_birth&quot;, &quot;day_of_birth&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/window.jl#L16-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.WITH-Tuple" href="#FunSQL.WITH-Tuple"><code>FunSQL.WITH</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">WITH(; over = nothing, recursive = false, args)
WITH(args...; over = nothing, recursive = false)</code></pre><p>A <code>WITH</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           WHERE(OP(&quot;IN&quot;, :person_id,
                          FROM(:essential_hypertension) |&gt;
                          SELECT(:person_id))) |&gt;
           SELECT(:person_id, :year_of_birth) |&gt;
           WITH(FROM(:condition_occurrence) |&gt;
                WHERE(OP(&quot;=&quot;, :condition_concept_id, 320128)) |&gt;
                SELECT(:person_id) |&gt;
                AS(:essential_hypertension));

julia&gt; print(render(c))
WITH &quot;essential_hypertension&quot; AS (
  SELECT &quot;person_id&quot;
  FROM &quot;condition_occurrence&quot;
  WHERE (&quot;condition_concept_id&quot; = 320128)
)
SELECT
  &quot;person_id&quot;,
  &quot;year_of_birth&quot;
FROM &quot;person&quot;
WHERE (&quot;person_id&quot; IN (
  SELECT &quot;person_id&quot;
  FROM &quot;essential_hypertension&quot;
))</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:essential_hypertension) |&gt;
           SELECT(OP(&quot;*&quot;)) |&gt;
           WITH(recursive = true,
                FROM(:concept) |&gt;
                WHERE(OP(&quot;=&quot;, :concept_id, 320128)) |&gt;
                SELECT(:concept_id, :concept_name) |&gt;
                UNION(all = true,
                      FROM(:eh =&gt; :essential_hypertension) |&gt;
                      JOIN(:cr =&gt; :concept_relationship,
                           OP(&quot;=&quot;, (:eh, :concept_id), (:cr, :concept_id_1))) |&gt;
                      JOIN(:c =&gt; :concept,
                           OP(&quot;=&quot;, (:cr, :concept_id_2), (:c, :concept_id))) |&gt;
                      WHERE(OP(&quot;=&quot;, (:cr, :relationship_id), &quot;Subsumes&quot;)) |&gt;
                      SELECT((:c, :concept_id), (:c, :concept_name))) |&gt;
                AS(:essential_hypertension, columns = [:concept_id, :concept_name]));

julia&gt; print(render(c))
WITH RECURSIVE &quot;essential_hypertension&quot; (&quot;concept_id&quot;, &quot;concept_name&quot;) AS (
  SELECT
    &quot;concept_id&quot;,
    &quot;concept_name&quot;
  FROM &quot;concept&quot;
  WHERE (&quot;concept_id&quot; = 320128)
  UNION ALL
  SELECT
    &quot;c&quot;.&quot;concept_id&quot;,
    &quot;c&quot;.&quot;concept_name&quot;
  FROM &quot;essential_hypertension&quot; AS &quot;eh&quot;
  JOIN &quot;concept_relationship&quot; AS &quot;cr&quot; ON (&quot;eh&quot;.&quot;concept_id&quot; = &quot;cr&quot;.&quot;concept_id_1&quot;)
  JOIN &quot;concept&quot; AS &quot;c&quot; ON (&quot;cr&quot;.&quot;concept_id_2&quot; = &quot;c&quot;.&quot;concept_id&quot;)
  WHERE (&quot;cr&quot;.&quot;relationship_id&quot; = &#39;Subsumes&#39;)
)
SELECT *
FROM &quot;essential_hypertension&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/7192ec53890e9b842a0876b067296855ab96b677/src/clauses/with.jl#L18-L89">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../guide/">« Usage Guide</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Sunday 9 January 2022 14:07">Sunday 9 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
