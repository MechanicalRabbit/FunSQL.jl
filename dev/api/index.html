<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · FunSQL.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FunSQL.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#SQL-Dialects"><span>SQL Dialects</span></a></li><li><a class="tocitem" href="#SQL-Entities"><span>SQL Entities</span></a></li><li><a class="tocitem" href="#SQL-Statements"><span>SQL Statements</span></a></li><li><a class="tocitem" href="#Semantic-Structure"><span>Semantic Structure</span></a></li><li><a class="tocitem" href="#Syntactic-Structure"><span>Syntactic Structure</span></a></li></ul></li><li><a class="tocitem" href="../test/">Test Suite</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="FunSQL.render" href="#FunSQL.render"><code>FunSQL.render</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">render(node; dialect = :default) :: String</code></pre><p>Convert the given SQL node or clause object to a SQL string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/FunSQL.jl#L11-L15">source</a></section></article><h2 id="SQL-Dialects"><a class="docs-heading-anchor" href="#SQL-Dialects">SQL Dialects</a><a id="SQL-Dialects-1"></a><a class="docs-heading-anchor-permalink" href="#SQL-Dialects" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FunSQL.SQLDialect" href="#FunSQL.SQLDialect"><code>FunSQL.SQLDialect</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Properties of a SQL dialect.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/dialects.jl#L25-L27">source</a></section></article><h2 id="SQL-Entities"><a class="docs-heading-anchor" href="#SQL-Entities">SQL Entities</a><a id="SQL-Entities-1"></a><a class="docs-heading-anchor-permalink" href="#SQL-Entities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FunSQL.SQLTable" href="#FunSQL.SQLTable"><code>FunSQL.SQLTable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SQLTable(; schema = nothing, name, columns)
SQLTable(name; schema = nothing, columns)
SQLTable(name, columns...; schema = nothing)</code></pre><p>The structure of a SQL table or a table-like entity (TEMP TABLE, VIEW, etc) for use as a reference in assembling SQL queries.</p><p>The <code>SQLTable</code> constructor expects the table <code>name</code>, a vector <code>columns</code> of column names, and, optionally, the name of the table <code>schema</code>.  A name can be provided as a <code>Symbol</code> or <code>String</code> value.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = SQLTable(:location,
                    :location_id, :address_1, :address_2, :city, :state, :zip);


julia&gt; show(t.name)
:location

julia&gt; show(t.columns)
[:location_id, :address_1, :address_2, :city, :state, :zip]</code></pre><pre><code class="language-julia-repl hljs">julia&gt; t = SQLTable(schema = &quot;public&quot;,
                    name = &quot;person&quot;,
                    columns = [&quot;person_id&quot;, &quot;birth_datetime&quot;, &quot;location_id&quot;]);

julia&gt; show(t.schema)
:public

julia&gt; show(t.name)
:person

julia&gt; show(t.columns)
[:person_id, :birth_datetime, :location_id]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/entities.jl#L3-L43">source</a></section></article><h2 id="SQL-Statements"><a class="docs-heading-anchor" href="#SQL-Statements">SQL Statements</a><a id="SQL-Statements-1"></a><a class="docs-heading-anchor-permalink" href="#SQL-Statements" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FunSQL.SQLStatement" href="#FunSQL.SQLStatement"><code>FunSQL.SQLStatement</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Prepared SQL statement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/statements.jl#L3-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.pack" href="#FunSQL.pack"><code>FunSQL.pack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pack(stmt::SQLStatement, vars::Union{Dict, NamedTuple}) :: Vector{Any}</code></pre><p>Convert named parameters to positional form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/statements.jl#L36-L40">source</a></section></article><h2 id="Semantic-Structure"><a class="docs-heading-anchor" href="#Semantic-Structure">Semantic Structure</a><a id="Semantic-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Semantic-Structure" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FunSQL.AbstractSQLNode" href="#FunSQL.AbstractSQLNode"><code>FunSQL.AbstractSQLNode</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A SQL expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.SQLNode" href="#FunSQL.SQLNode"><code>FunSQL.SQLNode</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An opaque wrapper over an arbitrary SQL node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes.jl#L24-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Agg-Tuple" href="#FunSQL.Agg-Tuple"><code>FunSQL.Agg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Agg(; over = nothing, name, distinct = false, args = [], filter = nothing)
Agg(name; over = nothing, distinct = false, args = [], filter = nothing)
Agg(name, args...; over = nothing, distinct = false, filter = nothing)</code></pre><p>An application of an aggregate function.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Group(Get.year_of_birth) |&gt;
           Select(Get.year_of_birth, Agg.count());

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;year_of_birth&quot;, COUNT(*) AS &quot;count&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
GROUP BY &quot;person_1&quot;.&quot;year_of_birth&quot;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Group() |&gt;
           Select(Agg.count(distinct = true, Get.year_of_birth));

julia&gt; print(render(q))
SELECT COUNT(DISTINCT &quot;person_1&quot;.&quot;year_of_birth&quot;) AS &quot;count&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id]);

julia&gt; visit_occurrence =
           SQLTable(:visit_occurrence, columns = [:visit_occurrence_id, :person_id, :visit_start_date]);

julia&gt; q = From(person) |&gt;
           LeftJoin(:visit_group =&gt; From(visit_occurrence) |&gt;
                                    Group(Get.person_id),
                    on = (Get.person_id .== Get.visit_group.person_id)) |&gt;
           Select(Get.person_id,
                  :max_visit_start_date =&gt;
                      Get.visit_group |&gt; Agg.max(Get.visit_start_date));

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;person_id&quot;, &quot;visit_group_1&quot;.&quot;max&quot; AS &quot;max_visit_start_date&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
LEFT JOIN (
  SELECT &quot;visit_occurrence_1&quot;.&quot;person_id&quot;, MAX(&quot;visit_occurrence_1&quot;.&quot;visit_start_date&quot;) AS &quot;max&quot;
  FROM &quot;visit_occurrence&quot; AS &quot;visit_occurrence_1&quot;
  GROUP BY &quot;visit_occurrence_1&quot;.&quot;person_id&quot;
) AS &quot;visit_group_1&quot; ON (&quot;person_1&quot;.&quot;person_id&quot; = &quot;visit_group_1&quot;.&quot;person_id&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/aggregate.jl#L25-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Append-Tuple" href="#FunSQL.Append-Tuple"><code>FunSQL.Append</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Append(; over = nothing, list)
Append(list...; over = nothing)</code></pre><p>A subquery that combines subqueries using <code>UNION ALL</code>.</p><pre><code class="language-sql hljs">SELECT ...
FROM $over
UNION ALL
SELECT ...
FROM $(list[1])
UNION ALL
...</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; measurement = SQLTable(:measurement, columns = [:measurement_id, :person_id, :measurement_date]);

julia&gt; observation = SQLTable(:observation, columns = [:observation_id, :person_id, :observation_date]);

julia&gt; q = From(measurement) |&gt;
           Define(:date =&gt; Get.measurement_date) |&gt;
           Append(From(observation) |&gt;
                  Define(:date =&gt; Get.observation_date)) |&gt;
           Select(Get.person_id, Get.date);

julia&gt; print(render(q))
SELECT &quot;union_1&quot;.&quot;person_id&quot;, &quot;union_1&quot;.&quot;date&quot;
FROM (
  SELECT &quot;measurement_1&quot;.&quot;person_id&quot;, &quot;measurement_1&quot;.&quot;measurement_date&quot; AS &quot;date&quot;
  FROM &quot;measurement&quot; AS &quot;measurement_1&quot;
  UNION ALL
  SELECT &quot;observation_1&quot;.&quot;person_id&quot;, &quot;observation_1&quot;.&quot;observation_date&quot; AS &quot;date&quot;
  FROM &quot;observation&quot; AS &quot;observation_1&quot;
) AS &quot;union_1&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/append.jl#L14-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.As-Tuple" href="#FunSQL.As-Tuple"><code>FunSQL.As</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">As(; over = nothing, name)
As(name; over = nothing)
name =&gt; over</code></pre><p>An alias for a subquery or an expression.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           As(:p) |&gt;
           Select(:birth_year =&gt; Get.p.year_of_birth);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/as.jl#L16-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Bind-Tuple" href="#FunSQL.Bind-Tuple"><code>FunSQL.Bind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Bind(; over = nothing; list)
Bind(list...; over = nothing)</code></pre><p>Bind a query parameter to make a correlated subquery.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id]);

julia&gt; visit_occurrence = SQLTable(:visit_occurrence, columns = [:visit_occurrence_id, :person_id]);

julia&gt; q = From(person) |&gt;
           Where(Fun.exists(From(visit_occurrence) |&gt;
                            Where(Get.person_id .== Var.person_id) |&gt;
                            Bind(Get.person_id)));

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;person_id&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
WHERE (EXISTS (
  SELECT NULL
  FROM &quot;visit_occurrence&quot; AS &quot;visit_occurrence_1&quot;
  WHERE (&quot;visit_occurrence_1&quot;.&quot;person_id&quot; = &quot;person_1&quot;.&quot;person_id&quot;)
))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/bind.jl#L16-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Define-Tuple" href="#FunSQL.Define-Tuple"><code>FunSQL.Define</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Define(; over; list = [])
Define(list...; over)</code></pre><p>A subquery that defines calculated columns.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :birth_datetime]);

julia&gt; q = From(person) |&gt;
           Define(:age =&gt; Fun.now() .- Get.birth_datetime) |&gt;
           Where(Get.age .&gt; &quot;16 years&quot;) |&gt;
           Select(Get.person_id, Get.age);

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;person_id&quot;, (NOW() - &quot;person_1&quot;.&quot;birth_datetime&quot;) AS &quot;age&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
WHERE ((NOW() - &quot;person_1&quot;.&quot;birth_datetime&quot;) &gt; &#39;16 years&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/define.jl#L14-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.From-Tuple" href="#FunSQL.From-Tuple"><code>FunSQL.From</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">From(; table)
From(table)</code></pre><p>A subquery that selects columns from the given table.</p><pre><code class="language-sql hljs">SELECT ...
FROM $table</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person);

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;person_id&quot;, &quot;person_1&quot;.&quot;year_of_birth&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/from.jl#L13-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Fun-Tuple" href="#FunSQL.Fun-Tuple"><code>FunSQL.Fun</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Fun(; name, args = [])
Fun(name; args = [])
Fun(name, args...)</code></pre><p>A function or an operator invocation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Where(Fun.not(Get.person_id .&gt; 2000));

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;person_id&quot;, &quot;person_1&quot;.&quot;year_of_birth&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
WHERE (NOT (&quot;person_1&quot;.&quot;person_id&quot; &gt; 2000))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/function.jl#L19-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Get-Tuple" href="#FunSQL.Get-Tuple"><code>FunSQL.Get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Get(; over, name)
Get(name; over)
Get.name        Get.&quot;name&quot;      Get[name]       Get[&quot;name&quot;]
over.name       over.&quot;name&quot;     over[name]      over[&quot;name&quot;]</code></pre><p>A reference to a table column, or an aliased expression or subquery.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           As(:p) |&gt;
           Select(Get.p.person_id);</code></pre><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person);

julia&gt; q = q |&gt; Select(q.person_id);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/get.jl#L16-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Group-Tuple" href="#FunSQL.Group-Tuple"><code>FunSQL.Group</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Group(; over; by = [])
Group(by...; over)</code></pre><p>A subquery that groups rows <code>by</code> a list of keys.</p><pre><code class="language-sql hljs">SELECT ...
FROM $over
GROUP BY $by...</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Group(Get.year_of_birth) |&gt;
           Select(Get.year_of_birth, Agg.count());

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;year_of_birth&quot;, COUNT(*) AS &quot;count&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
GROUP BY &quot;person_1&quot;.&quot;year_of_birth&quot;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Group() |&gt;
           Select(Agg.count(distinct = true, Get.year_of_birth));

julia&gt; print(render(q))
SELECT COUNT(DISTINCT &quot;person_1&quot;.&quot;year_of_birth&quot;) AS &quot;count&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/group.jl#L14-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Highlight-Tuple" href="#FunSQL.Highlight-Tuple"><code>FunSQL.Highlight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Highlight(; over = nothing; color)
Highlight(color; over = nothing)</code></pre><p>Highlight <code>over</code> with the given <code>color</code>.</p><p>Available colors can be found in <code>Base.text_colors</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Get.person_id |&gt; Highlight(:bold);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/highlight.jl#L41-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Join-Tuple" href="#FunSQL.Join-Tuple"><code>FunSQL.Join</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Join(; over = nothing, joinee, on, left = false, right = false)
Join(joinee; over = nothing, on, left = false, right = false)
Join(joinee, on; over = nothing, left = false, right = false)</code></pre><p>A subquery that joins two subqueries together.</p><pre><code class="language-sql hljs">SELECT ...
FROM $over
JOIN $joinee ON $on</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :location_id]);

julia&gt; location = SQLTable(:location, columns = [:location_id, :state]);

julia&gt; q = From(person) |&gt;
           Join(:location =&gt; location,
                Get.location_id .== Get.location.location_id) |&gt;
           Select(Get.person_id, Get.location.state);

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;person_id&quot;, &quot;location_1&quot;.&quot;state&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
JOIN &quot;location&quot; AS &quot;location_1&quot; ON (&quot;person_1&quot;.&quot;location_id&quot; = &quot;location_1&quot;.&quot;location_id&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/join.jl#L20-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.LeftJoin-Tuple" href="#FunSQL.LeftJoin-Tuple"><code>FunSQL.LeftJoin</code></a> — <span class="docstring-category">Method</span></header><section><div><p>An alias for <code>Join(...; ..., left = true)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/join.jl#L54-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Limit-Tuple" href="#FunSQL.Limit-Tuple"><code>FunSQL.Limit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Limit(; over = nothing, offset = nothing, limit = nothing)
Limit(limit; over = nothing, offset = nothing)
Limit(offset, limit; over = nothing)
Limit(start:stop; over = nothing)</code></pre><p>A subquery that takes a fixed-sized slice of the dataset.</p><pre><code class="language-sql hljs">SELECT ...
FROM $over
OFFSET $offset ROWS
FETCH NEXT $limit ROWS ONLY</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id]);

julia&gt; q = From(person) |&gt;
           Limit(1) |&gt;
           Select(Get.person_id);

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;person_id&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
FETCH FIRST 1 ROW ONLY</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/limit.jl#L21-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Lit-Tuple" href="#FunSQL.Lit-Tuple"><code>FunSQL.Lit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Lit(; val)
Lit(val)</code></pre><p>A SQL literal.</p><p>In a suitable context, <code>missing</code>, numbers, strings and datetime values are automatically converted to SQL literals.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; q = Select(:null =&gt; missing,
                  :boolean =&gt; true,
                  :integer =&gt; 42,
                  :text =&gt; &quot;SQL is fun!&quot;,
                  :date =&gt; Date(2000));

julia&gt; print(render(q))
SELECT NULL AS &quot;null&quot;, TRUE AS &quot;boolean&quot;, 42 AS &quot;integer&quot;, &#39;SQL is fun!&#39; AS &quot;text&quot;, &#39;2000-01-01&#39; AS &quot;date&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/literal.jl#L13-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Order-Tuple" href="#FunSQL.Order-Tuple"><code>FunSQL.Order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Order(; over = nothing, by)
Order(by...; over = nothing)</code></pre><p>A subquery that sorts the rows <code>by</code> a list of keys.</p><pre><code class="language-sql hljs">SELECT ...
FROM $over
ORDER BY $by...</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Order(Get.year_of_birth) |&gt;
           Select(Get.person_id);

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;person_id&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
ORDER BY &quot;person_1&quot;.&quot;year_of_birth&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/order.jl#L14-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Partition-Tuple" href="#FunSQL.Partition-Tuple"><code>FunSQL.Partition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Partition(; over, by = [], order_by = [], frame = nothing)
Partition(by...; over, order_by = [], frame = nothing)</code></pre><p>A subquery that partitions rows <code>by</code> a list of keys.</p><pre><code class="language-sql hljs">SELECT ...
FROM $over
WINDOW w AS (PARTITION BY $by... ORDER BY $order_by...)</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Partition(Get.year_of_birth) |&gt;
           Select(Get.year_of_birth, Agg.row_number());

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;year_of_birth&quot;, (ROW_NUMBER() OVER (PARTITION BY &quot;person_1&quot;.&quot;year_of_birth&quot;)) AS &quot;row_number&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Group(Get.year_of_birth) |&gt;
           Partition(order_by = [Get.year_of_birth],
                     frame = (mode = :range, start = -1, finish = 1)) |&gt;
           Select(Get.year_of_birth, Agg.avg(Agg.count()));

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;year_of_birth&quot;, (AVG(COUNT(*)) OVER (ORDER BY &quot;person_1&quot;.&quot;year_of_birth&quot; RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING)) AS &quot;avg&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
GROUP BY &quot;person_1&quot;.&quot;year_of_birth&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/partition.jl#L16-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Select-Tuple" href="#FunSQL.Select-Tuple"><code>FunSQL.Select</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Select(; over; list)
Select(list...; over)</code></pre><p>A subquery that fixes the <code>list</code> of output columns.</p><pre><code class="language-sql hljs">SELECT $list...
FROM $over</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Select(Get.person_id);

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;person_id&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/select.jl#L14-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Asc-Tuple{}" href="#FunSQL.Asc-Tuple{}"><code>FunSQL.Asc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Asc(; over = nothing, nulls = nothing)</code></pre><p>Ascending order indicator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/sort.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Desc-Tuple{}" href="#FunSQL.Desc-Tuple{}"><code>FunSQL.Desc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Desc(; over = nothing, nulls = nothing)</code></pre><p>Descending order indicator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/sort.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Sort-Tuple" href="#FunSQL.Sort-Tuple"><code>FunSQL.Sort</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Sort(; over = nothing, value, nulls = nothing)
Sort(value; over = nothing, nulls = nothing)
Asc(; over = nothing, nulls = nothing)
Desc(; over = nothing, nulls = nothing)</code></pre><p>Sort order indicator.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Order(Get.year_of_birth |&gt; Desc()) |&gt;
           Select(Get.person_id);

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;person_id&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
ORDER BY &quot;person_1&quot;.&quot;year_of_birth&quot; DESC</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/sort.jl#L18-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Var-Tuple" href="#FunSQL.Var-Tuple"><code>FunSQL.Var</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Var(; name)
Var(name)
Var.name        Var.&quot;name&quot;      Var[name]       Var[&quot;name&quot;]</code></pre><p>A reference to a query parameter.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Where(Get.year_of_birth .&gt; Var.year);

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;person_id&quot;, &quot;person_1&quot;.&quot;year_of_birth&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
WHERE (&quot;person_1&quot;.&quot;year_of_birth&quot; &gt; :year)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/variable.jl#L13-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.Where-Tuple" href="#FunSQL.Where-Tuple"><code>FunSQL.Where</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Where(; over = nothing, condition)
Where(condition; over = nothing)</code></pre><p>A subquery that filters by the given <code>condition</code>.</p><pre><code class="language-sql hljs">SELECT ...
FROM $over
WHERE $condition</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; person = SQLTable(:person, columns = [:person_id, :year_of_birth]);

julia&gt; q = From(person) |&gt;
           Where(Fun(&quot;&gt;&quot;, Get.year_of_birth, 2000));

julia&gt; print(render(q))
SELECT &quot;person_1&quot;.&quot;person_id&quot;, &quot;person_1&quot;.&quot;year_of_birth&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
WHERE (&quot;person_1&quot;.&quot;year_of_birth&quot; &gt; 2000)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/nodes/where.jl#L14-L39">source</a></section></article><h2 id="Syntactic-Structure"><a class="docs-heading-anchor" href="#Syntactic-Structure">Syntactic Structure</a><a id="Syntactic-Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Syntactic-Structure" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FunSQL.AbstractSQLClause" href="#FunSQL.AbstractSQLClause"><code>FunSQL.AbstractSQLClause</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A part of a SQL query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.SQLClause" href="#FunSQL.SQLClause"><code>FunSQL.SQLClause</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An opaque wrapper over an arbitrary SQL clause.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses.jl#L21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.AGG-Tuple" href="#FunSQL.AGG-Tuple"><code>FunSQL.AGG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AGG(; name, distinct = false, args = [], filter = nothing, over = nothing)
AGG(name; distinct = false, args = [], filter = nothing, over = nothing)
AGG(name, args...; distinct = false, filter = nothing, over = nothing)</code></pre><p>An application of an aggregate function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = AGG(:COUNT, OP(&quot;*&quot;));

julia&gt; print(render(c))
COUNT(*)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = AGG(:COUNT, distinct = true, :year_of_birth);

julia&gt; print(render(c))
COUNT(DISTINCT &quot;year_of_birth&quot;)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = AGG(:COUNT, OP(&quot;*&quot;), filter = OP(&quot;&gt;&quot;, :year_of_birth, 1970));

julia&gt; print(render(c))
(COUNT(*) FILTER (WHERE (&quot;year_of_birth&quot; &gt; 1970)))</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = AGG(:ROW_NUMBER, over = PARTITION(:year_of_birth));

julia&gt; print(render(c))
(ROW_NUMBER() OVER (PARTITION BY &quot;year_of_birth&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/aggregate.jl#L25-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.AS-Tuple" href="#FunSQL.AS-Tuple"><code>FunSQL.AS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AS(; over = nothing, name)
AS(name; over = nothing)</code></pre><p>An <code>AS</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = ID(:person) |&gt; AS(:p);

julia&gt; print(render(c))
&quot;person&quot; AS &quot;p&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/as.jl#L16-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.CASE-Tuple" href="#FunSQL.CASE-Tuple"><code>FunSQL.CASE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CASE(; args)
CASE(args...)</code></pre><p>A <code>CASE</code> expression.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = CASE(OP(&quot;&lt;&quot;, :year_of_birth, 1970), &quot;boomer&quot;, &quot;millenial&quot;);

julia&gt; print(render(c))
(CASE WHEN (&quot;year_of_birth&quot; &lt; 1970) THEN &#39;boomer&#39; ELSE &#39;millenial&#39; END)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/case.jl#L13-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.FROM-Tuple" href="#FunSQL.FROM-Tuple"><code>FunSQL.FROM</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FROM(; over = nothing)
FROM(over)</code></pre><p>A <code>FROM</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = ID(:person) |&gt; AS(:p) |&gt; FROM() |&gt; SELECT((:p, :person_id));

julia&gt; print(render(c))
SELECT &quot;p&quot;.&quot;person_id&quot;
FROM &quot;person&quot; AS &quot;p&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/from.jl#L13-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.FUN-Tuple" href="#FunSQL.FUN-Tuple"><code>FunSQL.FUN</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FUN(; name, args = [])
FUN(name; args = [])
FUN(name, args...)</code></pre><p>An invocation of a SQL function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FUN(:EXTRACT, OP(:YEAR), KW(:FROM, FUN(:NOW)));

julia&gt; print(render(c))
EXTRACT(YEAR FROM NOW())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/function.jl#L19-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.GROUP-Tuple" href="#FunSQL.GROUP-Tuple"><code>FunSQL.GROUP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GROUP(; over = nothing, by = [])
GROUP(by...; over = nothing)</code></pre><p>A <code>GROUP BY</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           GROUP(:year_of_birth) |&gt;
           SELECT(:year_of_birth, AGG(&quot;COUNT&quot;, OP(&quot;*&quot;)));

julia&gt; print(render(c))
SELECT &quot;year_of_birth&quot;, COUNT(*)
FROM &quot;person&quot;
GROUP BY &quot;year_of_birth&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/group.jl#L16-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.HAVING-Tuple" href="#FunSQL.HAVING-Tuple"><code>FunSQL.HAVING</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HAVING(; over = nothing, condition)
HAVING(condition; over = nothing)</code></pre><p>A <code>HAVING</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           GROUP(:year_of_birth) |&gt;
           HAVING(OP(&quot;&gt;&quot;, AGG(&quot;COUNT&quot;, OP(&quot;*&quot;)), 10)) |&gt;
           SELECT(:person_id);

julia&gt; print(render(c))
SELECT &quot;person_id&quot;
FROM &quot;person&quot;
GROUP BY &quot;year_of_birth&quot;
HAVING (COUNT(*) &gt; 10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/having.jl#L16-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.ID-Tuple" href="#FunSQL.ID-Tuple"><code>FunSQL.ID</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ID(; over = nothing, name)
ID(name; over = nothing)</code></pre><p>A SQL identifier.  Specify <code>over</code> or use the <code>|&gt;</code> operator to make a qualified identifier.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = ID(:person);

julia&gt; print(render(c))
&quot;person&quot;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = ID(:p) |&gt; ID(:birth_datetime);

julia&gt; print(render(c))
&quot;p&quot;.&quot;birth_datetime&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/identifier.jl#L16-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.JOIN-Tuple" href="#FunSQL.JOIN-Tuple"><code>FunSQL.JOIN</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">JOIN(; over = nothing, joinee, on, left = false, right = false, lateral = false)
JOIN(joinee; over = nothing, on, left = false, right = false, lateral = false)
JOIN(joinee, on; over = nothing, left = false, right = false, lateral = false)</code></pre><p>A <code>JOIN</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:p =&gt; :person) |&gt;
           JOIN(:l =&gt; :location,
                on = OP(&quot;=&quot;, (:p, :location_id), (:l, :location_id)),
                left = true) |&gt;
           SELECT((:p, :person_id), (:l, :state));

julia&gt; print(render(c))
SELECT &quot;p&quot;.&quot;person_id&quot;, &quot;l&quot;.&quot;state&quot;
FROM &quot;person&quot; AS &quot;p&quot;
LEFT JOIN &quot;location&quot; AS &quot;l&quot; ON (&quot;p&quot;.&quot;location_id&quot; = &quot;l&quot;.&quot;location_id&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/join.jl#L27-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.KW-Tuple" href="#FunSQL.KW-Tuple"><code>FunSQL.KW</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KW(; over = nothing, name)
KW(name; over = nothing)
KW(over, name)</code></pre><p>A keyword argument of a function or an operator.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FUN(:SUBSTRING, :zip, KW(:FROM, 1), KW(:FOR, 3));

julia&gt; print(render(c))
SUBSTRING(&quot;zip&quot; FROM 1 FOR 3)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = OP(:BETWEEN, :year_of_birth, 2000, KW(:AND, 2010));

julia&gt; print(render(c))
(&quot;year_of_birth&quot; BETWEEN 2000 AND 2010)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/keyword.jl#L19-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.LIMIT-Tuple" href="#FunSQL.LIMIT-Tuple"><code>FunSQL.LIMIT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LIMIT(; over = nothing, offset = nothing, limit = nothing, with_ties = false)
LIMIT(limit; over = nothing, offset = nothing, with_ties = false)
LIMIT(offset, limit; over = nothing, with_ties = false)
LIMIT(start:stop; over = nothing, with_ties = false)</code></pre><p>A <code>LIMIT</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           LIMIT(1) |&gt;
           SELECT(:person_id);

julia&gt; print(render(c))
SELECT &quot;person_id&quot;
FROM &quot;person&quot;
FETCH FIRST 1 ROW ONLY</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/limit.jl#L26-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.LIT-Tuple" href="#FunSQL.LIT-Tuple"><code>FunSQL.LIT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LIT(; val)
LIT(val)</code></pre><p>A SQL literal.</p><p>In a context of a SQL clause, <code>missing</code>, numbers, strings and datetime values are automatically converted to SQL literals.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = LIT(missing);


julia&gt; print(render(c))
NULL</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = LIT(&quot;SQL is fun!&quot;);

julia&gt; print(render(c))
&#39;SQL is fun!&#39;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/literal.jl#L13-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.OP-Tuple" href="#FunSQL.OP-Tuple"><code>FunSQL.OP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">OP(; name, args = [])
OP(name; args = [])
OP(name, args...)</code></pre><p>An application of a SQL operator.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = OP(&quot;NOT&quot;, OP(&quot;=&quot;, :zip, &quot;60614&quot;));

julia&gt; print(render(c))
(NOT (&quot;zip&quot; = &#39;60614&#39;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/operator.jl#L19-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.ORDER-Tuple" href="#FunSQL.ORDER-Tuple"><code>FunSQL.ORDER</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ORDER(; over = nothing, by = [])
ORDER(by...; over = nothing)</code></pre><p>A <code>ORDER BY</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           ORDER(:year_of_birth) |&gt;
           SELECT(:person_id);

julia&gt; print(render(c))
SELECT &quot;person_id&quot;
FROM &quot;person&quot;
ORDER BY &quot;year_of_birth&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/order.jl#L16-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.PARTITION-Tuple" href="#FunSQL.PARTITION-Tuple"><code>FunSQL.PARTITION</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PARTITION(; over = nothing, by = [], order_by = [], frame = nothing)
PARTITION(by...; over = nothing, order_by = [], frame = nothing)</code></pre><p>A window definition clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           SELECT(:person_id,
                  AGG(&quot;ROW_NUMBER&quot;, over = PARTITION(:year_of_birth)));

julia&gt; print(render(c))
SELECT &quot;person_id&quot;, (ROW_NUMBER() OVER (PARTITION BY &quot;year_of_birth&quot;))
FROM &quot;person&quot;</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           WINDOW(:w1 =&gt; PARTITION(:year_of_birth),
                  :w2 =&gt; :w1 |&gt; PARTITION(order_by = [:month_of_birth, :day_of_birth])) |&gt;
           SELECT(:person_id, AGG(&quot;ROW_NUMBER&quot;, over = :w2));

julia&gt; print(render(c))
SELECT &quot;person_id&quot;, (ROW_NUMBER() OVER (&quot;w2&quot;))
FROM &quot;person&quot;
WINDOW &quot;w1&quot; AS (PARTITION BY &quot;year_of_birth&quot;), &quot;w2&quot; AS (&quot;w1&quot; ORDER BY &quot;month_of_birth&quot;, &quot;day_of_birth&quot;)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           GROUP(:year_of_birth) |&gt;
           SELECT(:year_of_birth,
                  AGG(&quot;AVG&quot;,
                      AGG(&quot;COUNT&quot;, OP(&quot;*&quot;)),
                      over = PARTITION(order_by = [:year_of_birth],
                                       frame = (mode = :range, start = -1, finish = 1))));

julia&gt; print(render(c))
SELECT &quot;year_of_birth&quot;, (AVG(COUNT(*)) OVER (ORDER BY &quot;year_of_birth&quot; RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING))
FROM &quot;person&quot;
GROUP BY &quot;year_of_birth&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/partition.jl#L96-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.SELECT-Tuple" href="#FunSQL.SELECT-Tuple"><code>FunSQL.SELECT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SELECT(; over = nothing, top = nothing, distinct = false, list)
SELECT(list...; over = nothing, top = nothing, distinct = false)</code></pre><p>A <code>SELECT</code> clause.  Unlike raw SQL, <code>SELECT()</code> should be placed at the end of a clause chain.</p><p>Set <code>distinct</code> to <code>true</code> to add a <code>DISTINCT</code> modifier.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = SELECT(true, false);

julia&gt; print(render(c))
SELECT TRUE, FALSE</code></pre><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:location) |&gt;
           SELECT(distinct = true, :zip);

julia&gt; print(render(c))
SELECT DISTINCT &quot;zip&quot;
FROM &quot;location&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/select.jl#L43-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.ASC-Tuple{}" href="#FunSQL.ASC-Tuple{}"><code>FunSQL.ASC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ASC(; over = nothing, nulls = nothing)</code></pre><p>Ascending order indicator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/sort.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.DESC-Tuple{}" href="#FunSQL.DESC-Tuple{}"><code>FunSQL.DESC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">DESC(; over = nothing, nulls = nothing)</code></pre><p>Descending order indicator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/sort.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.SORT-Tuple" href="#FunSQL.SORT-Tuple"><code>FunSQL.SORT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SORT(; over = nothing, value, nulls = nothing)
SORT(value; over = nothing, nulls = nothing)
ASC(; over = nothing, nulls = nothing)
DESC(; over = nothing, nulls = nothing)</code></pre><p>Sort order options.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           ORDER(:year_of_birth |&gt; DESC()) |&gt;
           SELECT(:person_id);

julia&gt; print(render(c))
SELECT &quot;person_id&quot;
FROM &quot;person&quot;
ORDER BY &quot;year_of_birth&quot; DESC</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/sort.jl#L56-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.UNION-Tuple" href="#FunSQL.UNION-Tuple"><code>FunSQL.UNION</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">UNION(; over = nothing, all = false, list)
UNION(list...; over = nothing, all = false)</code></pre><p>A <code>UNION</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:measurement) |&gt;
           SELECT(:person_id, :date =&gt; :measurement_date) |&gt;
           UNION(all = true,
                 FROM(:observation) |&gt;
                 SELECT(:person_id, :date =&gt; :observation_date));

julia&gt; print(render(c))
SELECT &quot;person_id&quot;, &quot;measurement_date&quot; AS &quot;date&quot;
FROM &quot;measurement&quot;
UNION ALL
SELECT &quot;person_id&quot;, &quot;observation_date&quot; AS &quot;date&quot;
FROM &quot;observation&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/union.jl#L18-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.VAR-Tuple" href="#FunSQL.VAR-Tuple"><code>FunSQL.VAR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">VAR(; name)
VAR(name)</code></pre><p>A placeholder parameter in a prepared statement.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = VAR(:year);

julia&gt; print(render(c))
:year</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/variable.jl#L13-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.WHERE-Tuple" href="#FunSQL.WHERE-Tuple"><code>FunSQL.WHERE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">WHERE(; over = nothing, condition)
WHERE(condition; over = nothing)</code></pre><p>A <code>WHERE</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:location) |&gt;
           WHERE(OP(&quot;=&quot;, :zip, &quot;60614&quot;)) |&gt;
           SELECT(:location_id);

julia&gt; print(render(c))
SELECT &quot;location_id&quot;
FROM &quot;location&quot;
WHERE (&quot;zip&quot; = &#39;60614&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/where.jl#L16-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FunSQL.WINDOW-Tuple" href="#FunSQL.WINDOW-Tuple"><code>FunSQL.WINDOW</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">WINDOW(; over = nothing, list)
WINDOW(list...; over = nothing)</code></pre><p>A <code>WINDOW</code> clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; c = FROM(:person) |&gt;
           WINDOW(:w1 =&gt; PARTITION(:year_of_birth),
                  :w2 =&gt; :w1 |&gt; PARTITION(order_by = [:month_of_birth, :day_of_birth])) |&gt;
           SELECT(:person_id, AGG(&quot;ROW_NUMBER&quot;, over = :w2));

julia&gt; print(render(c))
SELECT &quot;person_id&quot;, (ROW_NUMBER() OVER (&quot;w2&quot;))
FROM &quot;person&quot;
WINDOW &quot;w1&quot; AS (PARTITION BY &quot;year_of_birth&quot;), &quot;w2&quot; AS (&quot;w1&quot; ORDER BY &quot;month_of_birth&quot;, &quot;day_of_birth&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/bc59514f7f5746c59ead421e52fb5834f53ab376/src/clauses/window.jl#L16-L35">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../test/">Test Suite »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Wednesday 18 August 2021 15:39">Wednesday 18 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
