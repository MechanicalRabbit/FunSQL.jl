var documenterSearchIndex = {"docs":
[{"location":"#FunSQL.jl","page":"Home","title":"FunSQL.jl","text":"","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"#SQL-Dialects","page":"Home","title":"SQL Dialects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [FunSQL]\nPages = [\"dialects.jl\"]","category":"page"},{"location":"#FunSQL.SQLDialect","page":"Home","title":"FunSQL.SQLDialect","text":"Properties of a SQL dialect.\n\n\n\n\n\n","category":"type"},{"location":"#SQL-Entities","page":"Home","title":"SQL Entities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [FunSQL]\nPages = [\"entities.jl\"]","category":"page"},{"location":"#FunSQL.SQLTable","page":"Home","title":"FunSQL.SQLTable","text":"SQLTable(; schema = nothing, name, columns)\nSQLTable(name; schema = nothing, columns)\nSQLTable(name, columns...; schema = nothing)\n\nThe structure of a SQL table or a table-like entity (TEMP TABLE, VIEW, etc) for use as a reference in assembling SQL queries.\n\nThe SQLTable constructor expects the table name, a vector columns of column names, and, optionally, the name of the table schema.  A name can be provided as a Symbol or String value.\n\nExamples\n\njulia> t = SQLTable(:location,\n                    :location_id, :address_1, :address_2, :city, :state, :zip);\n\njulia> show(t.name)\n:location\n\njulia> show(t.columns)\n[:location_id, :address_1, :address_2, :city, :state, :zip]\n\njulia> t = SQLTable(schema = \"public\",\n                    name = \"person\",\n                    columns = [\"person_id\", \"birth_datetime\", \"location_id\"]);\n\njulia> show(t.schema)\n:public\n\njulia> show(t.name)\n:person\n\njulia> show(t.columns)\n[:person_id, :birth_datetime, :location_id]\n\n\n\n\n\n","category":"type"},{"location":"#Syntactic-Structure","page":"Home","title":"Syntactic Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [FunSQL]\nPages = [\n    \"clauses.jl\",\n    \"clauses/as.jl\",\n    \"clauses/from.jl\",\n    \"clauses/identifier.jl\",\n    \"clauses/literal.jl\",\n    \"clauses/select.jl\",\n    \"clauses/where.jl\",\n]","category":"page"},{"location":"#FunSQL.AbstractSQLClause","page":"Home","title":"FunSQL.AbstractSQLClause","text":"A part of a SQL query.\n\n\n\n\n\n","category":"type"},{"location":"#FunSQL.SQLClause","page":"Home","title":"FunSQL.SQLClause","text":"An opaque wrapper over an arbitrary SQL clause.\n\n\n\n\n\n","category":"type"},{"location":"#FunSQL.render-Tuple{FunSQL.AbstractSQLClause}","page":"Home","title":"FunSQL.render","text":"render(clause; dialect = :default) :: String\n\nConvert the given SQL clause object to a SQL string.\n\n\n\n\n\n","category":"method"},{"location":"#FunSQL.AS-Tuple","page":"Home","title":"FunSQL.AS","text":"AS(; over = nothing, name)\nAS(name; over = nothing)\n\nAn AS clause.\n\nExamples\n\njulia> c = ID(:person) |> AS(:p);\n\njulia> print(render(c))\n\"person\" AS \"p\"\n\n\n\n\n\n","category":"method"},{"location":"#FunSQL.FROM-Tuple","page":"Home","title":"FunSQL.FROM","text":"FROM(; over = nothing)\nFROM(over)\n\nA FROM clause.\n\nExamples\n\njulia> c = ID(:person) |> AS(:p) |> FROM();\n\njulia> print(render(c))\nFROM \"person\" AS \"p\"\n\n\n\n\n\n","category":"method"},{"location":"#FunSQL.ID-Tuple","page":"Home","title":"FunSQL.ID","text":"ID(; over = nothing, name)\nID(name; over = nothing)\n\nA SQL identifier.  Specify over or use the |> operator to make a qualified identifier.\n\nExamples\n\njulia> c = ID(:person);\n\njulia> print(render(c))\n\"person\"\n\njulia> c = ID(:p) |> ID(:birth_datetime);\n\njulia> print(render(c))\n\"p\".\"birth_datetime\"\n\n\n\n\n\n","category":"method"},{"location":"#FunSQL.LITERAL-Tuple{Any}","page":"Home","title":"FunSQL.LITERAL","text":"LITERAL(val)\n\nA SQL literal.\n\nIn a context of a SQL clause, missing, numbers, strings and datetime values are automatically converted to SQL literals.\n\nExamples\n\njulia> c = LITERAL(missing);\n\njulia> print(render(c))\nNULL\n\njulia> c = LITERAL(\"SQL is fun!\");\n\njulia> print(render(c))\n'SQL is fun!'\n\n\n\n\n\n","category":"method"},{"location":"#FunSQL.SELECT-Tuple","page":"Home","title":"FunSQL.SELECT","text":"SELECT(; over = nothing, distinct = false, list)\nSELECT(list...; over = nothing, distinct = false)\n\nA SELECT clause.  Unlike raw SQL, SELECT() should be placed at the end of a clause chain.\n\nSet distinct to true to add a DISTINCT modifier.\n\nExamples\n\njulia> c = SELECT(true, false);\n\njulia> print(render(c))\nSELECT TRUE, FALSE\n\njulia> c = FROM(:location) |>\n           SELECT(distinct = true, :zip);\n\njulia> print(render(c))\nSELECT DISTINCT zip\nFROM location\n\n\n\n\n\n","category":"method"},{"location":"#FunSQL.WHERE-Tuple","page":"Home","title":"FunSQL.WHERE","text":"WHERE(; over = nothing, condition)\nWHERE(condition; over = nothing)\n\nA WHERE clause.\n\nExamples\n\njulia> c = FROM(:location) |>\n           WHERE(OP(\"=\", :zip, \"60614\")) |>\n           SELECT(:location_id);\n\njulia> print(render(c))\nSELECT \"location_id\"\nFROM \"location\"\nWHERE \"zip\" = '60614'\n\n\n\n\n\n","category":"method"}]
}
