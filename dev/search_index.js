var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [FunSQL]\nPages = [\"FunSQL.jl\"]","category":"page"},{"location":"api/#FunSQL.render","page":"API Reference","title":"FunSQL.render","text":"render(node; dialect = :default) :: String\n\nConvert the given SQL node or clause object to a SQL string.\n\n\n\n\n\n","category":"function"},{"location":"api/#SQL-Dialects","page":"API Reference","title":"SQL Dialects","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [FunSQL]\nPages = [\"dialects.jl\"]","category":"page"},{"location":"api/#FunSQL.SQLDialect","page":"API Reference","title":"FunSQL.SQLDialect","text":"Properties of a SQL dialect.\n\n\n\n\n\n","category":"type"},{"location":"api/#SQL-Entities","page":"API Reference","title":"SQL Entities","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [FunSQL]\nPages = [\"entities.jl\"]","category":"page"},{"location":"api/#FunSQL.SQLTable","page":"API Reference","title":"FunSQL.SQLTable","text":"SQLTable(; schema = nothing, name, columns)\nSQLTable(name; schema = nothing, columns)\nSQLTable(name, columns...; schema = nothing)\n\nThe structure of a SQL table or a table-like entity (TEMP TABLE, VIEW, etc) for use as a reference in assembling SQL queries.\n\nThe SQLTable constructor expects the table name, a vector columns of column names, and, optionally, the name of the table schema.  A name can be provided as a Symbol or String value.\n\nExamples\n\njulia> t = SQLTable(:location,\n                    :location_id, :address_1, :address_2, :city, :state, :zip);\n\n\njulia> show(t.name)\n:location\n\njulia> show(t.columns)\n[:location_id, :address_1, :address_2, :city, :state, :zip]\n\njulia> t = SQLTable(schema = \"public\",\n                    name = \"person\",\n                    columns = [\"person_id\", \"birth_datetime\", \"location_id\"]);\n\njulia> show(t.schema)\n:public\n\njulia> show(t.name)\n:person\n\njulia> show(t.columns)\n[:person_id, :birth_datetime, :location_id]\n\n\n\n\n\n","category":"type"},{"location":"api/#Semantic-Structure","page":"API Reference","title":"Semantic Structure","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [FunSQL]\nPages = [\n    \"nodes.jl\",\n    \"nodes/as.jl\",\n    \"nodes/from.jl\",\n    \"nodes/function.jl\",\n    \"nodes/get.jl\",\n    \"nodes/highlight.jl\",\n    \"nodes/join.jl\",\n    \"nodes/literal.jl\",\n    \"nodes/select.jl\",\n    \"nodes/where.jl\",\n]","category":"page"},{"location":"api/#FunSQL.AbstractSQLNode","page":"API Reference","title":"FunSQL.AbstractSQLNode","text":"A SQL expression.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunSQL.SQLNode","page":"API Reference","title":"FunSQL.SQLNode","text":"An opaque wrapper over an arbitrary SQL node.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunSQL.As-Tuple","page":"API Reference","title":"FunSQL.As","text":"As(; over = nothing; name)\nAs(name; over = nothing)\nname => over\n\nAn alias for a subquery or an expression.\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           As(:p) |>\n           Select(:birth_year => Get.p.year_of_birth);\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.From-Tuple","page":"API Reference","title":"FunSQL.From","text":"From(; table)\nFrom(table)\n\nA subquery that selects columns from the given table.\n\nSELECT ... FROM $table\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person);\n\njulia> print(render(q))\nSELECT \"person_1\".\"person_id\", \"person_1\".\"year_of_birth\"\nFROM \"person\" AS \"person_1\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Fun-Tuple","page":"API Reference","title":"FunSQL.Fun","text":"Fun(; name, args = [])\nFun(name; args = [])\nFun(name, args...)\n\nA function or an operator invocation.\n\nExample\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           Where(Fun.not(Get.person_id .> 2000));\n\njulia> print(render(q))\nSELECT \"person_1\".\"person_id\", \"person_1\".\"year_of_birth\"\nFROM \"person\" AS \"person_1\"\nWHERE (NOT (\"person_1\".\"person_id\" > 2000))\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Get-Tuple","page":"API Reference","title":"FunSQL.Get","text":"Get(; over, name)\nGet(name; over)\nGet.name        Get.\"name\"      Get[name]       Get[\"name\"]\nover.name       over.\"name\"     over[name]      over[\"name\"]\n\nA reference to a table column, or an aliased expression or subquery.\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           As(:p) |>\n           Select(Get.p.person_id);\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person);\n\njulia> q = q |> Select(q.person_id);\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Highlight-Tuple","page":"API Reference","title":"FunSQL.Highlight","text":"Highlight(; over = nothing; color)\nHighlight(color; over = nothing)\n\nHighlight over with the given color.\n\nAvailable colors can be found in Base.text_colors.\n\nExamples\n\njulia> q = Get.person_id |> Highlight(:bold);\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Join-Tuple","page":"API Reference","title":"FunSQL.Join","text":"Join(; over = nothing, joinee, on, left = false, right = false)\nJoin(joinee; over = nothing, on, left = false, right = false)\nJoin(joinee, on; over = nothing, left = false, right = false)\n\nA subquery that joins two subqueries together.\n\nSELECT ... FROM $over JOIN $joinee ON $on\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id, :location_id]);\n\njulia> location = SQLTable(:location, columns = [:location_id, :state]);\n\njulia> q = From(person) |>\n           Join(:location => location,\n                Get.location_id .== Get.location.location_id) |>\n           Select(Get.person_id, Get.location.state);\n\njulia> print(render(q))\nSELECT \"person_1\".\"person_id\", \"location_1\".\"state\"\nFROM \"person\" AS \"person_1\"\nJOIN \"location\" AS \"location_1\" ON (\"person_1\".\"location_id\" = \"location_1\".\"location_id\")\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.LeftJoin-Tuple","page":"API Reference","title":"FunSQL.LeftJoin","text":"An alias for Join(...; ..., left = true).\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Lit-Tuple","page":"API Reference","title":"FunSQL.Lit","text":"Lit(; val)\nLit(val)\n\nA SQL literal.\n\nIn a suitable context, missing, numbers, strings and datetime values are automatically converted to SQL literals.\n\nExamples\n\njulia> q = Select(:null => missing,\n                  :boolean => true,\n                  :integer => 42,\n                  :text => \"SQL is fun!\",\n                  :date => Date(2000));\n\njulia> print(render(q))\nSELECT NULL AS \"null\", TRUE AS \"boolean\", 42 AS \"integer\", 'SQL is fun!' AS \"text\", '2000-01-01' AS \"date\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Select-Tuple","page":"API Reference","title":"FunSQL.Select","text":"Select(; over; list)\nSelect(list...; over)\n\nA subquery that fixes the list of output columns.\n\nSELECT $list... FROM $over\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           Select(Get.person_id);\n\njulia> print(render(q))\nSELECT \"person_1\".\"person_id\"\nFROM \"person\" AS \"person_1\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Where-Tuple","page":"API Reference","title":"FunSQL.Where","text":"Where(; over = nothing, condition)\nWhere(condition; over = nothing)\n\nA subquery that filters by the given condition.\n\nSELECT ... FROM $over WHERE $condition\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           Where(Fun(\">\", Get.year_of_birth, 2000));\n\njulia> print(render(q))\nSELECT \"person_1\".\"person_id\", \"person_1\".\"year_of_birth\"\nFROM \"person\" AS \"person_1\"\nWHERE (\"person_1\".\"year_of_birth\" > 2000)\n\n\n\n\n\n","category":"method"},{"location":"api/#Syntactic-Structure","page":"API Reference","title":"Syntactic Structure","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [FunSQL]\nPages = [\n    \"clauses.jl\",\n    \"clauses/aggregate.jl\",\n    \"clauses/as.jl\",\n    \"clauses/case.jl\",\n    \"clauses/from.jl\",\n    \"clauses/function.jl\",\n    \"clauses/group.jl\",\n    \"clauses/having.jl\",\n    \"clauses/identifier.jl\",\n    \"clauses/join.jl\",\n    \"clauses/keyword.jl\",\n    \"clauses/literal.jl\",\n    \"clauses/operator.jl\",\n    \"clauses/select.jl\",\n    \"clauses/where.jl\",\n]","category":"page"},{"location":"api/#FunSQL.AbstractSQLClause","page":"API Reference","title":"FunSQL.AbstractSQLClause","text":"A part of a SQL query.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunSQL.SQLClause","page":"API Reference","title":"FunSQL.SQLClause","text":"An opaque wrapper over an arbitrary SQL clause.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunSQL.AGG-Tuple","page":"API Reference","title":"FunSQL.AGG","text":"AGG(; name, distinct = false, args = [], filter = nothing)\nAGG(name; distinct = false, args = [], filter = nothing)\nAGG(name, args...; distinct = false, filter = nothing)\n\nAn application of an aggregate function.\n\nExamples\n\njulia> c = AGG(:COUNT, OP(\"*\"));\n\njulia> print(render(c))\nCOUNT(*)\n\njulia> c = AGG(:COUNT, distinct = true, :year_of_birth);\n\njulia> print(render(c))\nCOUNT(DISTINCT \"year_of_birth\")\n\njulia> c = AGG(:COUNT, OP(\"*\"), filter = OP(\">\", :year_of_birth, 1970));\n\njulia> print(render(c))\n(COUNT(*) FILTER (WHERE (\"year_of_birth\" > 1970)))\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.AS-Tuple","page":"API Reference","title":"FunSQL.AS","text":"AS(; over = nothing, name)\nAS(name; over = nothing)\n\nAn AS clause.\n\nExamples\n\njulia> c = ID(:person) |> AS(:p);\n\njulia> print(render(c))\n\"person\" AS \"p\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.CASE-Tuple","page":"API Reference","title":"FunSQL.CASE","text":"CASE(; args)\nCASE(args...)\n\nA CASE expression.\n\nExamples\n\njulia> c = CASE(OP(\"<\", :year_of_birth, 1970), \"boomer\", \"millenial\");\n\njulia> print(render(c))\n(CASE WHEN (\"year_of_birth\" < 1970) THEN 'boomer' ELSE 'millenial' END)\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.FROM-Tuple","page":"API Reference","title":"FunSQL.FROM","text":"FROM(; over = nothing)\nFROM(over)\n\nA FROM clause.\n\nExamples\n\njulia> c = ID(:person) |> AS(:p) |> FROM() |> SELECT((:p, :person_id));\n\njulia> print(render(c))\nSELECT \"p\".\"person_id\"\nFROM \"person\" AS \"p\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.FUN-Tuple","page":"API Reference","title":"FunSQL.FUN","text":"FUN(; name, args = [])\nFUN(name; args = [])\nFUN(name, args...)\n\nAn invocation of a SQL function.\n\nExamples\n\njulia> c = FUN(:EXTRACT, OP(:YEAR), KW(:FROM, FUN(:NOW)));\n\njulia> print(render(c))\nEXTRACT(YEAR FROM NOW())\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.GROUP-Tuple","page":"API Reference","title":"FunSQL.GROUP","text":"GROUP(; over = nothing, partition = [])\nGROUP(partition...; over = nothing)\n\nA GROUP BY clause.\n\nExamples\n\njulia> c = FROM(:person) |>\n           GROUP(:year_of_birth) |>\n           SELECT(:year_of_birth, AGG(\"COUNT\", OP(\"*\")));\n\njulia> print(render(c))\nSELECT \"year_of_birth\", COUNT(*)\nFROM \"person\"\nGROUP BY \"year_of_birth\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.HAVING-Tuple","page":"API Reference","title":"FunSQL.HAVING","text":"HAVING(; over = nothing, condition)\nHAVING(condition; over = nothing)\n\nA HAVING clause.\n\nExamples\n\njulia> c = FROM(:person) |>\n           GROUP(:year_of_birth) |>\n           HAVING(OP(\">\", AGG(\"COUNT\", OP(\"*\")), 10)) |>\n           SELECT(:person_id);\n\njulia> print(render(c))\nSELECT \"person_id\"\nFROM \"person\"\nGROUP BY \"year_of_birth\"\nHAVING (COUNT(*) > 10)\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.ID-Tuple","page":"API Reference","title":"FunSQL.ID","text":"ID(; over = nothing, name)\nID(name; over = nothing)\n\nA SQL identifier.  Specify over or use the |> operator to make a qualified identifier.\n\nExamples\n\njulia> c = ID(:person);\n\njulia> print(render(c))\n\"person\"\n\njulia> c = ID(:p) |> ID(:birth_datetime);\n\njulia> print(render(c))\n\"p\".\"birth_datetime\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.JOIN-Tuple","page":"API Reference","title":"FunSQL.JOIN","text":"JOIN(; over = nothing, joinee, on, left = false, right = false, lateral = false)\nJOIN(joinee; over = nothing, on, left = false, right = false, lateral = false)\nJOIN(joinee, on; over = nothing, left = false, right = false, lateral = false)\n\nA JOIN clause.\n\nExamples\n\njulia> c = FROM(:p => :person) |>\n           JOIN(:l => :location,\n                on = OP(\"=\", (:p, :location_id), (:l, :location_id)),\n                left = true) |>\n           SELECT((:p, :person_id), (:l, :state));\n\njulia> print(render(c))\nSELECT \"p\".\"person_id\", \"l\".\"state\"\nFROM \"person\" AS \"p\"\nLEFT JOIN \"location\" AS \"l\" ON (\"p\".\"location_id\" = \"l\".\"location_id\")\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.KW-Tuple","page":"API Reference","title":"FunSQL.KW","text":"KW(; over = nothing, name)\nKW(name; over = nothing)\nKW(over, name)\n\nA keyword argument of a function or an operator.\n\nExamples\n\njulia> c = FUN(:SUBSTRING, :zip, KW(:FROM, 1), KW(:FOR, 3));\n\njulia> print(render(c))\nSUBSTRING(\"zip\" FROM 1 FOR 3)\n\njulia> c = OP(:BETWEEN, :year_of_birth, 2000, KW(:AND, 2010));\n\njulia> print(render(c))\n(\"year_of_birth\" BETWEEN 2000 AND 2010)\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.LIT-Tuple","page":"API Reference","title":"FunSQL.LIT","text":"LIT(; val)\nLIT(val)\n\nA SQL literal.\n\nIn a context of a SQL clause, missing, numbers, strings and datetime values are automatically converted to SQL literals.\n\nExamples\n\njulia> c = LIT(missing);\n\n\njulia> print(render(c))\nNULL\n\njulia> c = LIT(\"SQL is fun!\");\n\njulia> print(render(c))\n'SQL is fun!'\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.OP-Tuple","page":"API Reference","title":"FunSQL.OP","text":"OP(; name, args = [])\nOP(name; args = [])\nOP(name, args...)\n\nAn application of a SQL operator.\n\nExamples\n\njulia> c = OP(\"NOT\", OP(\"=\", :zip, \"60614\"));\n\njulia> print(render(c))\n(NOT (\"zip\" = '60614'))\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.SELECT-Tuple","page":"API Reference","title":"FunSQL.SELECT","text":"SELECT(; over = nothing, distinct = false, list)\nSELECT(list...; over = nothing, distinct = false)\n\nA SELECT clause.  Unlike raw SQL, SELECT() should be placed at the end of a clause chain.\n\nSet distinct to true to add a DISTINCT modifier.\n\nExamples\n\njulia> c = SELECT(true, false);\n\njulia> print(render(c))\nSELECT TRUE, FALSE\n\njulia> c = FROM(:location) |>\n           SELECT(distinct = true, :zip);\n\njulia> print(render(c))\nSELECT DISTINCT \"zip\"\nFROM \"location\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.WHERE-Tuple","page":"API Reference","title":"FunSQL.WHERE","text":"WHERE(; over = nothing, condition)\nWHERE(condition; over = nothing)\n\nA WHERE clause.\n\nExamples\n\njulia> c = FROM(:location) |>\n           WHERE(OP(\"=\", :zip, \"60614\")) |>\n           SELECT(:location_id);\n\njulia> print(render(c))\nSELECT \"location_id\"\nFROM \"location\"\nWHERE (\"zip\" = '60614')\n\n\n\n\n\n","category":"method"},{"location":"test/entities/#SQL-Entities","page":"SQL Entities","title":"SQL Entities","text":"","category":"section"},{"location":"test/entities/","page":"SQL Entities","title":"SQL Entities","text":"In FunSQL, tables and table-like entities are represented using SQLTable objects.","category":"page"},{"location":"test/entities/","page":"SQL Entities","title":"SQL Entities","text":"using FunSQL: SQLTable","category":"page"},{"location":"test/entities/","page":"SQL Entities","title":"SQL Entities","text":"A SQLTable constructor takes the table name, a vector of column names, and, optionally, the name of the table schema.  A name could be provided either as a Symbol or as a String value.","category":"page"},{"location":"test/entities/","page":"SQL Entities","title":"SQL Entities","text":"location = SQLTable(schema = :public,\n                    name = :location,\n                    columns = [:location_id, :address_1, :address_2,\n                               :city, :state, :zip])\n#-> SQLTable(:location, schema = :public, …)\n\nperson = SQLTable(name = \"person\",\n                  columns = [\"person_id\", \"year_of_birth\", \"location_id\"])\n#-> SQLTable(:person, …)","category":"page"},{"location":"test/entities/","page":"SQL Entities","title":"SQL Entities","text":"The table and the column names could be provided as positional arguments.","category":"page"},{"location":"test/entities/","page":"SQL Entities","title":"SQL Entities","text":"vocabulary = SQLTable(:vocabulary,\n                      columns = [:vocabulary_id, :vocabulary_name])\n#-> SQLTable(:vocabulary, …)\n\nconcept = SQLTable(\"concept\", \"concept_id\", \"concept_name\", \"vocabulary_id\")\n#-> SQLTable(:concept, …)","category":"page"},{"location":"test/entities/","page":"SQL Entities","title":"SQL Entities","text":"A SQLTable object is displayed as a Julia expression that created the object.","category":"page"},{"location":"test/entities/","page":"SQL Entities","title":"SQL Entities","text":"display(location)\n#=>\nSQLTable(:location,\n         schema = :public,\n         columns = [:location_id, :address_1, :address_2, :city, :state, :zip])\n=#\n\ndisplay(person)\n#=>\nSQLTable(:person, columns = [:person_id, :year_of_birth, :location_id])\n=#","category":"page"},{"location":"test/nodes/#SQL-Nodes","page":"SQL Nodes","title":"SQL Nodes","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"using FunSQL:\n    As, Fun, From, Get, Highlight, Join, LeftJoin, Lit, SQLNode, SQLTable,\n    Select, Where, render, resolve","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"We start with specifying the database model.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"person = SQLTable(:person,\n                  columns = [:person_id, :year_of_birth, :location_id])\n\nlocation = SQLTable(:location,\n                    columns = [:location_id, :city, :state])","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"In FunSQL, a SQL query is generated from a tree of SQLNode objects.  The nodes are created using constructors with familiar SQL names and connected together using the chain (|>) operator.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Where(Fun(\">\", Get.year_of_birth, 2000)) |>\n    Select(Get.person_id)\n#-> (…) |> Select(…)","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Displaying a SQLNode object shows how it was constructed.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"display(q)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Where(Fun(\">\", Get.year_of_birth, Lit(2000))),\n    q3 = q2 |> Select(Get.person_id)\n    q3\nend\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Each node wraps a concrete node object, which can be accessed using the indexing operator.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q[]\n#-> ((…) |> Select(…))[]\n\ndisplay(q[])\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Where(Fun(\">\", Get.year_of_birth, Lit(2000))),\n    q3 = q2 |> Select(Get.person_id)\n    q3[]\nend\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"The SQL query is generated using the function render().","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"print(render(q))\n#=>\nSELECT \"person_1\".\"person_id\"\nFROM \"person\" AS \"person_1\"\nWHERE (\"person_1\".\"year_of_birth\" > 2000)\n=#","category":"page"},{"location":"test/nodes/#Literals","page":"SQL Nodes","title":"Literals","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"A SQL value is created with Lit() constructor.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"e = Lit(\"SQL is fun!\")\n#-> Lit(\"SQL is fun!\")","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"In a SELECT clause, bare literal expressions get an alias \"_\".","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = Select(e)\n\nprint(render(q))\n#=>\nSELECT 'SQL is fun!' AS \"_\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Values of certain Julia data types are automatically converted to SQL literals when they are used in the context of a SQL node.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"using Dates\n\nq = Select(\"null\" => missing,\n           \"boolean\" => true,\n           \"integer\" => 42,\n           \"text\" => \"SQL is fun!\",\n           \"date\" => Date(2000))","category":"page"},{"location":"test/nodes/#Attributes","page":"SQL Nodes","title":"Attributes","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"To reference a table attribute, we use the Get constructor.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"e = Get(:person_id)\n#-> Get.person_id","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Alternatively, use shorthand notation.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Get.person_id\n#-> Get.person_id\n\nGet.\"person_id\"\n#-> Get.person_id\n\nGet[:person_id]\n#-> Get.person_id\n\nGet[\"person_id\"]\n#-> Get.person_id","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Hierarchical notation is supported.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"e = Get.p.person_id\n#-> Get.p.person_id\n\nGet.p |> Get.person_id\n#-> Get.p.person_id","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Get can also create bound references.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person)\n\ne = Get(over = q, :year_of_birth)\n#-> (…) |> Get.year_of_birth\n\ndisplay(e)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person)\n    q1.year_of_birth\nend\n=#\n\nq = q |> Where(Fun(\">\", e, 2000))\n\ne = Get(over = q, :person_id)\n#-> (…) |> Get.person_id\n\nq.person_id\n#-> (…) |> Get.person_id\n\nq.\"person_id\"\n#-> (…) |> Get.person_id\n\nq[:person_id]\n#-> (…) |> Get.person_id\n\nq[\"person_id\"]\n#-> (…) |> Get.person_id\n\nq = q |> Select(e)\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\"\nFROM \"person\" AS \"person_1\"\nWHERE (\"person_1\".\"year_of_birth\" > 2000)\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Get is used for dereferencing an alias created with As.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    As(:p) |>\n    Select(Get.p.person_id)\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"When Get refers to an unknown attribute, an error is reported.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = Select(Get.person_id)\n\nprint(render(q))\n#=>\nERROR: GetError: cannot find person_id in:\nSelect(Get.person_id)\n=#\n\nq = From(person) |>\n    As(:p) |>\n    Select(Get.q.person_id)\n\nprint(render(q))\n#=>\nERROR: GetError: cannot find person_id in:\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> As(:p) |> Select(Get.q.person_id)\n    q2\nend\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"An error is also reported when a Get reference cannot be resolved unambiguously.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = person |>\n    Join(person, true) |>\n    Select(Get.person_id)\n\nprint(render(q))\n#=>\nERROR: GetError: ambiguous person_id in:\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = From(person),\n    q3 = q1 |> Join(q2, Lit(true)),\n    q4 = q3 |> Select(Get.person_id)\n    q4\nend\n=#","category":"page"},{"location":"test/nodes/#Operations","page":"SQL Nodes","title":"Operations","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"A function or an operator invocation is created with the Fun constructor.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"e = Fun(\">\", Get.year_of_birth, 2000)\n#-> Fun(\">\", …)\n\ndisplay(e)\n#-> Fun(\">\", Get.year_of_birth, Lit(2000))","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"A vector of arguments could be passed directly.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Fun(\">\", args = SQLNode[Get.year_of_birth, 2000])\n#-> Fun(\">\", …)","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"In a SELECT clause, operator calls get an alias from their name.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"print(render(From(person) |> Select(e)))\n#=>\nSELECT (\"person_1\".\"year_of_birth\" > 2000) AS \">\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/#As","page":"SQL Nodes","title":"As","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"An alias to an expression can be added with the As constructor.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"e = 42 |> As(:integer)\n#-> (…) |> As(:integer)\n\ndisplay(e)\n#-> Lit(42) |> As(:integer)\n\nprint(render(Select(e)))\n#=>\nSELECT 42 AS \"integer\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"As is also used to create an alias for a subquery.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    As(:p) |>\n    Select(Get.p.person_id)\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"As blocks the default output columns.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |> As(:p)\n\nprint(render(q))\n#=>\nSELECT TRUE\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/#From","page":"SQL Nodes","title":"From","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"The From constructor creates a subquery that selects columns from the given table.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person)\n#-> From(…)\n\ndisplay(q)\n#-> From(SQLTable(:person, …))","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"By default, From selects all columns from the table.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"print(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", \"person_1\".\"year_of_birth\", \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"From adds the schema qualifier when the table has the schema.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"concept = SQLTable(schema = :public,\n                   :concept,\n                   columns = [:concept_id, :description])\n\nq = From(concept)\n\nprint(render(q))\n#=>\nSELECT \"concept_1\".\"concept_id\", \"concept_1\".\"description\"\nFROM \"public\".\"concept\" AS \"concept_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"In a suitable context, a SQLTable object is automatically converted to a From subquery.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"print(render(person))\n#=>\nSELECT \"person_1\".\"person_id\", \"person_1\".\"year_of_birth\", \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"From and other subqueries generate a correct SELECT clause when the table has no columns.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"empty = SQLTable(:empty, columns = Symbol[])\n\nq = From(empty) |>\n    Where(true) |>\n    Select(list = [])\n\ndisplay(q)\n#=>\nlet empty = SQLTable(:empty, …),\n    q1 = From(empty),\n    q2 = q1 |> Where(Lit(true)),\n    q3 = q2 |> Select(list = [])\n    q3\nend\n=#\n\nprint(render(q))\n#=>\nSELECT TRUE\nFROM \"empty\" AS \"empty_1\"\nWHERE TRUE\n=#","category":"page"},{"location":"test/nodes/#Join","page":"SQL Nodes","title":"Join","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"The Join constructor creates a subquery that combines the rows of two nested subqueries.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Join(:location => From(location),\n         on = Get.location_id .== Get.location.location_id,\n         left = true)\n#-> (…) |> Join(…)\n\ndisplay(q)\n#=>\nlet person = SQLTable(:person, …),\n    location = SQLTable(:location, …),\n    q1 = From(person),\n    q2 = From(location),\n    q3 = q1 |>\n         Join(q2 |> As(:location),\n              Fun(\"==\", Get.location_id, Get.location.location_id),\n              left = true)\n    q3\nend\n=#\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", \"person_1\".\"year_of_birth\", \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\nLEFT JOIN \"location\" AS \"location_1\" ON (\"person_1\".\"location_id\" = \"location_1\".\"location_id\")\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"LEFT JOIN is commonly used and has its own constructor.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    LeftJoin(:location => From(location),\n             on = Get.location_id .== Get.location.location_id)\n\ndisplay(q)\n#=>\nlet person = SQLTable(:person, …),\n    location = SQLTable(:location, …),\n    q1 = From(person),\n    q2 = From(location),\n    q3 = q1 |>\n         Join(q2 |> As(:location),\n              Fun(\"==\", Get.location_id, Get.location.location_id),\n              left = true)\n    q3\nend\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Nested subqueries that are combined with Join may fail to collapse.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Where(Get.year_of_birth .> 1970) |>\n    Join(:location => From(location) |>\n                      Where(Get.state .== \"IL\"),\n         on = (Get.location_id .== Get.location.location_id)) |>\n    Select(Get.person_id, Get.location.city)\n\nprint(render(q))\n#=>\nSELECT \"person_3\".\"person_id\", \"location_3\".\"city\"\nFROM (\n  SELECT \"person_1\".\"location_id\", \"person_1\".\"person_id\"\n  FROM \"person\" AS \"person_1\"\n  WHERE (\"person_1\".\"year_of_birth\" > 1970)\n) AS \"person_3\"\nJOIN (\n  SELECT \"location_1\".\"location_id\", \"location_1\".\"city\"\n  FROM \"location\" AS \"location_1\"\n  WHERE (\"location_1\".\"state\" = 'IL')\n) AS \"location_3\" ON (\"person_3\".\"location_id\" = \"location_3\".\"location_id\")\n=#","category":"page"},{"location":"test/nodes/#Select","page":"SQL Nodes","title":"Select","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"The Select constructor creates a subquery that fixes the output columns.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Select(Get.person_id)\n#-> (…) |> Select(…)\n\ndisplay(q)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Select(Get.person_id)\n    q2\nend\n=#\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Select does not have to be the last subquery in a chain.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Select(Get.year_of_birth) |>\n    Where(Fun(\">\", Get.year_of_birth, 2000))\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"year_of_birth\"\nFROM \"person\" AS \"person_1\"\nWHERE (\"person_1\".\"year_of_birth\" > 2000)\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Select requires all columns in the list to have unique aliases.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Select(Get.person_id, Get.person_id)\n\nprint(render(q))\n#=>\nERROR: DuplicateAliasError: person_id in:\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Select(Get.person_id, Get.person_id)\n    q2\nend\n=#","category":"page"},{"location":"test/nodes/#Where","page":"SQL Nodes","title":"Where","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"The Where constructor creates a subquery that filters by the given condition.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Where(Fun(\">\", Get.year_of_birth, 2000))\n#-> (…) |> Where(…)\n\ndisplay(q)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Where(Fun(\">\", Get.year_of_birth, Lit(2000)))\n    q2\nend\n=#\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", \"person_1\".\"year_of_birth\", \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\nWHERE (\"person_1\".\"year_of_birth\" > 2000)\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Several Where operations in a row are collapsed in a single WHERE clause.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Where(Fun(\">\", Get.year_of_birth, 2000)) |>\n    Where(Fun(\"<\", Get.year_of_birth, 2020)) |>\n    Where(Fun(\"<>\", Get.year_of_birth, 2010))\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", \"person_1\".\"year_of_birth\", \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\nWHERE ((\"person_1\".\"year_of_birth\" > 2000) AND (\"person_1\".\"year_of_birth\" < 2020) AND (\"person_1\".\"year_of_birth\" <> 2010))\n=#","category":"page"},{"location":"test/nodes/#Highlighting","page":"SQL Nodes","title":"Highlighting","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"To highlight a node on the output, wrap it with Highlight.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Highlight(:underline) |>\n    Where(Fun(\">\", Get.year_of_birth |> Highlight(:bold), 2000) |>\n          Highlight(:white)) |>\n    Select(Get.person_id) |>\n    Highlight(:green)\n#-> (…) |> Highlight(:green)","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"When the query is displayed on a color terminal, the affected node is highlighted.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"display(q)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Where(Fun(\">\", Get.year_of_birth, Lit(2000))),\n    q3 = q2 |> Select(Get.person_id)\n    q3\nend\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"The Highlight node does not otherwise affect processing of the query.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"print(render(q))\n#=>\nSELECT \"person_1\".\"person_id\"\nFROM \"person\" AS \"person_1\"\nWHERE (\"person_1\".\"year_of_birth\" > 2000)\n=#","category":"page"},{"location":"test/clauses/#SQL-Clauses","page":"SQL Clauses","title":"SQL Clauses","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"using FunSQL:\n    AGG, AS, CASE, FROM, FUN, GROUP, HAVING, ID, JOIN, KW, LIT, OP, SELECT,\n    WHERE, render","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"The syntactic structure of a SQL query is represented as a tree of SQLClause objects.  Different types of clauses are created by specialized constructors and connected using the chain (|>) operator.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |>\n    SELECT(:person_id, :year_of_birth)\n#-> (…) |> SELECT(…)","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Displaying a SQLClause object shows how it was constructed.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"display(c)\n#-> ID(:person) |> FROM() |> SELECT(ID(:person_id), ID(:year_of_birth))","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A SQLClause object wraps a concrete clause object, which can be accessed using the indexing operator.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c[]\n#-> ((…) |> SELECT(…))[]\n\ndisplay(c[])\n#-> (ID(:person) |> FROM() |> SELECT(ID(:person_id), ID(:year_of_birth)))[]","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"To generate SQL, we use function render().","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"print(render(c))\n#=>\nSELECT \"person_id\", \"year_of_birth\"\nFROM \"person\"\n=#","category":"page"},{"location":"test/clauses/#SQL-Literals","page":"SQL Clauses","title":"SQL Literals","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A SQL literal is created using a LIT() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = LIT(\"SQL is fun!\")\n#-> LIT(\"SQL is fun!\")","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Values of certain Julia data types are automatically converted to SQL literals when they are used in the context of a SQL clause.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"using Dates\n\nc = SELECT(missing, true, 42, \"SQL is fun!\", Date(2000))\n\n#? VERSION >= v\"1.5.0\"\ndisplay(c)\n#=>\nSELECT(LIT(missing),\n       LIT(true),\n       LIT(42),\n       LIT(\"SQL is fun!\"),\n       LIT(Dates.Date(\"2000-01-01\")))\n=#\n\nprint(render(c))\n#-> SELECT NULL, TRUE, 42, 'SQL is fun!', '2000-01-01'","category":"page"},{"location":"test/clauses/#SQL-Identifiers","page":"SQL Clauses","title":"SQL Identifiers","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A SQL identifier is created with ID() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = ID(:person)\n#-> ID(:person)\n\ndisplay(c)\n#-> ID(:person)\n\nprint(render(c))\n#-> \"person\"","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A quoted identifier is created using pipeline notation.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = ID(:person) |> ID(:year_of_birth)\n#-> (…) |> ID(:year_of_birth)\n\ndisplay(c)\n#-> ID(:person) |> ID(:year_of_birth)\n\nprint(render(c))\n#-> \"person\".\"year_of_birth\"","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Symbols and pairs of symbols are automatically converted to SQL identifiers when they are used in the context of a SQL clause.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:p => :person) |> SELECT((:p, :person_id))\ndisplay(c)\n#-> ID(:person) |> AS(:p) |> FROM() |> SELECT(ID(:p) |> ID(:person_id))\n\nprint(render(c))\n#=>\nSELECT \"p\".\"person_id\"\nFROM \"person\" AS \"p\"\n=#","category":"page"},{"location":"test/clauses/#SQL-Functions","page":"SQL Clauses","title":"SQL Functions","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"An application of a SQL function is created with FUN() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FUN(\"CONCAT\", :city, \", \", :state)\n#-> FUN(\"CONCAT\", …)\n\ndisplay(c)\n#-> FUN(\"CONCAT\", ID(:city), LIT(\", \"), ID(:state))\n\nprint(render(c))\n#-> CONCAT(\"city\", ', ', \"state\")","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A function with special separators can be constructed using KW() clause.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FUN(\"SUBSTRING\", :zip, KW(\"FROM\", 1), KW(\"FOR\", 3))\n#-> FUN(\"SUBSTRING\", …)\n\ndisplay(c)\n#-> FUN(\"SUBSTRING\", ID(:zip), LIT(1) |> KW(:FROM), LIT(3) |> KW(:FOR))\n\nprint(render(c))\n#-> SUBSTRING(\"zip\" FROM 1 FOR 3)","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Functions without arguments are permitted.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FUN(\"NOW\")\n#-> FUN(\"NOW\")\n\nprint(render(c))\n#-> NOW()","category":"page"},{"location":"test/clauses/#Aggregate-Functions","page":"SQL Clauses","title":"Aggregate Functions","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Aggregate SQL functions have a specialized AGG() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = AGG(\"COUNT\", OP(\"*\"))\n#-> AGG(\"COUNT\", …)\n\ndisplay(c)\n#-> AGG(\"COUNT\", OP(\"*\"))\n\nprint(render(c))\n#-> COUNT(*)","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Aggregate functions accept the DISTINCT modifier.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = AGG(\"COUNT\", distinct = true, :year_of_birth)\n\ndisplay(c)\n#-> AGG(\"COUNT\", distinct = true, ID(:year_of_birth))\n\nprint(render(c))\n#-> COUNT(DISTINCT \"year_of_birth\")","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"An aggregate function may have a FILTER modifier.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = AGG(\"COUNT\", OP(\"*\"), filter = OP(\">\", :year_of_birth, 1970))\n\ndisplay(c)\n#-> AGG(\"COUNT\", OP(\"*\"), filter = OP(\">\", ID(:year_of_birth), LIT(1970)))\n\nprint(render(c))\n#-> (COUNT(*) FILTER (WHERE (\"year_of_birth\" > 1970)))","category":"page"},{"location":"test/clauses/#SQL-Operators","page":"SQL Clauses","title":"SQL Operators","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"An application of a SQL operator is created with OP() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = OP(\"NOT\", OP(\"=\", :zip, \"60614\"))\n#-> OP(\"NOT\", …)\n\ndisplay(c)\n#-> OP(\"NOT\", OP(\"=\", ID(:zip), LIT(\"60614\")))\n\nprint(render(c))\n#-> (NOT (\"zip\" = '60614'))","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"An operator without arguments can be constructed, if necessary.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = OP(\"CURRENT_TIMESTAMP\")\n#-> OP(\"CURRENT_TIMESTAMP\")\n\nprint(render(c))\n#-> CURRENT_TIMESTAMP","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A composite operator can be constructed with the help of KW() clause.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = OP(\"BETWEEN\", :year_of_birth, 2000, KW(:AND, 2020))\n\nprint(render(c))\n#-> (\"year_of_birth\" BETWEEN 2000 AND 2020)","category":"page"},{"location":"test/clauses/#CASE-Expression","page":"SQL Clauses","title":"CASE Expression","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A CASE expression is created with CASE() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = CASE(OP(\"<\", :year_of_birth, 1970), \"boomer\")\n#-> CASE(…)\n\ndisplay(c)\n#-> CASE(OP(\"<\", ID(:year_of_birth), LIT(1970)), LIT(\"boomer\"))\n\nprint(render(c))\n#-> (CASE WHEN (\"year_of_birth\" < 1970) THEN 'boomer' END)","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"The arguments of CASE form an interleaving sequence of conditions and the corresponding values.  When CASE has an odd number of arguments, the last argument provides the default value.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = CASE(OP(\"<\", :year_of_birth, 1970), \"boomer\", \"millenial\")\n\nprint(render(c))\n#-> (CASE WHEN (\"year_of_birth\" < 1970) THEN 'boomer' ELSE 'millenial' END)","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"An invalid CASE expression can be constructed.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = CASE(args = [])\n#-> CASE(args = [])","category":"page"},{"location":"test/clauses/#AS-Clause","page":"SQL Clauses","title":"AS Clause","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"An AS clause is created with AS() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = ID(:person) |> AS(:p)\n#-> (…) |> AS(:p)\n\ndisplay(c)\n#-> ID(:person) |> AS(:p)\n\nprint(render(c))\n#-> \"person\" AS \"p\"","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A pair expression is automatically converted to an AS clause.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:p => :person)\ndisplay(c)\n#-> ID(:person) |> AS(:p) |> FROM()\n\nprint(render(c |> SELECT((:p, :person_id))))\n#=>\nSELECT \"p\".\"person_id\"\nFROM \"person\" AS \"p\"\n=#","category":"page"},{"location":"test/clauses/#FROM-Clause","page":"SQL Clauses","title":"FROM Clause","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A FROM clause is created with FROM() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person)\n#-> (…) |> FROM()\n\ndisplay(c)\n#-> ID(:person) |> FROM()\n\nprint(render(c |> SELECT(:person_id)))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\n=#","category":"page"},{"location":"test/clauses/#SELECT-Clause","page":"SQL Clauses","title":"SELECT Clause","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A SELECT clause is created with SELECT() constructor.  While in SQL, SELECT typically opens a query, in FunSQL, SELECT() should be placed at the end of a clause chain.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = :person |> FROM() |> SELECT(:person_id, :year_of_birth)\n#-> (…) |> SELECT(…)\n\ndisplay(c)\n#-> ID(:person) |> FROM() |> SELECT(ID(:person_id), ID(:year_of_birth))\n\nprint(render(c))\n#=>\nSELECT \"person_id\", \"year_of_birth\"\nFROM \"person\"\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"The DISTINCT modifier can be added from the constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:location) |> SELECT(distinct = true, :zip)\n#-> (…) |> SELECT(…)\n\ndisplay(c)\n#-> ID(:location) |> FROM() |> SELECT(distinct = true, ID(:zip))\n\nprint(render(c))\n#=>\nSELECT DISTINCT \"zip\"\nFROM \"location\"\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A SELECT clause with an empty list can be created explicitly.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = SELECT(list = [])\n#-> SELECT(…)","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Rendering a nested SELECT clause adds parentheses around it.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = :location |> FROM() |> SELECT(:state, :zip) |> FROM() |> SELECT(:zip)\n\nprint(render(c))\n#=>\nSELECT \"zip\"\nFROM (\n  SELECT \"state\", \"zip\"\n  FROM \"location\"\n)\n=#","category":"page"},{"location":"test/clauses/#WHERE-Clause","page":"SQL Clauses","title":"WHERE Clause","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A WHERE clause is created with WHERE() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |> WHERE(OP(\">\", :year_of_birth, 2000))\n#-> (…) |> WHERE(…)\n\ndisplay(c)\n#-> ID(:person) |> FROM() |> WHERE(OP(\">\", ID(:year_of_birth), LIT(2000)))\n\nprint(render(c |> SELECT(:person_id)))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nWHERE (\"year_of_birth\" > 2000)\n=#","category":"page"},{"location":"test/clauses/#JOIN-Clause","page":"SQL Clauses","title":"JOIN Clause","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A JOIN clause is created with JOIN() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:p => :person) |>\n    JOIN(:l => :location, OP(\"=\", (:p, :location_id), (:l, :location_id)), left = true)\n#-> (…) |> JOIN(…)\n\ndisplay(c)\n#=>\nID(:person) |>\nAS(:p) |>\nFROM() |>\nJOIN(ID(:location) |> AS(:l),\n     OP(\"=\", ID(:p) |> ID(:location_id), ID(:l) |> ID(:location_id)),\n     left = true)\n=#\n\nprint(render(c |> SELECT((:p, :person_id), (:l, :state))))\n#=>\nSELECT \"p\".\"person_id\", \"l\".\"state\"\nFROM \"person\" AS \"p\"\nLEFT JOIN \"location\" AS \"l\" ON (\"p\".\"location_id\" = \"l\".\"location_id\")\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Different types of JOIN are supported.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:p => :person) |>\n    JOIN(:op => :observation_period,\n         on = OP(\"=\", (:p, :person_id), (:op, :person_id)))\n\ndisplay(c)\n#=>\nID(:person) |>\nAS(:p) |>\nFROM() |>\nJOIN(ID(:observation_period) |> AS(:op),\n     OP(\"=\", ID(:p) |> ID(:person_id), ID(:op) |> ID(:person_id)))\n=#\n\nprint(render(c |> SELECT((:p, :person_id), (:op, :observation_period_start_date))))\n#=>\nSELECT \"p\".\"person_id\", \"op\".\"observation_period_start_date\"\nFROM \"person\" AS \"p\"\nJOIN \"observation_period\" AS \"op\" ON (\"p\".\"person_id\" = \"op\".\"person_id\")\n=#\n\nc = FROM(:l => :location) |>\n    JOIN(:cs => :care_site,\n         on = OP(\"=\", (:l, :location_id), (:cs, :location_id)),\n         right = true)\n\ndisplay(c)\n#=>\nID(:location) |>\nAS(:l) |>\nFROM() |>\nJOIN(ID(:care_site) |> AS(:cs),\n     OP(\"=\", ID(:l) |> ID(:location_id), ID(:cs) |> ID(:location_id)),\n     right = true)\n=#\n\nprint(render(c |> SELECT((:cs, :care_site_name), (:l, :state))))\n#=>\nSELECT \"cs\".\"care_site_name\", \"l\".\"state\"\nFROM \"location\" AS \"l\"\nRIGHT JOIN \"care_site\" AS \"cs\" ON (\"l\".\"location_id\" = \"cs\".\"location_id\")\n=#\n\nc = FROM(:p => :person) |>\n    JOIN(:pr => :provider,\n         on = OP(\"=\", (:p, :provider_id), (:pr, :provider_id)),\n         left = true,\n         right = true)\n\ndisplay(c)\n#=>\nID(:person) |>\nAS(:p) |>\nFROM() |>\nJOIN(ID(:provider) |> AS(:pr),\n     OP(\"=\", ID(:p) |> ID(:provider_id), ID(:pr) |> ID(:provider_id)),\n     left = true,\n     right = true)\n=#\n\nprint(render(c |> SELECT((:p, :person_id), (:pr, :npi))))\n#=>\nSELECT \"p\".\"person_id\", \"pr\".\"npi\"\nFROM \"person\" AS \"p\"\nFULL JOIN \"provider\" AS \"pr\" ON (\"p\".\"provider_id\" = \"pr\".\"provider_id\")\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"To render a CROSS JOIN, set the join condition to true.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:p1 => :person) |>\n    JOIN(:p2 => :person,\n         on = true)\n\nprint(render(c |> SELECT((:p1, :person_id), (:p2, :person_id))))\n#=>\nSELECT \"p1\".\"person_id\", \"p2\".\"person_id\"\nFROM \"person\" AS \"p1\"\nCROSS JOIN \"person\" AS \"p2\"\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A JOIN LATERAL clause can be created.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:p => :person) |>\n    JOIN(:vo => FROM(:vo => :visit_occurrence) |>\n                WHERE(OP(\"=\", (:p, :person_id), (:vo, :person_id))) |>\n                # TODO: add ORDER BY and LIMIT when they are implemented\n                SELECT((:vo, :visit_start_date)),\n         on = true,\n         lateral = true)\n\ndisplay(c)\n#=>\nID(:person) |>\nAS(:p) |>\nFROM() |>\nJOIN(ID(:visit_occurrence) |>\n     AS(:vo) |>\n     FROM() |>\n     WHERE(OP(\"=\", ID(:p) |> ID(:person_id), ID(:vo) |> ID(:person_id))) |>\n     SELECT(ID(:vo) |> ID(:visit_start_date)) |>\n     AS(:vo),\n     LIT(true),\n     lateral = true)\n=#\n\nprint(render(c |> SELECT((:p, :person_id), (:vo, :visit_start_date))))\n#=>\nSELECT \"p\".\"person_id\", \"vo\".\"visit_start_date\"\nFROM \"person\" AS \"p\"\nCROSS JOIN LATERAL (\n  SELECT \"vo\".\"visit_start_date\"\n  FROM \"visit_occurrence\" AS \"vo\"\n  WHERE (\"p\".\"person_id\" = \"vo\".\"person_id\")\n) AS \"vo\"\n=#","category":"page"},{"location":"test/clauses/#GROUP-Clause","page":"SQL Clauses","title":"GROUP Clause","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A GROUP BY clause is created with GROUP constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |> GROUP(:year_of_birth)\n#-> (…) |> GROUP(…)\n\ndisplay(c)\n#-> ID(:person) |> FROM() |> GROUP(ID(:year_of_birth))\n\nprint(render(c |> SELECT(:year_of_birth, AGG(\"COUNT\", OP(\"*\")))))\n#=>\nSELECT \"year_of_birth\", COUNT(*)\nFROM \"person\"\nGROUP BY \"year_of_birth\"\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A GROUP BY clause accepts an empty partition list.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |> GROUP()\n#-> (…) |> GROUP()\n\nprint(render(c |> SELECT(AGG(\"COUNT\", OP(\"*\")))))\n#=>\nSELECT COUNT(*)\nFROM \"person\"\nGROUP BY ()\n=#","category":"page"},{"location":"test/clauses/#HAVING-Clause","page":"SQL Clauses","title":"HAVING Clause","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A HAVING clause is created with HAVING() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |>\n    GROUP(:year_of_birth) |>\n    HAVING(OP(\">\", AGG(\"COUNT\", OP(\"*\")), 10))\n#-> (…) |> HAVING(…)\n\ndisplay(c)\n#=>\nID(:person) |>\nFROM() |>\nGROUP(ID(:year_of_birth)) |>\nHAVING(OP(\">\", AGG(\"COUNT\", OP(\"*\")), LIT(10)))\n=#\n\nprint(render(c |> SELECT(:person_id)))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nGROUP BY \"year_of_birth\"\nHAVING (COUNT(*) > 10)\n=#","category":"page"},{"location":"#FunSQL.jl","page":"Home","title":"FunSQL.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FunSQL is a Julia library for compositional construction of SQL queries.","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"tutorial.md\",\n    \"api.md\",\n    \"test/index.md\",\n]","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Sample-Database","page":"Tutorial","title":"Sample Database","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we consider a tiny SQLite database with a 10 person sample of simulated patient data extracted from CMS DE-SynPuf dataset.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The SQLite database file can be downloaded with the following code.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"const URL = \"https://github.com/MechanicalRabbit/ohdsi-synpuf-demo/releases/download/20210412/synpuf-10p.sqlite\"\nconst DB = download(URL)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternatively, we can create an Artifacts.toml file with a link to the database in order to avoid downloading the file more than once.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg.Artifacts, LazyArtifacts\n\nconst DB = joinpath(artifact\"synpuf-10p\", \"synpuf-10p.sqlite\")\n#-> ⋮","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, we create a connection to the database.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using SQLite\n\nconst conn = SQLite.DB(DB)","category":"page"},{"location":"tutorial/#First-Query","page":"Tutorial","title":"First Query","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using FunSQL: SQLTable, Join, From, Where, Select, Get, render\nusing DataFrames\n\nperson = SQLTable(:person, columns = [:person_id, :year_of_birth, :location_id])\nlocation = SQLTable(:location, columns = [:location_id, :city, :state])\n\nq = person |>\n    Join(:location => location,\n         on = Get.location_id .== Get.location.location_id,\n         left = true) |>\n    Where(Get.year_of_birth .> 1950) |>\n    Select(Get.person_id, Get.location.state)\n\nsql = render(q)\nprint(sql)\n#=>\nSELECT \"person_1\".\"person_id\", \"location_1\".\"state\"\nFROM \"person\" AS \"person_1\"\nLEFT JOIN \"location\" AS \"location_1\" ON (\"person_1\".\"location_id\" = \"location_1\".\"location_id\")\nWHERE (\"person_1\".\"year_of_birth\" > 1950)\n=#\n\nres = DBInterface.execute(conn, sql)\n\nDataFrame(res)\n#=>\n3×2 DataFrame\n Row │ person_id  state\n     │ Int64      String\n─────┼───────────────────\n   1 │     69985  MS\n   2 │     82328  NY\n   3 │    107680  WA\n=#","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can define a convenience function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function run(conn, q)\n    sql = render(q, dialect = :sqlite)\n    res = DBInterface.execute(conn, sql)\n    DataFrame(res)\nend\n\nrun(conn, q)\n#=>\n3×2 DataFrame\n Row │ person_id  state\n     │ Int64      String\n─────┼───────────────────\n   1 │     69985  MS\n   2 │     82328  NY\n   3 │    107680  WA\n=#","category":"page"},{"location":"test/#Test-Suite","page":"Test Suite","title":"Test Suite","text":"","category":"section"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"Pages = [\n    \"clauses.md\",\n    \"entities.md\",\n    \"nodes.md\",\n]","category":"page"}]
}
