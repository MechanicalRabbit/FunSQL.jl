var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [FunSQL]\nPages = [\"FunSQL.jl\"]","category":"page"},{"location":"api/#FunSQL.render","page":"API Reference","title":"FunSQL.render","text":"render(node; dialect = :default) :: String\n\nConvert the given SQL node or clause object to a SQL string.\n\n\n\n\n\n","category":"function"},{"location":"api/#SQL-Dialects","page":"API Reference","title":"SQL Dialects","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [FunSQL]\nPages = [\"dialects.jl\"]","category":"page"},{"location":"api/#FunSQL.SQLDialect","page":"API Reference","title":"FunSQL.SQLDialect","text":"Properties of a SQL dialect.\n\n\n\n\n\n","category":"type"},{"location":"api/#SQL-Entities","page":"API Reference","title":"SQL Entities","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [FunSQL]\nPages = [\"entities.jl\"]","category":"page"},{"location":"api/#FunSQL.SQLTable","page":"API Reference","title":"FunSQL.SQLTable","text":"SQLTable(; schema = nothing, name, columns)\nSQLTable(name; schema = nothing, columns)\nSQLTable(name, columns...; schema = nothing)\n\nThe structure of a SQL table or a table-like entity (TEMP TABLE, VIEW, etc) for use as a reference in assembling SQL queries.\n\nThe SQLTable constructor expects the table name, a vector columns of column names, and, optionally, the name of the table schema.  A name can be provided as a Symbol or String value.\n\nExamples\n\njulia> t = SQLTable(:location,\n                    :location_id, :address_1, :address_2, :city, :state, :zip);\n\n\njulia> show(t.name)\n:location\n\njulia> show(t.columns)\n[:location_id, :address_1, :address_2, :city, :state, :zip]\n\njulia> t = SQLTable(schema = \"public\",\n                    name = \"person\",\n                    columns = [\"person_id\", \"birth_datetime\", \"location_id\"]);\n\njulia> show(t.schema)\n:public\n\njulia> show(t.name)\n:person\n\njulia> show(t.columns)\n[:person_id, :birth_datetime, :location_id]\n\n\n\n\n\n","category":"type"},{"location":"api/#SQL-Statements","page":"API Reference","title":"SQL Statements","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [FunSQL]\nPages = [\"statements.jl\"]","category":"page"},{"location":"api/#FunSQL.SQLStatement","page":"API Reference","title":"FunSQL.SQLStatement","text":"Prepared SQL statement.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunSQL.pack","page":"API Reference","title":"FunSQL.pack","text":"pack(stmt::SQLStatement, vars::Union{Dict, NamedTuple}) :: Vector{Any}\n\nConvert named parameters to positional form.\n\n\n\n\n\n","category":"function"},{"location":"api/#Semantic-Structure","page":"API Reference","title":"Semantic Structure","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [FunSQL]\nPages = [\n    \"nodes.jl\",\n    \"nodes/aggregate.jl\",\n    \"nodes/append.jl\",\n    \"nodes/as.jl\",\n    \"nodes/bind.jl\",\n    \"nodes/define.jl\",\n    \"nodes/from.jl\",\n    \"nodes/function.jl\",\n    \"nodes/get.jl\",\n    \"nodes/group.jl\",\n    \"nodes/highlight.jl\",\n    \"nodes/join.jl\",\n    \"nodes/limit.jl\",\n    \"nodes/literal.jl\",\n    \"nodes/order.jl\",\n    \"nodes/partition.jl\",\n    \"nodes/select.jl\",\n    \"nodes/sort.jl\",\n    \"nodes/variable.jl\",\n    \"nodes/where.jl\",\n]","category":"page"},{"location":"api/#FunSQL.AbstractSQLNode","page":"API Reference","title":"FunSQL.AbstractSQLNode","text":"A SQL expression.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunSQL.SQLNode","page":"API Reference","title":"FunSQL.SQLNode","text":"An opaque wrapper over an arbitrary SQL node.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunSQL.Agg-Tuple","page":"API Reference","title":"FunSQL.Agg","text":"Agg(; over = nothing, name, distinct = false, args = [], filter = nothing)\nAgg(name; over = nothing, distinct = false, args = [], filter = nothing)\nAgg(name, args...; over = nothing, distinct = false, filter = nothing)\n\nAn application of an aggregate function.\n\nExample\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           Group(Get.year_of_birth) |>\n           Select(Get.year_of_birth, Agg.count());\n\njulia> print(render(q))\nSELECT \"person_1\".\"year_of_birth\", COUNT(*) AS \"count\"\nFROM \"person\" AS \"person_1\"\nGROUP BY \"person_1\".\"year_of_birth\"\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           Group() |>\n           Select(Agg.count(distinct = true, Get.year_of_birth));\n\njulia> print(render(q))\nSELECT COUNT(DISTINCT \"person_1\".\"year_of_birth\") AS \"count\"\nFROM \"person\" AS \"person_1\"\n\njulia> person = SQLTable(:person, columns = [:person_id]);\n\njulia> visit_occurrence =\n           SQLTable(:visit_occurrence, columns = [:visit_occurrence_id, :person_id, :visit_start_date]);\n\njulia> q = From(person) |>\n           LeftJoin(:visit_group => From(visit_occurrence) |>\n                                    Group(Get.person_id),\n                    on = (Get.person_id .== Get.visit_group.person_id)) |>\n           Select(Get.person_id,\n                  :max_visit_start_date =>\n                      Get.visit_group |> Agg.max(Get.visit_start_date));\n\njulia> print(render(q))\nSELECT \"person_1\".\"person_id\", \"visit_group_1\".\"max\" AS \"max_visit_start_date\"\nFROM \"person\" AS \"person_1\"\nLEFT JOIN (\n  SELECT \"visit_occurrence_1\".\"person_id\", MAX(\"visit_occurrence_1\".\"visit_start_date\") AS \"max\"\n  FROM \"visit_occurrence\" AS \"visit_occurrence_1\"\n  GROUP BY \"visit_occurrence_1\".\"person_id\"\n) AS \"visit_group_1\" ON (\"person_1\".\"person_id\" = \"visit_group_1\".\"person_id\")\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Append-Tuple","page":"API Reference","title":"FunSQL.Append","text":"Append(; over = nothing, list)\nAppend(list...; over = nothing)\n\nA subquery that combines subqueries using UNION ALL.\n\nSELECT ...\nFROM $over\nUNION ALL\nSELECT ...\nFROM $(list[1])\nUNION ALL\n...\n\nExamples\n\njulia> measurement = SQLTable(:measurement, columns = [:measurement_id, :person_id, :measurement_date]);\n\njulia> observation = SQLTable(:observation, columns = [:observation_id, :person_id, :observation_date]);\n\njulia> q = From(measurement) |>\n           Define(:date => Get.measurement_date) |>\n           Append(From(observation) |>\n                  Define(:date => Get.observation_date)) |>\n           Select(Get.person_id, Get.date);\n\njulia> print(render(q))\nSELECT \"union_1\".\"person_id\", \"union_1\".\"date\"\nFROM (\n  SELECT \"measurement_1\".\"person_id\", \"measurement_1\".\"measurement_date\" AS \"date\"\n  FROM \"measurement\" AS \"measurement_1\"\n  UNION ALL\n  SELECT \"observation_1\".\"person_id\", \"observation_1\".\"observation_date\" AS \"date\"\n  FROM \"observation\" AS \"observation_1\"\n) AS \"union_1\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.As-Tuple","page":"API Reference","title":"FunSQL.As","text":"As(; over = nothing, name)\nAs(name; over = nothing)\nname => over\n\nAn alias for a subquery or an expression.\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           As(:p) |>\n           Select(:birth_year => Get.p.year_of_birth);\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Bind-Tuple","page":"API Reference","title":"FunSQL.Bind","text":"Bind(; over = nothing; list)\nBind(list...; over = nothing)\n\nBind a query parameter to make a correlated subquery.\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id]);\n\njulia> visit_occurrence = SQLTable(:visit_occurrence, columns = [:visit_occurrence_id, :person_id]);\n\njulia> q = From(person) |>\n           Where(Fun.exists(From(visit_occurrence) |>\n                            Where(Get.person_id .== Var.person_id) |>\n                            Bind(Get.person_id)));\n\njulia> print(render(q))\nSELECT \"person_1\".\"person_id\"\nFROM \"person\" AS \"person_1\"\nWHERE (EXISTS (\n  SELECT NULL\n  FROM \"visit_occurrence\" AS \"visit_occurrence_1\"\n  WHERE (\"visit_occurrence_1\".\"person_id\" = \"person_1\".\"person_id\")\n))\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Define-Tuple","page":"API Reference","title":"FunSQL.Define","text":"Define(; over; list = [])\nDefine(list...; over)\n\nA subquery that defines calculated columns.\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id, :birth_datetime]);\n\njulia> q = From(person) |>\n           Define(:age => Fun.now() .- Get.birth_datetime) |>\n           Where(Get.age .> \"16 years\") |>\n           Select(Get.person_id, Get.age);\n\njulia> print(render(q))\nSELECT \"person_1\".\"person_id\", (NOW() - \"person_1\".\"birth_datetime\") AS \"age\"\nFROM \"person\" AS \"person_1\"\nWHERE ((NOW() - \"person_1\".\"birth_datetime\") > '16 years')\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.From-Tuple","page":"API Reference","title":"FunSQL.From","text":"From(; table)\nFrom(table)\n\nA subquery that selects columns from the given table.\n\nSELECT ...\nFROM $table\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person);\n\njulia> print(render(q))\nSELECT \"person_1\".\"person_id\", \"person_1\".\"year_of_birth\"\nFROM \"person\" AS \"person_1\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Fun-Tuple","page":"API Reference","title":"FunSQL.Fun","text":"Fun(; name, args = [])\nFun(name; args = [])\nFun(name, args...)\n\nA function or an operator invocation.\n\nExample\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           Where(Fun.not(Get.person_id .> 2000));\n\njulia> print(render(q))\nSELECT \"person_1\".\"person_id\", \"person_1\".\"year_of_birth\"\nFROM \"person\" AS \"person_1\"\nWHERE (NOT (\"person_1\".\"person_id\" > 2000))\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Get-Tuple","page":"API Reference","title":"FunSQL.Get","text":"Get(; over, name)\nGet(name; over)\nGet.name        Get.\"name\"      Get[name]       Get[\"name\"]\nover.name       over.\"name\"     over[name]      over[\"name\"]\n\nA reference to a table column, or an aliased expression or subquery.\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           As(:p) |>\n           Select(Get.p.person_id);\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person);\n\njulia> q = q |> Select(q.person_id);\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Group-Tuple","page":"API Reference","title":"FunSQL.Group","text":"Group(; over; by = [])\nGroup(by...; over)\n\nA subquery that groups rows by a list of keys.\n\nSELECT ...\nFROM $over\nGROUP BY $by...\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           Group(Get.year_of_birth) |>\n           Select(Get.year_of_birth, Agg.count());\n\njulia> print(render(q))\nSELECT \"person_1\".\"year_of_birth\", COUNT(*) AS \"count\"\nFROM \"person\" AS \"person_1\"\nGROUP BY \"person_1\".\"year_of_birth\"\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           Group() |>\n           Select(Agg.count(distinct = true, Get.year_of_birth));\n\njulia> print(render(q))\nSELECT COUNT(DISTINCT \"person_1\".\"year_of_birth\") AS \"count\"\nFROM \"person\" AS \"person_1\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Highlight-Tuple","page":"API Reference","title":"FunSQL.Highlight","text":"Highlight(; over = nothing; color)\nHighlight(color; over = nothing)\n\nHighlight over with the given color.\n\nAvailable colors can be found in Base.text_colors.\n\nExamples\n\njulia> q = Get.person_id |> Highlight(:bold);\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Join-Tuple","page":"API Reference","title":"FunSQL.Join","text":"Join(; over = nothing, joinee, on, left = false, right = false)\nJoin(joinee; over = nothing, on, left = false, right = false)\nJoin(joinee, on; over = nothing, left = false, right = false)\n\nA subquery that joins two subqueries together.\n\nSELECT ...\nFROM $over\nJOIN $joinee ON $on\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id, :location_id]);\n\njulia> location = SQLTable(:location, columns = [:location_id, :state]);\n\njulia> q = From(person) |>\n           Join(:location => location,\n                Get.location_id .== Get.location.location_id) |>\n           Select(Get.person_id, Get.location.state);\n\njulia> print(render(q))\nSELECT \"person_1\".\"person_id\", \"location_1\".\"state\"\nFROM \"person\" AS \"person_1\"\nJOIN \"location\" AS \"location_1\" ON (\"person_1\".\"location_id\" = \"location_1\".\"location_id\")\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.LeftJoin-Tuple","page":"API Reference","title":"FunSQL.LeftJoin","text":"An alias for Join(...; ..., left = true).\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Limit-Tuple","page":"API Reference","title":"FunSQL.Limit","text":"Limit(; over = nothing, offset = nothing, limit = nothing)\nLimit(limit; over = nothing, offset = nothing)\nLimit(offset, limit; over = nothing)\nLimit(start:stop; over = nothing)\n\nA subquery that takes a fixed-sized slice of the dataset.\n\nSELECT ...\nFROM $over\nOFFSET $offset ROWS\nFETCH NEXT $limit ROWS ONLY\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id]);\n\njulia> q = From(person) |>\n           Limit(1) |>\n           Select(Get.person_id);\n\njulia> print(render(q))\nSELECT \"person_1\".\"person_id\"\nFROM \"person\" AS \"person_1\"\nFETCH FIRST 1 ROW ONLY\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Lit-Tuple","page":"API Reference","title":"FunSQL.Lit","text":"Lit(; val)\nLit(val)\n\nA SQL literal.\n\nIn a suitable context, missing, numbers, strings and datetime values are automatically converted to SQL literals.\n\nExamples\n\njulia> q = Select(:null => missing,\n                  :boolean => true,\n                  :integer => 42,\n                  :text => \"SQL is fun!\",\n                  :date => Date(2000));\n\njulia> print(render(q))\nSELECT NULL AS \"null\", TRUE AS \"boolean\", 42 AS \"integer\", 'SQL is fun!' AS \"text\", '2000-01-01' AS \"date\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Order-Tuple","page":"API Reference","title":"FunSQL.Order","text":"Order(; over = nothing, by)\nOrder(by...; over = nothing)\n\nA subquery that sorts the rows by a list of keys.\n\nSELECT ...\nFROM $over\nORDER BY $by...\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           Order(Get.year_of_birth) |>\n           Select(Get.person_id);\n\njulia> print(render(q))\nSELECT \"person_1\".\"person_id\"\nFROM \"person\" AS \"person_1\"\nORDER BY \"person_1\".\"year_of_birth\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Partition-Tuple","page":"API Reference","title":"FunSQL.Partition","text":"Partition(; over, by = [], order_by = [], frame = nothing)\nPartition(by...; over, order_by = [], frame = nothing)\n\nA subquery that partitions rows by a list of keys.\n\nSELECT ...\nFROM $over\nWINDOW w AS (PARTITION BY $by... ORDER BY $order_by...)\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           Partition(Get.year_of_birth) |>\n           Select(Get.year_of_birth, Agg.row_number());\n\njulia> print(render(q))\nSELECT \"person_1\".\"year_of_birth\", (ROW_NUMBER() OVER (PARTITION BY \"person_1\".\"year_of_birth\")) AS \"row_number\"\nFROM \"person\" AS \"person_1\"\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           Group(Get.year_of_birth) |>\n           Partition(order_by = [Get.year_of_birth],\n                     frame = (mode = :range, start = -1, finish = 1)) |>\n           Select(Get.year_of_birth, Agg.avg(Agg.count()));\n\njulia> print(render(q))\nSELECT \"person_1\".\"year_of_birth\", (AVG(COUNT(*)) OVER (ORDER BY \"person_1\".\"year_of_birth\" RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING)) AS \"avg\"\nFROM \"person\" AS \"person_1\"\nGROUP BY \"person_1\".\"year_of_birth\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Select-Tuple","page":"API Reference","title":"FunSQL.Select","text":"Select(; over; list)\nSelect(list...; over)\n\nA subquery that fixes the list of output columns.\n\nSELECT $list...\nFROM $over\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           Select(Get.person_id);\n\njulia> print(render(q))\nSELECT \"person_1\".\"person_id\"\nFROM \"person\" AS \"person_1\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Asc-Tuple{}","page":"API Reference","title":"FunSQL.Asc","text":"Asc(; over = nothing, nulls = nothing)\n\nAscending order indicator.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Desc-Tuple{}","page":"API Reference","title":"FunSQL.Desc","text":"Desc(; over = nothing, nulls = nothing)\n\nDescending order indicator.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Sort-Tuple","page":"API Reference","title":"FunSQL.Sort","text":"Sort(; over = nothing, value, nulls = nothing)\nSort(value; over = nothing, nulls = nothing)\nAsc(; over = nothing, nulls = nothing)\nDesc(; over = nothing, nulls = nothing)\n\nSort order indicator.\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           Order(Get.year_of_birth |> Desc()) |>\n           Select(Get.person_id);\n\njulia> print(render(q))\nSELECT \"person_1\".\"person_id\"\nFROM \"person\" AS \"person_1\"\nORDER BY \"person_1\".\"year_of_birth\" DESC\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Var-Tuple","page":"API Reference","title":"FunSQL.Var","text":"Var(; name)\nVar(name)\nVar.name        Var.\"name\"      Var[name]       Var[\"name\"]\n\nA reference to a query parameter.\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           Where(Get.year_of_birth .> Var.year);\n\njulia> print(render(q))\nSELECT \"person_1\".\"person_id\", \"person_1\".\"year_of_birth\"\nFROM \"person\" AS \"person_1\"\nWHERE (\"person_1\".\"year_of_birth\" > :year)\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.Where-Tuple","page":"API Reference","title":"FunSQL.Where","text":"Where(; over = nothing, condition)\nWhere(condition; over = nothing)\n\nA subquery that filters by the given condition.\n\nSELECT ...\nFROM $over\nWHERE $condition\n\nExamples\n\njulia> person = SQLTable(:person, columns = [:person_id, :year_of_birth]);\n\njulia> q = From(person) |>\n           Where(Fun(\">\", Get.year_of_birth, 2000));\n\njulia> print(render(q))\nSELECT \"person_1\".\"person_id\", \"person_1\".\"year_of_birth\"\nFROM \"person\" AS \"person_1\"\nWHERE (\"person_1\".\"year_of_birth\" > 2000)\n\n\n\n\n\n","category":"method"},{"location":"api/#Syntactic-Structure","page":"API Reference","title":"Syntactic Structure","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [FunSQL]\nPages = [\n    \"clauses.jl\",\n    \"clauses/aggregate.jl\",\n    \"clauses/as.jl\",\n    \"clauses/case.jl\",\n    \"clauses/from.jl\",\n    \"clauses/function.jl\",\n    \"clauses/group.jl\",\n    \"clauses/having.jl\",\n    \"clauses/identifier.jl\",\n    \"clauses/join.jl\",\n    \"clauses/keyword.jl\",\n    \"clauses/limit.jl\",\n    \"clauses/literal.jl\",\n    \"clauses/operator.jl\",\n    \"clauses/order.jl\",\n    \"clauses/partition.jl\",\n    \"clauses/select.jl\",\n    \"clauses/sort.jl\",\n    \"clauses/union.jl\",\n    \"clauses/variable.jl\",\n    \"clauses/where.jl\",\n    \"clauses/window.jl\",\n]","category":"page"},{"location":"api/#FunSQL.AbstractSQLClause","page":"API Reference","title":"FunSQL.AbstractSQLClause","text":"A part of a SQL query.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunSQL.SQLClause","page":"API Reference","title":"FunSQL.SQLClause","text":"An opaque wrapper over an arbitrary SQL clause.\n\n\n\n\n\n","category":"type"},{"location":"api/#FunSQL.AGG-Tuple","page":"API Reference","title":"FunSQL.AGG","text":"AGG(; name, distinct = false, args = [], filter = nothing, over = nothing)\nAGG(name; distinct = false, args = [], filter = nothing, over = nothing)\nAGG(name, args...; distinct = false, filter = nothing, over = nothing)\n\nAn application of an aggregate function.\n\nExamples\n\njulia> c = AGG(:COUNT, OP(\"*\"));\n\njulia> print(render(c))\nCOUNT(*)\n\njulia> c = AGG(:COUNT, distinct = true, :year_of_birth);\n\njulia> print(render(c))\nCOUNT(DISTINCT \"year_of_birth\")\n\njulia> c = AGG(:COUNT, OP(\"*\"), filter = OP(\">\", :year_of_birth, 1970));\n\njulia> print(render(c))\n(COUNT(*) FILTER (WHERE (\"year_of_birth\" > 1970)))\n\njulia> c = AGG(:ROW_NUMBER, over = PARTITION(:year_of_birth));\n\njulia> print(render(c))\n(ROW_NUMBER() OVER (PARTITION BY \"year_of_birth\"))\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.AS-Tuple","page":"API Reference","title":"FunSQL.AS","text":"AS(; over = nothing, name)\nAS(name; over = nothing)\n\nAn AS clause.\n\nExamples\n\njulia> c = ID(:person) |> AS(:p);\n\njulia> print(render(c))\n\"person\" AS \"p\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.CASE-Tuple","page":"API Reference","title":"FunSQL.CASE","text":"CASE(; args)\nCASE(args...)\n\nA CASE expression.\n\nExamples\n\njulia> c = CASE(OP(\"<\", :year_of_birth, 1970), \"boomer\", \"millenial\");\n\njulia> print(render(c))\n(CASE WHEN (\"year_of_birth\" < 1970) THEN 'boomer' ELSE 'millenial' END)\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.FROM-Tuple","page":"API Reference","title":"FunSQL.FROM","text":"FROM(; over = nothing)\nFROM(over)\n\nA FROM clause.\n\nExamples\n\njulia> c = ID(:person) |> AS(:p) |> FROM() |> SELECT((:p, :person_id));\n\njulia> print(render(c))\nSELECT \"p\".\"person_id\"\nFROM \"person\" AS \"p\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.FUN-Tuple","page":"API Reference","title":"FunSQL.FUN","text":"FUN(; name, args = [])\nFUN(name; args = [])\nFUN(name, args...)\n\nAn invocation of a SQL function.\n\nExamples\n\njulia> c = FUN(:EXTRACT, OP(:YEAR), KW(:FROM, FUN(:NOW)));\n\njulia> print(render(c))\nEXTRACT(YEAR FROM NOW())\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.GROUP-Tuple","page":"API Reference","title":"FunSQL.GROUP","text":"GROUP(; over = nothing, by = [])\nGROUP(by...; over = nothing)\n\nA GROUP BY clause.\n\nExamples\n\njulia> c = FROM(:person) |>\n           GROUP(:year_of_birth) |>\n           SELECT(:year_of_birth, AGG(\"COUNT\", OP(\"*\")));\n\njulia> print(render(c))\nSELECT \"year_of_birth\", COUNT(*)\nFROM \"person\"\nGROUP BY \"year_of_birth\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.HAVING-Tuple","page":"API Reference","title":"FunSQL.HAVING","text":"HAVING(; over = nothing, condition)\nHAVING(condition; over = nothing)\n\nA HAVING clause.\n\nExamples\n\njulia> c = FROM(:person) |>\n           GROUP(:year_of_birth) |>\n           HAVING(OP(\">\", AGG(\"COUNT\", OP(\"*\")), 10)) |>\n           SELECT(:person_id);\n\njulia> print(render(c))\nSELECT \"person_id\"\nFROM \"person\"\nGROUP BY \"year_of_birth\"\nHAVING (COUNT(*) > 10)\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.ID-Tuple","page":"API Reference","title":"FunSQL.ID","text":"ID(; over = nothing, name)\nID(name; over = nothing)\n\nA SQL identifier.  Specify over or use the |> operator to make a qualified identifier.\n\nExamples\n\njulia> c = ID(:person);\n\njulia> print(render(c))\n\"person\"\n\njulia> c = ID(:p) |> ID(:birth_datetime);\n\njulia> print(render(c))\n\"p\".\"birth_datetime\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.JOIN-Tuple","page":"API Reference","title":"FunSQL.JOIN","text":"JOIN(; over = nothing, joinee, on, left = false, right = false, lateral = false)\nJOIN(joinee; over = nothing, on, left = false, right = false, lateral = false)\nJOIN(joinee, on; over = nothing, left = false, right = false, lateral = false)\n\nA JOIN clause.\n\nExamples\n\njulia> c = FROM(:p => :person) |>\n           JOIN(:l => :location,\n                on = OP(\"=\", (:p, :location_id), (:l, :location_id)),\n                left = true) |>\n           SELECT((:p, :person_id), (:l, :state));\n\njulia> print(render(c))\nSELECT \"p\".\"person_id\", \"l\".\"state\"\nFROM \"person\" AS \"p\"\nLEFT JOIN \"location\" AS \"l\" ON (\"p\".\"location_id\" = \"l\".\"location_id\")\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.KW-Tuple","page":"API Reference","title":"FunSQL.KW","text":"KW(; over = nothing, name)\nKW(name; over = nothing)\nKW(over, name)\n\nA keyword argument of a function or an operator.\n\nExamples\n\njulia> c = FUN(:SUBSTRING, :zip, KW(:FROM, 1), KW(:FOR, 3));\n\njulia> print(render(c))\nSUBSTRING(\"zip\" FROM 1 FOR 3)\n\njulia> c = OP(:BETWEEN, :year_of_birth, 2000, KW(:AND, 2010));\n\njulia> print(render(c))\n(\"year_of_birth\" BETWEEN 2000 AND 2010)\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.LIMIT-Tuple","page":"API Reference","title":"FunSQL.LIMIT","text":"LIMIT(; over = nothing, offset = nothing, limit = nothing, with_ties = false)\nLIMIT(limit; over = nothing, offset = nothing, with_ties = false)\nLIMIT(offset, limit; over = nothing, with_ties = false)\nLIMIT(start:stop; over = nothing, with_ties = false)\n\nA LIMIT clause.\n\nExamples\n\njulia> c = FROM(:person) |>\n           LIMIT(1) |>\n           SELECT(:person_id);\n\njulia> print(render(c))\nSELECT \"person_id\"\nFROM \"person\"\nFETCH FIRST 1 ROW ONLY\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.LIT-Tuple","page":"API Reference","title":"FunSQL.LIT","text":"LIT(; val)\nLIT(val)\n\nA SQL literal.\n\nIn a context of a SQL clause, missing, numbers, strings and datetime values are automatically converted to SQL literals.\n\nExamples\n\njulia> c = LIT(missing);\n\n\njulia> print(render(c))\nNULL\n\njulia> c = LIT(\"SQL is fun!\");\n\njulia> print(render(c))\n'SQL is fun!'\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.OP-Tuple","page":"API Reference","title":"FunSQL.OP","text":"OP(; name, args = [])\nOP(name; args = [])\nOP(name, args...)\n\nAn application of a SQL operator.\n\nExamples\n\njulia> c = OP(\"NOT\", OP(\"=\", :zip, \"60614\"));\n\njulia> print(render(c))\n(NOT (\"zip\" = '60614'))\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.ORDER-Tuple","page":"API Reference","title":"FunSQL.ORDER","text":"ORDER(; over = nothing, by = [])\nORDER(by...; over = nothing)\n\nA ORDER BY clause.\n\nExamples\n\njulia> c = FROM(:person) |>\n           ORDER(:year_of_birth) |>\n           SELECT(:person_id);\n\njulia> print(render(c))\nSELECT \"person_id\"\nFROM \"person\"\nORDER BY \"year_of_birth\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.PARTITION-Tuple","page":"API Reference","title":"FunSQL.PARTITION","text":"PARTITION(; over = nothing, by = [], order_by = [], frame = nothing)\nPARTITION(by...; over = nothing, order_by = [], frame = nothing)\n\nA window definition clause.\n\nExamples\n\njulia> c = FROM(:person) |>\n           SELECT(:person_id,\n                  AGG(\"ROW_NUMBER\", over = PARTITION(:year_of_birth)));\n\njulia> print(render(c))\nSELECT \"person_id\", (ROW_NUMBER() OVER (PARTITION BY \"year_of_birth\"))\nFROM \"person\"\n\njulia> c = FROM(:person) |>\n           WINDOW(:w1 => PARTITION(:year_of_birth),\n                  :w2 => :w1 |> PARTITION(order_by = [:month_of_birth, :day_of_birth])) |>\n           SELECT(:person_id, AGG(\"ROW_NUMBER\", over = :w2));\n\njulia> print(render(c))\nSELECT \"person_id\", (ROW_NUMBER() OVER (\"w2\"))\nFROM \"person\"\nWINDOW \"w1\" AS (PARTITION BY \"year_of_birth\"), \"w2\" AS (\"w1\" ORDER BY \"month_of_birth\", \"day_of_birth\")\n\njulia> c = FROM(:person) |>\n           GROUP(:year_of_birth) |>\n           SELECT(:year_of_birth,\n                  AGG(\"AVG\",\n                      AGG(\"COUNT\", OP(\"*\")),\n                      over = PARTITION(order_by = [:year_of_birth],\n                                       frame = (mode = :range, start = -1, finish = 1))));\n\njulia> print(render(c))\nSELECT \"year_of_birth\", (AVG(COUNT(*)) OVER (ORDER BY \"year_of_birth\" RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING))\nFROM \"person\"\nGROUP BY \"year_of_birth\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.SELECT-Tuple","page":"API Reference","title":"FunSQL.SELECT","text":"SELECT(; over = nothing, top = nothing, distinct = false, list)\nSELECT(list...; over = nothing, top = nothing, distinct = false)\n\nA SELECT clause.  Unlike raw SQL, SELECT() should be placed at the end of a clause chain.\n\nSet distinct to true to add a DISTINCT modifier.\n\nExamples\n\njulia> c = SELECT(true, false);\n\njulia> print(render(c))\nSELECT TRUE, FALSE\n\njulia> c = FROM(:location) |>\n           SELECT(distinct = true, :zip);\n\njulia> print(render(c))\nSELECT DISTINCT \"zip\"\nFROM \"location\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.ASC-Tuple{}","page":"API Reference","title":"FunSQL.ASC","text":"ASC(; over = nothing, nulls = nothing)\n\nAscending order indicator.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.DESC-Tuple{}","page":"API Reference","title":"FunSQL.DESC","text":"DESC(; over = nothing, nulls = nothing)\n\nDescending order indicator.\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.SORT-Tuple","page":"API Reference","title":"FunSQL.SORT","text":"SORT(; over = nothing, value, nulls = nothing)\nSORT(value; over = nothing, nulls = nothing)\nASC(; over = nothing, nulls = nothing)\nDESC(; over = nothing, nulls = nothing)\n\nSort order options.\n\nExamples\n\njulia> c = FROM(:person) |>\n           ORDER(:year_of_birth |> DESC()) |>\n           SELECT(:person_id);\n\njulia> print(render(c))\nSELECT \"person_id\"\nFROM \"person\"\nORDER BY \"year_of_birth\" DESC\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.UNION-Tuple","page":"API Reference","title":"FunSQL.UNION","text":"UNION(; over = nothing, all = false, list)\nUNION(list...; over = nothing, all = false)\n\nA UNION clause.\n\nExamples\n\njulia> c = FROM(:measurement) |>\n           SELECT(:person_id, :date => :measurement_date) |>\n           UNION(all = true,\n                 FROM(:observation) |>\n                 SELECT(:person_id, :date => :observation_date));\n\njulia> print(render(c))\nSELECT \"person_id\", \"measurement_date\" AS \"date\"\nFROM \"measurement\"\nUNION ALL\nSELECT \"person_id\", \"observation_date\" AS \"date\"\nFROM \"observation\"\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.VAR-Tuple","page":"API Reference","title":"FunSQL.VAR","text":"VAR(; name)\nVAR(name)\n\nA placeholder parameter in a prepared statement.\n\nExamples\n\njulia> c = VAR(:year);\n\njulia> print(render(c))\n:year\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.WHERE-Tuple","page":"API Reference","title":"FunSQL.WHERE","text":"WHERE(; over = nothing, condition)\nWHERE(condition; over = nothing)\n\nA WHERE clause.\n\nExamples\n\njulia> c = FROM(:location) |>\n           WHERE(OP(\"=\", :zip, \"60614\")) |>\n           SELECT(:location_id);\n\njulia> print(render(c))\nSELECT \"location_id\"\nFROM \"location\"\nWHERE (\"zip\" = '60614')\n\n\n\n\n\n","category":"method"},{"location":"api/#FunSQL.WINDOW-Tuple","page":"API Reference","title":"FunSQL.WINDOW","text":"WINDOW(; over = nothing, list)\nWINDOW(list...; over = nothing)\n\nA WINDOW clause.\n\nExamples\n\njulia> c = FROM(:person) |>\n           WINDOW(:w1 => PARTITION(:year_of_birth),\n                  :w2 => :w1 |> PARTITION(order_by = [:month_of_birth, :day_of_birth])) |>\n           SELECT(:person_id, AGG(\"ROW_NUMBER\", over = :w2));\n\njulia> print(render(c))\nSELECT \"person_id\", (ROW_NUMBER() OVER (\"w2\"))\nFROM \"person\"\nWINDOW \"w1\" AS (PARTITION BY \"year_of_birth\"), \"w2\" AS (\"w1\" ORDER BY \"month_of_birth\", \"day_of_birth\")\n\n\n\n\n\n","category":"method"},{"location":"test/entities/#SQL-Entities","page":"SQL Entities","title":"SQL Entities","text":"","category":"section"},{"location":"test/entities/","page":"SQL Entities","title":"SQL Entities","text":"In FunSQL, tables and table-like entities are represented using SQLTable objects.","category":"page"},{"location":"test/entities/","page":"SQL Entities","title":"SQL Entities","text":"using FunSQL: SQLTable","category":"page"},{"location":"test/entities/","page":"SQL Entities","title":"SQL Entities","text":"A SQLTable constructor takes the table name, a vector of column names, and, optionally, the name of the table schema.  A name could be provided either as a Symbol or as a String value.","category":"page"},{"location":"test/entities/","page":"SQL Entities","title":"SQL Entities","text":"location = SQLTable(schema = :public,\n                    name = :location,\n                    columns = [:location_id, :address_1, :address_2,\n                               :city, :state, :zip])\n#-> SQLTable(:location, schema = :public, …)\n\nperson = SQLTable(name = \"person\",\n                  columns = [\"person_id\", \"year_of_birth\", \"location_id\"])\n#-> SQLTable(:person, …)","category":"page"},{"location":"test/entities/","page":"SQL Entities","title":"SQL Entities","text":"The table and the column names could be provided as positional arguments.","category":"page"},{"location":"test/entities/","page":"SQL Entities","title":"SQL Entities","text":"vocabulary = SQLTable(:vocabulary,\n                      columns = [:vocabulary_id, :vocabulary_name])\n#-> SQLTable(:vocabulary, …)\n\nconcept = SQLTable(\"concept\", \"concept_id\", \"concept_name\", \"vocabulary_id\")\n#-> SQLTable(:concept, …)","category":"page"},{"location":"test/entities/","page":"SQL Entities","title":"SQL Entities","text":"A SQLTable object is displayed as a Julia expression that created the object.","category":"page"},{"location":"test/entities/","page":"SQL Entities","title":"SQL Entities","text":"display(location)\n#=>\nSQLTable(:location,\n         schema = :public,\n         columns = [:location_id, :address_1, :address_2, :city, :state, :zip])\n=#\n\ndisplay(person)\n#=>\nSQLTable(:person, columns = [:person_id, :year_of_birth, :location_id])\n=#","category":"page"},{"location":"test/nodes/#SQL-Nodes","page":"SQL Nodes","title":"SQL Nodes","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"using FunSQL:\n    Agg, Append, As, Asc, Bind, Define, Desc, Fun, From, Get, Group,\n    Highlight, Join, LeftJoin, Limit, Lit, Order, Partition, SQLNode,\n    SQLTable, Select, Sort, Var, Where, render, resolve","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"We start with specifying the database model.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"const concept =\n    SQLTable(:concept, columns = [:concept_id, :vocabulary_id, :concept_code])\n\nconst location =\n    SQLTable(:location, columns = [:location_id, :city, :state])\n\nconst person =\n    SQLTable(:person, columns = [:person_id, :gender_concept_id, :year_of_birth, :month_of_birth, :day_of_birth, :birth_datetime, :location_id])\n\nconst visit_occurrence =\n    SQLTable(:visit_occurrence, columns = [:visit_occurrence_id, :person_id, :visit_start_date, :visit_end_date])\n\nconst measurement =\n    SQLTable(:measurement, columns = [:measurement_id, :person_id, :measurement_date])\n\nconst observation =\n    SQLTable(:observation, columns = [:observation_id, :person_id, :observation_date])","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"In FunSQL, a SQL query is generated from a tree of SQLNode objects.  The nodes are created using constructors with familiar SQL names and connected together using the chain (|>) operator.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Where(Fun.\">\"(Get.year_of_birth, 2000)) |>\n    Select(Get.person_id)\n#-> (…) |> Select(…)","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Displaying a SQLNode object shows how it was constructed.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"display(q)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Where(Fun.\">\"(Get.year_of_birth, Lit(2000))),\n    q3 = q2 |> Select(Get.person_id)\n    q3\nend\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Each node wraps a concrete node object, which can be accessed using the indexing operator.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q[]\n#-> ((…) |> Select(…))[]\n\ndisplay(q[])\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Where(Fun.\">\"(Get.year_of_birth, Lit(2000))),\n    q3 = q2 |> Select(Get.person_id)\n    q3[]\nend\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"The SQL query is generated using the function render().","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"print(render(q))\n#=>\nSELECT \"person_1\".\"person_id\"\nFROM \"person\" AS \"person_1\"\nWHERE (\"person_1\".\"year_of_birth\" > 2000)\n=#","category":"page"},{"location":"test/nodes/#Literals","page":"SQL Nodes","title":"Literals","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"A SQL value is created with Lit() constructor.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"e = Lit(\"SQL is fun!\")\n#-> Lit(\"SQL is fun!\")","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"In a SELECT clause, bare literal expressions get an alias \"_\".","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = Select(e)\n\nprint(render(q))\n#=>\nSELECT 'SQL is fun!' AS \"_\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Values of certain Julia data types are automatically converted to SQL literals when they are used in the context of a SQL node.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"using Dates\n\nq = Select(\"null\" => missing,\n           \"boolean\" => true,\n           \"integer\" => 42,\n           \"text\" => \"SQL is fun!\",\n           \"date\" => Date(2000))","category":"page"},{"location":"test/nodes/#Attributes","page":"SQL Nodes","title":"Attributes","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"To reference a table attribute, we use the Get constructor.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"e = Get(:person_id)\n#-> Get.person_id","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Alternatively, use shorthand notation.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Get.person_id\n#-> Get.person_id\n\nGet.\"person_id\"\n#-> Get.person_id\n\nGet[:person_id]\n#-> Get.person_id\n\nGet[\"person_id\"]\n#-> Get.person_id","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Hierarchical notation is supported.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"e = Get.p.person_id\n#-> Get.p.person_id\n\nGet.p |> Get.person_id\n#-> Get.p.person_id","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Get can also create bound references.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person)\n\ne = Get(over = q, :year_of_birth)\n#-> (…) |> Get.year_of_birth\n\ndisplay(e)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person)\n    q1.year_of_birth\nend\n=#\n\nq = q |> Where(Fun.\">\"(e, 2000))\n\ne = Get(over = q, :person_id)\n#-> (…) |> Get.person_id\n\nq.person_id\n#-> (…) |> Get.person_id\n\nq.\"person_id\"\n#-> (…) |> Get.person_id\n\nq[:person_id]\n#-> (…) |> Get.person_id\n\nq[\"person_id\"]\n#-> (…) |> Get.person_id\n\nq = q |> Select(e)\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\"\nFROM \"person\" AS \"person_1\"\nWHERE (\"person_1\".\"year_of_birth\" > 2000)\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Get is used for dereferencing an alias created with As.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    As(:p) |>\n    Select(Get.p.person_id)\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"When Get refers to an unknown attribute, an error is reported.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = Select(Get.person_id)\n\nprint(render(q))\n#=>\nERROR: GetError: cannot find person_id in:\nSelect(Get.person_id)\n=#\n\nq = From(person) |>\n    As(:p) |>\n    Select(Get.q.person_id)\n\nprint(render(q))\n#=>\nERROR: GetError: cannot find person_id in:\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> As(:p) |> Select(Get.q.person_id)\n    q2\nend\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"An error is also reported when a Get reference cannot be resolved unambiguously.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = person |>\n    Join(person, true) |>\n    Select(Get.person_id)\n\nprint(render(q))\n#=>\nERROR: GetError: ambiguous person_id in:\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = From(person),\n    q3 = q1 |> Join(q2, Lit(true)),\n    q4 = q3 |> Select(Get.person_id)\n    q4\nend\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Any expression could be given a name and attached to a query using the Define constructor.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Define(:age => Fun.now() .- Get.birth_datetime)\n#-> (…) |> Define(…)\n\ndisplay(q)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Define(Fun.\"-\"(Fun.now(), Get.birth_datetime) |> As(:age))\n    q2\nend\n=#\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", …, \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"This expression could be referred to by name as if it were a regular table attribute.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"print(render(q |> Where(Get.age .> \"16 years\")))\n#=>\nSELECT \"person_1\".\"person_id\", …, \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\nWHERE ((NOW() - \"person_1\".\"birth_datetime\") > '16 years')\n=#","category":"page"},{"location":"test/nodes/#Variables","page":"SQL Nodes","title":"Variables","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"A query variable is created with the Var constructor.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"e = Var(:year)\n#-> Var.year","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Alternatively, use shorthand notation.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Var.year\n#-> Var.year\n\nVar.\"year\"\n#-> Var.year\n\nVar[:year]\n#-> Var.year\n\nVar[\"year\"]\n#-> Var.year","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Unbound query variables are serialized as query parameters.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Where(Get.year_of_birth .> Var.year)\n\nsql = render(q)\n\nprint(sql)\n#=>\nSELECT \"person_1\".\"person_id\", …, \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\nWHERE (\"person_1\".\"year_of_birth\" > :year)\n=#\n\nsql.vars\n#-> [:year]","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Query variables could be bound using the Bind constructor.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q0(person_id) =\n    From(visit_occurrence) |>\n    Where(Get.person_id .== Var.person_id) |>\n    Bind(:person_id => person_id)\n\nq0(1)\n#-> (…) |> Bind(…)\n\ndisplay(q0(1))\n#=>\nlet visit_occurrence = SQLTable(:visit_occurrence, …),\n    q1 = From(visit_occurrence),\n    q2 = q1 |> Where(Fun.\"==\"(Get.person_id, Var.person_id))\n    q2 |> Bind(Lit(1) |> As(:person_id))\nend\n=#\n\nprint(render(q0(1)))\n#=>\nSELECT \"visit_occurrence_1\".\"visit_occurrence_id\", …, \"visit_occurrence_1\".\"visit_end_date\"\nFROM \"visit_occurrence\" AS \"visit_occurrence_1\"\nWHERE (\"visit_occurrence_1\".\"person_id\" = 1)\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Bind lets us create correlated subqueries.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Where(Fun.exists(q0(Get.person_id)))\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", …, \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\nWHERE (EXISTS (\n  SELECT NULL\n  FROM \"visit_occurrence\" AS \"visit_occurrence_1\"\n  WHERE (\"visit_occurrence_1\".\"person_id\" = \"person_1\".\"person_id\")\n))\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"An empty Bind can be created.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Bind(list = [])\n#-> Bind(list = [])","category":"page"},{"location":"test/nodes/#Functions-and-Operations","page":"SQL Nodes","title":"Functions and Operations","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"A function or an operator invocation is created with the Fun constructor.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"e = Fun.\">\"(Get.year_of_birth, 2000)\n#-> Fun.:(\">\")(…)\n\ndisplay(e)\n#-> Fun.\">\"(Get.year_of_birth, Lit(2000))","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"A vector of arguments could be passed directly.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Fun.\">\"(args = SQLNode[Get.year_of_birth, 2000])\n#-> Fun.:(\">\")(…)","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"In a SELECT clause, operator calls get an alias from their name.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"print(render(From(person) |> Select(e)))\n#=>\nSELECT (\"person_1\".\"year_of_birth\" > 2000) AS \">\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"A function invocation may include a nested query.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"p = From(person) |>\n    Where(Get.year_of_birth .> 1950)\n\nq = Select(Fun.exists(p))\n\nprint(render(q))\n#=>\nSELECT (EXISTS (\n  SELECT NULL\n  FROM \"person\" AS \"person_1\"\n  WHERE (\"person_1\".\"year_of_birth\" > 1950)\n)) AS \"exists\"\n=#\n\np = From(concept) |>\n    Where(Fun.and(Get.vocabulary_id .== \"Gender\",\n                  Get.concept_code .== \"F\")) |>\n    Select(Get.concept_id)\n\nq = From(person) |>\n    Where(Fun.in(Get.gender_concept_id, p))\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", …, \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\nWHERE (\"person_1\".\"gender_concept_id\" IN (\n  SELECT \"concept_1\".\"concept_id\"\n  FROM \"concept\" AS \"concept_1\"\n  WHERE ((\"concept_1\".\"vocabulary_id\" = 'Gender') AND (\"concept_1\".\"concept_code\" = 'F'))\n))\n=#","category":"page"},{"location":"test/nodes/#Append","page":"SQL Nodes","title":"Append","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"The Append constructor creates a subquery that merges the output of multiple queries.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(measurement) |>\n    Define(:date => Get.measurement_date) |>\n    Append(From(observation) |>\n           Define(:date => Get.observation_date))\n#-> (…) |> Append(…)\n\ndisplay(q)\n#=>\nlet measurement = SQLTable(:measurement, …),\n    observation = SQLTable(:observation, …),\n    q1 = From(measurement),\n    q2 = q1 |> Define(Get.measurement_date |> As(:date)),\n    q3 = From(observation),\n    q4 = q3 |> Define(Get.observation_date |> As(:date)),\n    q5 = q2 |> Append(q4)\n    q5\nend\n=#\n\nprint(render(q |> Select(Get.person_id, Get.date)))\n#=>\nSELECT \"union_1\".\"person_id\", \"union_1\".\"date\"\nFROM (\n  SELECT \"measurement_1\".\"person_id\", \"measurement_1\".\"measurement_date\" AS \"date\"\n  FROM \"measurement\" AS \"measurement_1\"\n  UNION ALL\n  SELECT \"observation_1\".\"person_id\", \"observation_1\".\"observation_date\" AS \"date\"\n  FROM \"observation\" AS \"observation_1\"\n) AS \"union_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"An Append without any queries can be created explicitly.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = Append(list = [])\n#-> Append(list = [])\n\nprint(render(q))\n#-> SELECT NULL","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Without an explicit Select, the output of Append includes the common columns of the nested queries.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = measurement |>\n    Append(observation)\n\nprint(render(q))\n#=>\nSELECT \"measurement_1\".\"person_id\"\nFROM \"measurement\" AS \"measurement_1\"\nUNION ALL\nSELECT \"observation_1\".\"person_id\"\nFROM \"observation\" AS \"observation_1\"\n=#","category":"page"},{"location":"test/nodes/#As","page":"SQL Nodes","title":"As","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"An alias to an expression can be added with the As constructor.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"e = 42 |> As(:integer)\n#-> (…) |> As(:integer)\n\ndisplay(e)\n#-> Lit(42) |> As(:integer)\n\nprint(render(Select(e)))\n#=>\nSELECT 42 AS \"integer\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"As is also used to create an alias for a subquery.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    As(:p) |>\n    Select(Get.p.person_id)\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"As blocks the default output columns.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |> As(:p)\n\nprint(render(q))\n#=>\nSELECT NULL\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/#From","page":"SQL Nodes","title":"From","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"The From constructor creates a subquery that selects columns from the given table.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person)\n#-> From(…)\n\ndisplay(q)\n#-> From(SQLTable(:person, …))","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"By default, From selects all columns from the table.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"print(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", …, \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"From adds the schema qualifier when the table has the schema.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"const pg_database =\n    SQLTable(schema = :pg_catalog, :pg_database, columns = [:oid, :datname])\n\nq = From(pg_database)\n\nprint(render(q))\n#=>\nSELECT \"pg_database_1\".\"oid\", \"pg_database_1\".\"datname\"\nFROM \"pg_catalog\".\"pg_database\" AS \"pg_database_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"In a suitable context, a SQLTable object is automatically converted to a From subquery.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"print(render(person))\n#=>\nSELECT \"person_1\".\"person_id\", …, \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"From and other subqueries generate a correct SELECT clause when the table has no columns.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"empty = SQLTable(:empty, columns = Symbol[])\n\nq = From(empty) |>\n    Where(false) |>\n    Select(list = [])\n\ndisplay(q)\n#=>\nlet empty = SQLTable(:empty, …),\n    q1 = From(empty),\n    q2 = q1 |> Where(Lit(false)),\n    q3 = q2 |> Select(list = [])\n    q3\nend\n=#\n\nprint(render(q))\n#=>\nSELECT NULL\nFROM \"empty\" AS \"empty_1\"\nWHERE FALSE\n=#","category":"page"},{"location":"test/nodes/#Group","page":"SQL Nodes","title":"Group","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"The Group constructor creates a subquery that summarizes the rows partitioned by the given keys.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Group(Get.year_of_birth)\n#-> (…) |> Group(…)\n\ndisplay(q)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Group(Get.year_of_birth)\n    q2\nend\n=#\n\nprint(render(q))\n#=>\nSELECT DISTINCT \"person_1\".\"year_of_birth\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Partitions created by Group are summarized using aggregate expressions.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Group(Get.year_of_birth) |>\n    Select(Get.year_of_birth, Agg.count())\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"year_of_birth\", COUNT(*) AS \"count\"\nFROM \"person\" AS \"person_1\"\nGROUP BY \"person_1\".\"year_of_birth\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Group accepts an empty list of keys.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Group() |>\n    Select(Agg.count(), Agg.min(Get.year_of_birth), Agg.max(Get.year_of_birth))\n\nprint(render(q))\n#=>\nSELECT COUNT(*) AS \"count\", MIN(\"person_1\".\"year_of_birth\") AS \"min\", MAX(\"person_1\".\"year_of_birth\") AS \"max\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Group with no keys and no aggregates creates a trivial subquery.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Group()\n\nprint(render(q))\n#-> SELECT NULL","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Group requires all keys to have unique aliases.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Group(Get.person_id, Get.person_id)\n\nprint(render(q))\n#=>\nERROR: DuplicateAliasError: person_id in:\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Group(Get.person_id, Get.person_id)\n    q2\nend\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Group ensures that each aggregate expression gets a unique alias.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Join(:visit_group => From(visit_occurrence) |>\n                         Group(Get.person_id),\n         on = Get.person_id .== Get.visit_group.person_id) |>\n    Select(Get.person_id,\n           :max_visit_start_date =>\n               Get.visit_group |> Agg.max(Get.visit_start_date),\n           :max_visit_end_date =>\n               Get.visit_group |> Agg.max(Get.visit_end_date))\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", \"visit_group_1\".\"max_1\" AS \"max_visit_start_date\", \"visit_group_1\".\"max_2\" AS \"max_visit_end_date\"\nFROM \"person\" AS \"person_1\"\nJOIN (\n  SELECT \"visit_occurrence_1\".\"person_id\", MAX(\"visit_occurrence_1\".\"visit_start_date\") AS \"max_1\", MAX(\"visit_occurrence_1\".\"visit_end_date\") AS \"max_2\"\n  FROM \"visit_occurrence\" AS \"visit_occurrence_1\"\n  GROUP BY \"visit_occurrence_1\".\"person_id\"\n) AS \"visit_group_1\" ON (\"person_1\".\"person_id\" = \"visit_group_1\".\"person_id\")\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Aggregate expressions can be applied to distinct values of the partition.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"e = Agg.count(distinct = true, Get.year_of_birth)\n#-> Agg.count(distinct = true, …)\n\ndisplay(e)\n#-> Agg.count(distinct = true, Get.year_of_birth)\n\nq = From(person) |> Group() |> Select(e)\n\nprint(render(q))\n#=>\nSELECT COUNT(DISTINCT \"person_1\".\"year_of_birth\") AS \"count\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Aggregate expressions can be applied to a filtered portion of a partition.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"e = Agg.count(filter = Get.year_of_birth .> 1950)\n#-> Agg.count(filter = (…))\n\ndisplay(e)\n#-> Agg.count(filter = Fun.\">\"(Get.year_of_birth, Lit(1950)))\n\nq = From(person) |> Group() |> Select(e)\n\nprint(render(q))\n#=>\nSELECT (COUNT(*) FILTER (WHERE (\"person_1\".\"year_of_birth\" > 1950))) AS \"count\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/#Partition","page":"SQL Nodes","title":"Partition","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"The Partition constructor creates a subquery that partitions the rows by the given keys.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Partition(Get.year_of_birth, order_by = [Get.month_of_birth, Get.day_of_birth])\n#-> (…) |> Partition(…, order_by = […])\n\ndisplay(q)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |>\n         Partition(Get.year_of_birth,\n                   order_by = [Get.month_of_birth, Get.day_of_birth])\n    q2\nend\n=#\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", …, \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Calculations across the rows of the partitions are performed by window functions.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Partition(Get.gender_concept_id) |>\n    Select(Get.person_id, Agg.row_number())\n\ndisplay(q)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Partition(Get.gender_concept_id),\n    q3 = q2 |> Select(Get.person_id, Agg.row_number())\n    q3\nend\n=#\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", (ROW_NUMBER() OVER (PARTITION BY \"person_1\".\"gender_concept_id\")) AS \"row_number\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"A partition may specify the window frame.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Group(Get.year_of_birth) |>\n    Partition(order_by = [Get.year_of_birth],\n              frame = (mode = :range, start = -1, finish = 1)) |>\n    Select(Get.year_of_birth, Agg.avg(Agg.count()))\n\ndisplay(q)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Group(Get.year_of_birth),\n    q3 = q2 |>\n         Partition(order_by = [Get.year_of_birth],\n                   frame = (mode = :RANGE, start = -1, finish = 1)),\n    q4 = q3 |> Select(Get.year_of_birth, Agg.avg(Agg.count()))\n    q4\nend\n=#\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"year_of_birth\", (AVG(COUNT(*)) OVER (ORDER BY \"person_1\".\"year_of_birth\" RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING)) AS \"avg\"\nFROM \"person\" AS \"person_1\"\nGROUP BY \"person_1\".\"year_of_birth\"\n=#","category":"page"},{"location":"test/nodes/#Join","page":"SQL Nodes","title":"Join","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"The Join constructor creates a subquery that combines the rows of two nested subqueries.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Join(:location => From(location),\n         on = Get.location_id .== Get.location.location_id,\n         left = true)\n#-> (…) |> Join(…)\n\ndisplay(q)\n#=>\nlet person = SQLTable(:person, …),\n    location = SQLTable(:location, …),\n    q1 = From(person),\n    q2 = From(location),\n    q3 = q1 |>\n         Join(q2 |> As(:location),\n              Fun.\"==\"(Get.location_id, Get.location.location_id),\n              left = true)\n    q3\nend\n=#\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", …, \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\nLEFT JOIN \"location\" AS \"location_1\" ON (\"person_1\".\"location_id\" = \"location_1\".\"location_id\")\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"LEFT JOIN is commonly used and has its own constructor.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    LeftJoin(:location => From(location),\n             on = Get.location_id .== Get.location.location_id)\n\ndisplay(q)\n#=>\nlet person = SQLTable(:person, …),\n    location = SQLTable(:location, …),\n    q1 = From(person),\n    q2 = From(location),\n    q3 = q1 |>\n         Join(q2 |> As(:location),\n              Fun.\"==\"(Get.location_id, Get.location.location_id),\n              left = true)\n    q3\nend\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Nested subqueries that are combined with Join may fail to collapse.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Where(Get.year_of_birth .> 1970) |>\n    Join(:location => From(location) |>\n                      Where(Get.state .== \"IL\"),\n         on = (Get.location_id .== Get.location.location_id)) |>\n    Select(Get.person_id, Get.location.city)\n\nprint(render(q))\n#=>\nSELECT \"person_3\".\"person_id\", \"location_3\".\"city\"\nFROM (\n  SELECT \"person_1\".\"location_id\", \"person_1\".\"person_id\"\n  FROM \"person\" AS \"person_1\"\n  WHERE (\"person_1\".\"year_of_birth\" > 1970)\n) AS \"person_3\"\nJOIN (\n  SELECT \"location_1\".\"location_id\", \"location_1\".\"city\"\n  FROM \"location\" AS \"location_1\"\n  WHERE (\"location_1\".\"state\" = 'IL')\n) AS \"location_3\" ON (\"person_3\".\"location_id\" = \"location_3\".\"location_id\")\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Join can be applied to correlated subqueries.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q0(person_id) =\n    From(visit_occurrence) |>\n    Where(Get.person_id .== Var.person_id) |>\n    Partition(order_by = [Get.visit_start_date]) |>\n    Where(Agg.row_number() .== 1) |>\n    Bind(:person_id => person_id)\n\nprint(render(q0(1)))\n#=>\nSELECT \"visit_occurrence_4\".\"visit_occurrence_id\", …, \"visit_occurrence_4\".\"visit_end_date\"\nFROM (\n  SELECT (ROW_NUMBER() OVER (ORDER BY \"visit_occurrence_1\".\"visit_start_date\")) AS \"row_number\", \"visit_occurrence_1\".\"visit_occurrence_id\", …, \"visit_occurrence_1\".\"visit_end_date\"\n  FROM \"visit_occurrence\" AS \"visit_occurrence_1\"\n  WHERE (\"visit_occurrence_1\".\"person_id\" = 1)\n) AS \"visit_occurrence_4\"\nWHERE (\"visit_occurrence_4\".\"row_number\" = 1)\n=#\n\nq = From(person) |>\n    Join(:visit => q0(Get.person_id), on = true) |>\n    Select(Get.person_id,\n           Get.visit.visit_occurrence_id,\n           Get.visit.visit_start_date)\n\nprint(render(q))\n#=>\nSELECT \"person_2\".\"person_id\", \"visit_1\".\"visit_occurrence_id\", \"visit_1\".\"visit_start_date\"\nFROM (\n  SELECT \"person_1\".\"person_id\"\n  FROM \"person\" AS \"person_1\"\n) AS \"person_2\"\nCROSS JOIN LATERAL (\n  SELECT \"visit_occurrence_4\".\"visit_occurrence_id\", \"visit_occurrence_4\".\"visit_start_date\"\n  FROM (\n    SELECT (ROW_NUMBER() OVER (ORDER BY \"visit_occurrence_1\".\"visit_start_date\")) AS \"row_number\", \"visit_occurrence_1\".\"visit_occurrence_id\", \"visit_occurrence_1\".\"visit_start_date\"\n    FROM \"visit_occurrence\" AS \"visit_occurrence_1\"\n    WHERE (\"visit_occurrence_1\".\"person_id\" = \"person_2\".\"person_id\")\n  ) AS \"visit_occurrence_4\"\n  WHERE (\"visit_occurrence_4\".\"row_number\" = 1)\n) AS \"visit_1\"\n=#","category":"page"},{"location":"test/nodes/#Order","page":"SQL Nodes","title":"Order","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"The Order constructor creates a subquery for sorting the data.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Order(Get.year_of_birth)\n#-> (…) |> Order(…)\n\ndisplay(q)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Order(Get.year_of_birth)\n    q2\nend\n=#\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", …, \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\nORDER BY \"person_1\".\"year_of_birth\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"It is possible to specify ascending or descending order of the sort column.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Order(Get.year_of_birth |> Desc(nulls = :first),\n          Get.person_id |> Asc())\n\ndisplay(q)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |>\n         Order(Get.year_of_birth |> Desc(nulls = :NULLS_FIRST),\n               Get.person_id |> Asc())\n    q2\nend\n=#\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", …, \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\nORDER BY \"person_1\".\"year_of_birth\" DESC NULLS FIRST, \"person_1\".\"person_id\" ASC\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"A generic Sort constructor could also be used for this purpose.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Order(Get.year_of_birth |> Sort(:desc, nulls = :first),\n          Get.person_id |> Sort(:asc))\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", …, \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\nORDER BY \"person_1\".\"year_of_birth\" DESC NULLS FIRST, \"person_1\".\"person_id\" ASC\n=#","category":"page"},{"location":"test/nodes/#Limit","page":"SQL Nodes","title":"Limit","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"The Limit constructor creates a subquery that takes a fixed-size slice of the dataset.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Order(Get.person_id) |>\n    Limit(10)\n#-> (…) |> Limit(10)\n\ndisplay(q)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Order(Get.person_id),\n    q3 = q2 |> Limit(10)\n    q3\nend\n=#\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", …, \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\nORDER BY \"person_1\".\"person_id\"\nFETCH FIRST 10 ROWS ONLY\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Both the offset and the limit can be specified.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Order(Get.person_id) |>\n    Limit(100, 10)\n\ndisplay(q)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Order(Get.person_id),\n    q3 = q2 |> Limit(100, 10)\n    q3\nend\n=#\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", …, \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\nORDER BY \"person_1\".\"person_id\"\nOFFSET 100 ROWS\nFETCH NEXT 10 ROWS ONLY\n=#\n\nq = From(person) |>\n    Order(Get.person_id) |>\n    Limit(101:110)\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", …, \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\nORDER BY \"person_1\".\"person_id\"\nOFFSET 100 ROWS\nFETCH NEXT 10 ROWS ONLY\n=#","category":"page"},{"location":"test/nodes/#Select","page":"SQL Nodes","title":"Select","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"The Select constructor creates a subquery that fixes the output columns.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Select(Get.person_id)\n#-> (…) |> Select(…)\n\ndisplay(q)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Select(Get.person_id)\n    q2\nend\n=#\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Select does not have to be the last subquery in a chain.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Select(Get.year_of_birth) |>\n    Where(Fun.\">\"(Get.year_of_birth, 2000))\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"year_of_birth\"\nFROM \"person\" AS \"person_1\"\nWHERE (\"person_1\".\"year_of_birth\" > 2000)\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Select requires all columns in the list to have unique aliases.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Select(Get.person_id, Get.person_id)\n\nprint(render(q))\n#=>\nERROR: DuplicateAliasError: person_id in:\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Select(Get.person_id, Get.person_id)\n    q2\nend\n=#","category":"page"},{"location":"test/nodes/#Where","page":"SQL Nodes","title":"Where","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"The Where constructor creates a subquery that filters by the given condition.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Where(Fun.\">\"(Get.year_of_birth, 2000))\n#-> (…) |> Where(…)\n\ndisplay(q)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Where(Fun.\">\"(Get.year_of_birth, Lit(2000)))\n    q2\nend\n=#\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", …, \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\nWHERE (\"person_1\".\"year_of_birth\" > 2000)\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Several Where operations in a row are collapsed in a single WHERE clause.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Where(Fun.\">\"(Get.year_of_birth, 2000)) |>\n    Where(Fun.\"<\"(Get.year_of_birth, 2020)) |>\n    Where(Fun.\"<>\"(Get.year_of_birth, 2010))\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"person_id\", …, \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\nWHERE ((\"person_1\".\"year_of_birth\" > 2000) AND (\"person_1\".\"year_of_birth\" < 2020) AND (\"person_1\".\"year_of_birth\" <> 2010))\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"Where that follows Group subquery is transformed to a HAVING clause.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Group(Get.year_of_birth) |>\n    Where(Agg.count() .> 10)\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"year_of_birth\"\nFROM \"person\" AS \"person_1\"\nGROUP BY \"person_1\".\"year_of_birth\"\nHAVING (COUNT(*) > 10)\n=#\n\nq = From(person) |>\n    Group(Get.year_of_birth) |>\n    Where(Agg.count() .> 10) |>\n    Where(Agg.count() .< 100) |>\n    Where(Fun.and(Agg.count() .!= 33, Agg.count() .!= 66))\n\nprint(render(q))\n#=>\nSELECT \"person_1\".\"year_of_birth\"\nFROM \"person\" AS \"person_1\"\nGROUP BY \"person_1\".\"year_of_birth\"\nHAVING ((COUNT(*) > 10) AND (COUNT(*) < 100) AND (COUNT(*) <> 33) AND (COUNT(*) <> 66))\n=#","category":"page"},{"location":"test/nodes/#Highlighting","page":"SQL Nodes","title":"Highlighting","text":"","category":"section"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"To highlight a node on the output, wrap it with Highlight.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"q = From(person) |>\n    Highlight(:underline) |>\n    Where(Fun.\">\"(Get.year_of_birth |> Highlight(:bold), 2000) |>\n          Highlight(:white)) |>\n    Select(Get.person_id) |>\n    Highlight(:green)\n#-> (…) |> Highlight(:green)","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"When the query is displayed on a color terminal, the affected node is highlighted.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"display(q)\n#=>\nlet person = SQLTable(:person, …),\n    q1 = From(person),\n    q2 = q1 |> Where(Fun.\">\"(Get.year_of_birth, Lit(2000))),\n    q3 = q2 |> Select(Get.person_id)\n    q3\nend\n=#","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"The Highlight node does not otherwise affect processing of the query.","category":"page"},{"location":"test/nodes/","page":"SQL Nodes","title":"SQL Nodes","text":"print(render(q))\n#=>\nSELECT \"person_1\".\"person_id\"\nFROM \"person\" AS \"person_1\"\nWHERE (\"person_1\".\"year_of_birth\" > 2000)\n=#","category":"page"},{"location":"test/clauses/#SQL-Clauses","page":"SQL Clauses","title":"SQL Clauses","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"using FunSQL:\n    AGG, AS, ASC, CASE, DESC, FROM, FUN, GROUP, HAVING, ID, JOIN, KW,\n    LIMIT, LIT, OP, ORDER, PARTITION, SELECT, SORT, UNION, VAR, WHERE,\n    WINDOW, pack, render","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"The syntactic structure of a SQL query is represented as a tree of SQLClause objects.  Different types of clauses are created by specialized constructors and connected using the chain (|>) operator.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |>\n    SELECT(:person_id, :year_of_birth)\n#-> (…) |> SELECT(…)","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Displaying a SQLClause object shows how it was constructed.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"display(c)\n#-> ID(:person) |> FROM() |> SELECT(ID(:person_id), ID(:year_of_birth))","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A SQLClause object wraps a concrete clause object, which can be accessed using the indexing operator.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c[]\n#-> ((…) |> SELECT(…))[]\n\ndisplay(c[])\n#-> (ID(:person) |> FROM() |> SELECT(ID(:person_id), ID(:year_of_birth)))[]","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"To generate SQL, we use function render().","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"print(render(c))\n#=>\nSELECT \"person_id\", \"year_of_birth\"\nFROM \"person\"\n=#","category":"page"},{"location":"test/clauses/#SQL-Literals","page":"SQL Clauses","title":"SQL Literals","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A SQL literal is created using a LIT() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = LIT(\"SQL is fun!\")\n#-> LIT(\"SQL is fun!\")","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Values of certain Julia data types are automatically converted to SQL literals when they are used in the context of a SQL clause.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"using Dates\n\nc = SELECT(missing, true, 42, \"SQL is fun!\", Date(2000))\n\n#? VERSION >= v\"1.5.0\"\ndisplay(c)\n#=>\nSELECT(LIT(missing),\n       LIT(true),\n       LIT(42),\n       LIT(\"SQL is fun!\"),\n       LIT(Dates.Date(\"2000-01-01\")))\n=#\n\nprint(render(c))\n#-> SELECT NULL, TRUE, 42, 'SQL is fun!', '2000-01-01'","category":"page"},{"location":"test/clauses/#SQL-Identifiers","page":"SQL Clauses","title":"SQL Identifiers","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A SQL identifier is created with ID() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = ID(:person)\n#-> ID(:person)\n\ndisplay(c)\n#-> ID(:person)\n\nprint(render(c))\n#-> \"person\"","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Serialization of an identifier depends on the SQL dialect.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"print(render(c, dialect = :sqlserver))\n#-> [person]","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A quoted identifier is created using the chain operator.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = ID(:person) |> ID(:year_of_birth)\n#-> (…) |> ID(:year_of_birth)\n\ndisplay(c)\n#-> ID(:person) |> ID(:year_of_birth)\n\nprint(render(c))\n#-> \"person\".\"year_of_birth\"","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Symbols and pairs of symbols are automatically converted to SQL identifiers when they are used in the context of a SQL clause.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:p => :person) |> SELECT((:p, :person_id))\ndisplay(c)\n#-> ID(:person) |> AS(:p) |> FROM() |> SELECT(ID(:p) |> ID(:person_id))\n\nprint(render(c))\n#=>\nSELECT \"p\".\"person_id\"\nFROM \"person\" AS \"p\"\n=#","category":"page"},{"location":"test/clauses/#SQL-Variables","page":"SQL Clauses","title":"SQL Variables","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Placeholder parameters to a SQL query are created with VAR() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = VAR(:year)\n#-> VAR(:year)\n\ndisplay(c)\n#-> VAR(:year)\n\nprint(render(c))\n#-> :year","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Rendering of a SQL parameter depends on the chosen dialect.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"print(render(c, dialect = :sqlite))\n#-> ?1\n\nprint(render(c, dialect = :postgresql))\n#-> $1\n\nprint(render(c, dialect = :mysql))\n#-> ?","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Function pack() converts named parameters to a positional form.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |>\n    WHERE(OP(\"OR\", OP(\"=\", :gender_concept_id, VAR(:gender)),\n                   OP(\"=\", :gender_source_concept_id, VAR(:gender)))) |>\n    SELECT(:person_id)\n\nsql = render(c, dialect = :sqlite)\n\nprint(sql)\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nWHERE ((\"gender_concept_id\" = ?1) OR (\"gender_source_concept_id\" = ?1))\n=#\n\npack(sql, (gender = 8532,))\n#-> Any[8532]\n\npack(sql, Dict(:gender => 8532))\n#-> Any[8532]\n\npack(sql, Dict(\"gender\" => 8532))\n#-> Any[8532]","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"If the dialect does not support numbered parameters, pack() may need to duplicate parameter values.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"sql = render(c, dialect = :mysql)\n\nprint(sql)\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nWHERE ((\"gender_concept_id\" = ?) OR (\"gender_source_concept_id\" = ?))\n=#\n\npack(sql, (gender = 8532,))\n#-> Any[8532, 8532]","category":"page"},{"location":"test/clauses/#SQL-Functions","page":"SQL Clauses","title":"SQL Functions","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"An application of a SQL function is created with FUN() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FUN(\"CONCAT\", :city, \", \", :state)\n#-> FUN(\"CONCAT\", …)\n\ndisplay(c)\n#-> FUN(\"CONCAT\", ID(:city), LIT(\", \"), ID(:state))\n\nprint(render(c))\n#-> CONCAT(\"city\", ', ', \"state\")","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A function with special separators can be constructed using KW() clause.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FUN(\"SUBSTRING\", :zip, KW(\"FROM\", 1), KW(\"FOR\", 3))\n#-> FUN(\"SUBSTRING\", …)\n\ndisplay(c)\n#-> FUN(\"SUBSTRING\", ID(:zip), LIT(1) |> KW(:FROM), LIT(3) |> KW(:FOR))\n\nprint(render(c))\n#-> SUBSTRING(\"zip\" FROM 1 FOR 3)","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Functions without arguments are permitted.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FUN(\"NOW\")\n#-> FUN(\"NOW\")\n\nprint(render(c))\n#-> NOW()","category":"page"},{"location":"test/clauses/#Aggregate-Functions","page":"SQL Clauses","title":"Aggregate Functions","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Aggregate SQL functions have a specialized AGG() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = AGG(\"COUNT\", OP(\"*\"))\n#-> AGG(\"COUNT\", …)\n\ndisplay(c)\n#-> AGG(\"COUNT\", OP(\"*\"))\n\nprint(render(c))\n#-> COUNT(*)","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Aggregate functions accept the DISTINCT modifier.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = AGG(\"COUNT\", distinct = true, :year_of_birth)\n\ndisplay(c)\n#-> AGG(\"COUNT\", distinct = true, ID(:year_of_birth))\n\nprint(render(c))\n#-> COUNT(DISTINCT \"year_of_birth\")","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"An aggregate function may have a FILTER modifier.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = AGG(\"COUNT\", OP(\"*\"), filter = OP(\">\", :year_of_birth, 1970))\n\ndisplay(c)\n#-> AGG(\"COUNT\", OP(\"*\"), filter = OP(\">\", ID(:year_of_birth), LIT(1970)))\n\nprint(render(c))\n#-> (COUNT(*) FILTER (WHERE (\"year_of_birth\" > 1970)))","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A window function can be created by adding an OVER modifier.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = PARTITION(:year_of_birth, order_by = [:month_of_birth, :day_of_birth]) |>\n    AGG(\"ROW_NUMBER\")\n\ndisplay(c)\n#=>\nAGG(\"ROW_NUMBER\",\n    over = PARTITION(ID(:year_of_birth),\n                     order_by = [ID(:month_of_birth), ID(:day_of_birth)]))\n=#\n\nprint(render(c))\n#-> (ROW_NUMBER() OVER (PARTITION BY \"year_of_birth\" ORDER BY \"month_of_birth\", \"day_of_birth\"))\n\nc = AGG(\"ROW_NUMBER\", over = :w)\n\nprint(render(c))\n#-> (ROW_NUMBER() OVER (\"w\"))","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"The PARTITION clause may contain a frame specification including the frame mode, frame endpoints, and frame exclusion.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = PARTITION(order_by = [:year_of_birth], frame = :groups)\n#-> PARTITION(order_by = […], frame = :GROUPS)\n\nprint(render(c))\n#-> ORDER BY \"year_of_birth\" GROUPS UNBOUNDED PRECEDING\n\nc = PARTITION(order_by = [:year_of_birth], frame = (mode = :rows,))\n#-> PARTITION(order_by = […], frame = :ROWS)\n\nprint(render(c))\n#-> ORDER BY \"year_of_birth\" ROWS UNBOUNDED PRECEDING\n\nc = PARTITION(order_by = [:year_of_birth], frame = (mode = :range, start = -1, finish = 1, exclude = :current_row))\n#-> PARTITION(order_by = […], frame = (mode = :RANGE, start = -1, finish = 1, exclude = :CURRENT_ROW))\n\nprint(render(c))\n#-> ORDER BY \"year_of_birth\" RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING EXCLUDE CURRENT ROW\n\nc = PARTITION(order_by = [:year_of_birth], frame = (mode = :range, start = -Inf, finish = 0))\n\nprint(render(c))\n#-> ORDER BY \"year_of_birth\" RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n\nc = PARTITION(order_by = [:year_of_birth], frame = (mode = :range, start = 0, finish = Inf))\n\nprint(render(c))\n#-> ORDER BY \"year_of_birth\" RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING\n\nc = PARTITION(order_by = [:year_of_birth], frame = (mode = :range, exclude = :no_others))\n\nprint(render(c))\n#-> ORDER BY \"year_of_birth\" RANGE UNBOUNDED PRECEDING EXCLUDE NO OTHERS\n\nc = PARTITION(order_by = [:year_of_birth], frame = (mode = :range, exclude = :group))\n\nprint(render(c))\n#-> ORDER BY \"year_of_birth\" RANGE UNBOUNDED PRECEDING EXCLUDE GROUP\n\nc = PARTITION(order_by = [:year_of_birth], frame = (mode = :range, exclude = :ties))\n\nprint(render(c))\n#-> ORDER BY \"year_of_birth\" RANGE UNBOUNDED PRECEDING EXCLUDE TIES","category":"page"},{"location":"test/clauses/#SQL-Operators","page":"SQL Clauses","title":"SQL Operators","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"An application of a SQL operator is created with OP() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = OP(\"NOT\", OP(\"=\", :zip, \"60614\"))\n#-> OP(\"NOT\", …)\n\ndisplay(c)\n#-> OP(\"NOT\", OP(\"=\", ID(:zip), LIT(\"60614\")))\n\nprint(render(c))\n#-> (NOT (\"zip\" = '60614'))","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"An operator without arguments can be constructed, if necessary.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = OP(\"CURRENT_TIMESTAMP\")\n#-> OP(\"CURRENT_TIMESTAMP\")\n\nprint(render(c))\n#-> CURRENT_TIMESTAMP","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A composite operator can be constructed with the help of KW() clause.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = OP(\"BETWEEN\", :year_of_birth, 2000, KW(:AND, 2020))\n\nprint(render(c))\n#-> (\"year_of_birth\" BETWEEN 2000 AND 2020)","category":"page"},{"location":"test/clauses/#CASE-Expression","page":"SQL Clauses","title":"CASE Expression","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A CASE expression is created with CASE() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = CASE(OP(\"<\", :year_of_birth, 1970), \"boomer\")\n#-> CASE(…)\n\ndisplay(c)\n#-> CASE(OP(\"<\", ID(:year_of_birth), LIT(1970)), LIT(\"boomer\"))\n\nprint(render(c))\n#-> (CASE WHEN (\"year_of_birth\" < 1970) THEN 'boomer' END)","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"The arguments of CASE form an interleaving sequence of conditions and the corresponding values.  When CASE has an odd number of arguments, the last argument provides the default value.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = CASE(OP(\"<\", :year_of_birth, 1970), \"boomer\", \"millenial\")\n\nprint(render(c))\n#-> (CASE WHEN (\"year_of_birth\" < 1970) THEN 'boomer' ELSE 'millenial' END)","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"An invalid CASE expression can be constructed.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = CASE(args = [])\n#-> CASE(args = [])","category":"page"},{"location":"test/clauses/#AS-Clause","page":"SQL Clauses","title":"AS Clause","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"An AS clause is created with AS() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = ID(:person) |> AS(:p)\n#-> (…) |> AS(:p)\n\ndisplay(c)\n#-> ID(:person) |> AS(:p)\n\nprint(render(c))\n#-> \"person\" AS \"p\"","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A pair expression is automatically converted to an AS clause.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:p => :person)\ndisplay(c)\n#-> ID(:person) |> AS(:p) |> FROM()\n\nprint(render(c |> SELECT((:p, :person_id))))\n#=>\nSELECT \"p\".\"person_id\"\nFROM \"person\" AS \"p\"\n=#","category":"page"},{"location":"test/clauses/#FROM-Clause","page":"SQL Clauses","title":"FROM Clause","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A FROM clause is created with FROM() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person)\n#-> (…) |> FROM()\n\ndisplay(c)\n#-> ID(:person) |> FROM()\n\nprint(render(c |> SELECT(:person_id)))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\n=#","category":"page"},{"location":"test/clauses/#SELECT-Clause","page":"SQL Clauses","title":"SELECT Clause","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A SELECT clause is created with SELECT() constructor.  While in SQL, SELECT typically opens a query, in FunSQL, SELECT() should be placed at the end of a clause chain.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = :person |> FROM() |> SELECT(:person_id, :year_of_birth)\n#-> (…) |> SELECT(…)\n\ndisplay(c)\n#-> ID(:person) |> FROM() |> SELECT(ID(:person_id), ID(:year_of_birth))\n\nprint(render(c))\n#=>\nSELECT \"person_id\", \"year_of_birth\"\nFROM \"person\"\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"The DISTINCT modifier can be added from the constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:location) |> SELECT(distinct = true, :zip)\n#-> (…) |> SELECT(…)\n\ndisplay(c)\n#-> ID(:location) |> FROM() |> SELECT(distinct = true, ID(:zip))\n\nprint(render(c))\n#=>\nSELECT DISTINCT \"zip\"\nFROM \"location\"\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A TOP modifier could be specified.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |> SELECT(top = 1, :person_id)\n\ndisplay(c)\n#-> ID(:person) |> FROM() |> SELECT(top = 1, ID(:person_id))\n\nprint(render(c))\n#=>\nSELECT TOP 1 \"person_id\"\nFROM \"person\"\n=#\n\nc = FROM(:person) |>\n    ORDER(:year_of_birth) |>\n    SELECT(top = (limit = 1, with_ties = true), :person_id)\n\ndisplay(c)\n#=>\nID(:person) |>\nFROM() |>\nORDER(ID(:year_of_birth)) |>\nSELECT(top = (limit = 1, with_ties = true), ID(:person_id))\n=#\n\nprint(render(c))\n#=>\nSELECT TOP 1 WITH TIES \"person_id\"\nFROM \"person\"\nORDER BY \"year_of_birth\"\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A SELECT clause with an empty list can be created explicitly.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = SELECT(list = [])\n#-> SELECT(…)","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Rendering a nested SELECT clause adds parentheses around it.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = :location |> FROM() |> SELECT(:state, :zip) |> FROM() |> SELECT(:zip)\n\nprint(render(c))\n#=>\nSELECT \"zip\"\nFROM (\n  SELECT \"state\", \"zip\"\n  FROM \"location\"\n)\n=#","category":"page"},{"location":"test/clauses/#WHERE-Clause","page":"SQL Clauses","title":"WHERE Clause","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A WHERE clause is created with WHERE() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |> WHERE(OP(\">\", :year_of_birth, 2000))\n#-> (…) |> WHERE(…)\n\ndisplay(c)\n#-> ID(:person) |> FROM() |> WHERE(OP(\">\", ID(:year_of_birth), LIT(2000)))\n\nprint(render(c |> SELECT(:person_id)))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nWHERE (\"year_of_birth\" > 2000)\n=#","category":"page"},{"location":"test/clauses/#LIMIT-Clause","page":"SQL Clauses","title":"LIMIT Clause","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A LIMIT/OFFSET (or OFFSET/FETCH) clause is created with LIMIT() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |> LIMIT(10)\n#-> (…) |> LIMIT(10)\n\ndisplay(c)\n#-> ID(:person) |> FROM() |> LIMIT(10)\n\nprint(render(c |> SELECT(:person_id)))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nFETCH FIRST 10 ROWS ONLY\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Non-standard MySQL and SQLite syntax is supported.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"print(render(c |> SELECT(:person_id), dialect = :mysql))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nLIMIT 10\n=#\n\nprint(render(c |> SELECT(:person_id), dialect = :sqlite))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nLIMIT 10\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Both limit (the number of rows) and offset (number of rows to skip) can be specified.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |> LIMIT(100, 10) |> SELECT(:person_id)\n\ndisplay(c)\n#-> ID(:person) |> FROM() |> LIMIT(100, 10) |> SELECT(ID(:person_id))\n\nprint(render(c))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nOFFSET 100 ROWS\nFETCH NEXT 10 ROWS ONLY\n=#\n\nprint(render(c, dialect = :mysql))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nLIMIT 100, 10\n=#\n\nprint(render(c, dialect = :sqlite))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nLIMIT 10\nOFFSET 100\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Alternatively, both limit and offset can be specified as a unit range.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |> LIMIT(101:110)\n\nprint(render(c |> SELECT(:person_id)))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nOFFSET 100 ROWS\nFETCH NEXT 10 ROWS ONLY\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"It is possible to specify the offset without the limit.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |> LIMIT(offset = 100) |> SELECT(:person_id)\n\ndisplay(c)\n#-> ID(:person) |> FROM() |> LIMIT(100, nothing) |> SELECT(ID(:person_id))\n\nprint(render(c))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nOFFSET 100 ROWS\n=#\n\nprint(render(c, dialect = :mysql))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nLIMIT 100, 18446744073709551615\n=#\n\nprint(render(c, dialect = :sqlite))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nLIMIT -1\nOFFSET 100\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"It is possible to specify the limit with ties.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |>\n    ORDER(:year_of_birth) |>\n    LIMIT(10, with_ties = true) |>\n    SELECT(:person_id)\n\ndisplay(c)\n#=>\nID(:person) |>\nFROM() |>\nORDER(ID(:year_of_birth)) |>\nLIMIT(10, with_ties = true) |>\nSELECT(ID(:person_id))\n=#\n\nprint(render(c))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nORDER BY \"year_of_birth\"\nFETCH FIRST 10 ROWS WITH TIES\n=#","category":"page"},{"location":"test/clauses/#JOIN-Clause","page":"SQL Clauses","title":"JOIN Clause","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A JOIN clause is created with JOIN() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:p => :person) |>\n    JOIN(:l => :location, OP(\"=\", (:p, :location_id), (:l, :location_id)), left = true)\n#-> (…) |> JOIN(…)\n\ndisplay(c)\n#=>\nID(:person) |>\nAS(:p) |>\nFROM() |>\nJOIN(ID(:location) |> AS(:l),\n     OP(\"=\", ID(:p) |> ID(:location_id), ID(:l) |> ID(:location_id)),\n     left = true)\n=#\n\nprint(render(c |> SELECT((:p, :person_id), (:l, :state))))\n#=>\nSELECT \"p\".\"person_id\", \"l\".\"state\"\nFROM \"person\" AS \"p\"\nLEFT JOIN \"location\" AS \"l\" ON (\"p\".\"location_id\" = \"l\".\"location_id\")\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Different types of JOIN are supported.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:p => :person) |>\n    JOIN(:op => :observation_period,\n         on = OP(\"=\", (:p, :person_id), (:op, :person_id)))\n\ndisplay(c)\n#=>\nID(:person) |>\nAS(:p) |>\nFROM() |>\nJOIN(ID(:observation_period) |> AS(:op),\n     OP(\"=\", ID(:p) |> ID(:person_id), ID(:op) |> ID(:person_id)))\n=#\n\nprint(render(c |> SELECT((:p, :person_id), (:op, :observation_period_start_date))))\n#=>\nSELECT \"p\".\"person_id\", \"op\".\"observation_period_start_date\"\nFROM \"person\" AS \"p\"\nJOIN \"observation_period\" AS \"op\" ON (\"p\".\"person_id\" = \"op\".\"person_id\")\n=#\n\nc = FROM(:l => :location) |>\n    JOIN(:cs => :care_site,\n         on = OP(\"=\", (:l, :location_id), (:cs, :location_id)),\n         right = true)\n\ndisplay(c)\n#=>\nID(:location) |>\nAS(:l) |>\nFROM() |>\nJOIN(ID(:care_site) |> AS(:cs),\n     OP(\"=\", ID(:l) |> ID(:location_id), ID(:cs) |> ID(:location_id)),\n     right = true)\n=#\n\nprint(render(c |> SELECT((:cs, :care_site_name), (:l, :state))))\n#=>\nSELECT \"cs\".\"care_site_name\", \"l\".\"state\"\nFROM \"location\" AS \"l\"\nRIGHT JOIN \"care_site\" AS \"cs\" ON (\"l\".\"location_id\" = \"cs\".\"location_id\")\n=#\n\nc = FROM(:p => :person) |>\n    JOIN(:pr => :provider,\n         on = OP(\"=\", (:p, :provider_id), (:pr, :provider_id)),\n         left = true,\n         right = true)\n\ndisplay(c)\n#=>\nID(:person) |>\nAS(:p) |>\nFROM() |>\nJOIN(ID(:provider) |> AS(:pr),\n     OP(\"=\", ID(:p) |> ID(:provider_id), ID(:pr) |> ID(:provider_id)),\n     left = true,\n     right = true)\n=#\n\nprint(render(c |> SELECT((:p, :person_id), (:pr, :npi))))\n#=>\nSELECT \"p\".\"person_id\", \"pr\".\"npi\"\nFROM \"person\" AS \"p\"\nFULL JOIN \"provider\" AS \"pr\" ON (\"p\".\"provider_id\" = \"pr\".\"provider_id\")\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"To render a CROSS JOIN, set the join condition to true.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:p1 => :person) |>\n    JOIN(:p2 => :person,\n         on = true)\n\nprint(render(c |> SELECT((:p1, :person_id), (:p2, :person_id))))\n#=>\nSELECT \"p1\".\"person_id\", \"p2\".\"person_id\"\nFROM \"person\" AS \"p1\"\nCROSS JOIN \"person\" AS \"p2\"\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A JOIN LATERAL clause can be created.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:p => :person) |>\n    JOIN(:vo => FROM(:vo => :visit_occurrence) |>\n                WHERE(OP(\"=\", (:p, :person_id), (:vo, :person_id))) |>\n                ORDER((:vo, :visit_start_date) |> DESC()) |>\n                LIMIT(1) |>\n                SELECT((:vo, :visit_start_date)),\n         on = true,\n         left = true,\n         lateral = true)\n\ndisplay(c)\n#=>\nID(:person) |>\nAS(:p) |>\nFROM() |>\nJOIN(ID(:visit_occurrence) |>\n     AS(:vo) |>\n     FROM() |>\n     WHERE(OP(\"=\", ID(:p) |> ID(:person_id), ID(:vo) |> ID(:person_id))) |>\n     ORDER(ID(:vo) |> ID(:visit_start_date) |> DESC()) |>\n     LIMIT(1) |>\n     SELECT(ID(:vo) |> ID(:visit_start_date)) |>\n     AS(:vo),\n     LIT(true),\n     left = true,\n     lateral = true)\n=#\n\nprint(render(c |> SELECT((:p, :person_id), (:vo, :visit_start_date))))\n#=>\nSELECT \"p\".\"person_id\", \"vo\".\"visit_start_date\"\nFROM \"person\" AS \"p\"\nLEFT JOIN LATERAL (\n  SELECT \"vo\".\"visit_start_date\"\n  FROM \"visit_occurrence\" AS \"vo\"\n  WHERE (\"p\".\"person_id\" = \"vo\".\"person_id\")\n  ORDER BY \"vo\".\"visit_start_date\" DESC\n  FETCH FIRST 1 ROW ONLY\n) AS \"vo\" ON TRUE\n=#","category":"page"},{"location":"test/clauses/#GROUP-Clause","page":"SQL Clauses","title":"GROUP Clause","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A GROUP BY clause is created with GROUP constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |> GROUP(:year_of_birth)\n#-> (…) |> GROUP(…)\n\ndisplay(c)\n#-> ID(:person) |> FROM() |> GROUP(ID(:year_of_birth))\n\nprint(render(c |> SELECT(:year_of_birth, AGG(\"COUNT\", OP(\"*\")))))\n#=>\nSELECT \"year_of_birth\", COUNT(*)\nFROM \"person\"\nGROUP BY \"year_of_birth\"\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A GROUP constructor accepts an empty partition list, in which case, it is not rendered.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |> GROUP()\n#-> (…) |> GROUP()\n\nprint(render(c |> SELECT(AGG(\"COUNT\", OP(\"*\")))))\n#=>\nSELECT COUNT(*)\nFROM \"person\"\n=#","category":"page"},{"location":"test/clauses/#HAVING-Clause","page":"SQL Clauses","title":"HAVING Clause","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A HAVING clause is created with HAVING() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |>\n    GROUP(:year_of_birth) |>\n    HAVING(OP(\">\", AGG(\"COUNT\", OP(\"*\")), 10))\n#-> (…) |> HAVING(…)\n\ndisplay(c)\n#=>\nID(:person) |>\nFROM() |>\nGROUP(ID(:year_of_birth)) |>\nHAVING(OP(\">\", AGG(\"COUNT\", OP(\"*\")), LIT(10)))\n=#\n\nprint(render(c |> SELECT(:person_id)))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nGROUP BY \"year_of_birth\"\nHAVING (COUNT(*) > 10)\n=#","category":"page"},{"location":"test/clauses/#ORDER-Clause","page":"SQL Clauses","title":"ORDER Clause","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"An ORDER BY clause is created with ORDER constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |> ORDER(:year_of_birth)\n#-> (…) |> ORDER(…)\n\ndisplay(c)\n#-> ID(:person) |> FROM() |> ORDER(ID(:year_of_birth))\n\nprint(render(c |> SELECT(:person_id)))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nORDER BY \"year_of_birth\"\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"An ORDER constructor accepts an empty list, in which case, it is not rendered.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |> ORDER()\n#-> (…) |> ORDER()\n\nprint(render(c |> SELECT(:person_id)))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"It is possible to specify ascending or descending order of the sort column.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |>\n    ORDER(:year_of_birth |> DESC(nulls = :first),\n          :person_id |> ASC()) |>\n    SELECT(:person_id)\n\ndisplay(c)\n#=>\nID(:person) |>\nFROM() |>\nORDER(ID(:year_of_birth) |> DESC(nulls = :NULLS_FIRST),\n      ID(:person_id) |> ASC()) |>\nSELECT(ID(:person_id))\n=#\n\nprint(render(c))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nORDER BY \"year_of_birth\" DESC NULLS FIRST, \"person_id\" ASC\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Instead of ASC and DESC, a generic SORT constructor can be used.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |>\n    ORDER(:year_of_birth |> SORT(:desc, nulls = :first),\n          :person_id |> SORT(:asc)) |>\n    SELECT(:person_id)\n\nprint(render(c))\n#=>\nSELECT \"person_id\"\nFROM \"person\"\nORDER BY \"year_of_birth\" DESC NULLS FIRST, \"person_id\" ASC\n=#","category":"page"},{"location":"test/clauses/#UNION-Clause.","page":"SQL Clauses","title":"UNION Clause.","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"UNION and UNION ALL clauses are created with UNION() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:measurement) |>\n    SELECT(:person_id, :date => :measurement_date) |>\n    UNION(all = true,\n          FROM(:observation) |>\n          SELECT(:person_id, :date => :observation_date))\n#-> (…) |> UNION(all = true, …)\n\ndisplay(c)\n#=>\nID(:measurement) |>\nFROM() |>\nSELECT(ID(:person_id), ID(:measurement_date) |> AS(:date)) |>\nUNION(all = true,\n      ID(:observation) |>\n      FROM() |>\n      SELECT(ID(:person_id), ID(:observation_date) |> AS(:date)))\n=#\n\nprint(render(c))\n#=>\nSELECT \"person_id\", \"measurement_date\" AS \"date\"\nFROM \"measurement\"\nUNION ALL\nSELECT \"person_id\", \"observation_date\" AS \"date\"\nFROM \"observation\"\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A UNION clause with no subqueries can be created explicitly.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"UNION(list = [])\n#-> UNION(list = [])","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"Rendering a nested UNION clause adds parentheses around it.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:measurement) |>\n    SELECT(:person_id, :date => :measurement_date) |>\n    UNION(all = true,\n          FROM(:observation) |>\n          SELECT(:person_id, :date => :observation_date)) |>\n    FROM() |>\n    AS(:union) |>\n    WHERE(OP(\">\", ID(:date), Date(2000))) |>\n    SELECT(ID(:person_id))\n\nprint(render(c))\n#=>\nSELECT \"person_id\"\nFROM (\n  SELECT \"person_id\", \"measurement_date\" AS \"date\"\n  FROM \"measurement\"\n  UNION ALL\n  SELECT \"person_id\", \"observation_date\" AS \"date\"\n  FROM \"observation\"\n) AS \"union\"\nWHERE (\"date\" > '2000-01-01')\n=#","category":"page"},{"location":"test/clauses/#WINDOW-Clause","page":"SQL Clauses","title":"WINDOW Clause","text":"","category":"section"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"A WINDOW clause is created with WINDOW() constructor.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |>\n    WINDOW(:w1 => PARTITION(:gender_concept_id),\n           :w2 => :w1 |> PARTITION(:year_of_birth, order_by = [:month_of_birth, :day_of_birth]))\n#-> (…) |> WINDOW(…)\n\ndisplay(c)\n#=>\nID(:person) |>\nFROM() |>\nWINDOW(PARTITION(ID(:gender_concept_id)) |> AS(:w1),\n       ID(:w1) |>\n       PARTITION(ID(:year_of_birth),\n                 order_by = [ID(:month_of_birth), ID(:day_of_birth)]) |>\n       AS(:w2))\n=#\n\nprint(render(c |> SELECT(:w1 |> AGG(\"ROW_NUMBER\"), :w2 |> AGG(\"ROW_NUMBER\"))))\n#=>\nSELECT (ROW_NUMBER() OVER (\"w1\")), (ROW_NUMBER() OVER (\"w2\"))\nFROM \"person\"\nWINDOW \"w1\" AS (PARTITION BY \"gender_concept_id\"), \"w2\" AS (\"w1\" PARTITION BY \"year_of_birth\" ORDER BY \"month_of_birth\", \"day_of_birth\")\n=#","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"The WINDOW() constructor accepts an empty list of partitions, in which case, it is not rendered.","category":"page"},{"location":"test/clauses/","page":"SQL Clauses","title":"SQL Clauses","text":"c = FROM(:person) |>\n    WINDOW(list = [])\n\ndisplay(c)\n#-> ID(:person) |> FROM() |> WINDOW(list = [])\n\nprint(render(c |> SELECT(AGG(\"ROW_NUMBER\", over = PARTITION()))))\n#=>\nSELECT (ROW_NUMBER() OVER ())\nFROM \"person\"\n=#","category":"page"},{"location":"#FunSQL.jl","page":"Home","title":"FunSQL.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FunSQL is a Julia library for compositional construction of SQL queries.","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"tutorial.md\",\n    \"api.md\",\n    \"test/index.md\",\n]","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial will teach you how to build SQL queries using FunSQL.","category":"page"},{"location":"tutorial/#Test-Database","page":"Tutorial","title":"Test Database","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To demonstrate database queries, we need a test database.  The database we use is a tiny 10 person sample of simulated patient data extracted from a much larger CMS DE-SynPuf dataset. For a database engine, we picked SQLite.  Using SQLite in a tutorial is convenient because it does not require a database server to run and allows us to distribute the whole database as a single file. FunSQL supports SQLite and many other database engines.  The techniques discussed here are not specific to SQLite or this particular database.  Once you learn them, you should be able to apply them to your own databases.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you wish to follow along with the tutorial and run the examples, download the database file:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"const URL = \"https://github.com/MechanicalRabbit/ohdsi-synpuf-demo/releases/download/20210412/synpuf-10p.sqlite\"\nconst DB = download(URL)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"During development, all the code examples here are executed on every update by the NarrativeTest package.  To avoid downloading the database file more than once, we registered the download URL as an artifact and use Pkg.Artifacts API to fetch it:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg.Artifacts, LazyArtifacts\n\nconst DB = joinpath(artifact\"synpuf-10p\", \"synpuf-10p.sqlite\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To interact with a SQLite database from Julia code, we need to install the SQLite package:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg\n\nPkg.add(\"SQLite\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once the package is installed, we can use it to connect to the database:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using SQLite\n\nconst conn = SQLite.DB(DB)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Later we will use the conn object to execute database queries.","category":"page"},{"location":"tutorial/#Database-Schema","page":"Tutorial","title":"Database Schema","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The data in the test database is stored in the format of the OMOP Common Data Model, an open source database schema for observational healthcare data.  In this tutorial, we will only use a small fragment of the Common Data Model.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Fragment of the OMOP Common Data Model)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Before we can start assembling queries with FunSQL, we need to make FunSQL aware of the database schema.  For each table in the database, we need to create a corresponding SQLTable(@ref) object, which encapsulates the name of the table and the names of the columns.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using FunSQL: SQLTable","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The patient data, including basic demographic information, is stored in the table person:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"const person =\n    SQLTable(:person,\n             columns = [:person_id, :year_of_birth, :location_id])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Patient addresses are stored in a separate table location, linked to the person table by the key column location_id:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"const location =\n    SQLTable(:location,\n             columns = [:location_id, :city, :state])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The bulk of patient data consists of clinical events: visits to healthcare providers, recorded observations, diagnosed conditions, prescribed medications, etc.  In this tutorial we only use two types of events, visits and conditions:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"const visit_occurrence =\n    SQLTable(:visit_occurrence,\n             columns = [:visit_occurrence_id, :person_id,\n                        :visit_concept_id,\n                        :visit_start_date, :visit_end_date])\n\nconst condition_occurrence =\n    SQLTable(:condition_occurrence,\n             columns = [:condition_occurrence_id, :person_id,\n                        :condition_concept_id,\n                        :condition_start_date, :condition_end_date])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The specific type of the event (e.g., Inpatient visit or Essential hypertension condition) is indicated using a concept id column, which refers to the concept table:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"const concept =\n    SQLTable(:concept,\n             columns = [:concept_id, :concept_name])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Different concepts may be related to each other.  For instance, Essential hypertension is a Hypertensive disorder, which itself is a Disorder of cardiovascular system.  Concept relationships are recorded in the corresponding table:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"const concept_relationship =\n    SQLTable(:concept_relationship,\n             columns = [:concept_id_1, :concept_id_2, :relationship_id])","category":"page"},{"location":"tutorial/#Using-FunSQL","page":"Tutorial","title":"Using FunSQL","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To retrieve data from the database using FunSQL, we need to perform three steps: assemble a query object, render SQL, and execute SQL.  To demonstrate these steps, let us consider the following question:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Who are the patients born between 1930 and 1940 and what is their current age (by the end of 2020)?","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The SQL query that answer this question could be written like this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SELECT p.person_id, 2020 - p.year_of_birth AS age\nFROM person p\nWHERE p.year_of_birth >= 1930 AND p.year_of_birth < 1940","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"FunSQL representation of the SQL query mirrors its structure: the structure of the SQL query:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using FunSQL: From, Fun, Get, Select, Where\n\nq = From(person) |>\n    Where(Fun.and(Get.year_of_birth .>= 1930,\n                  Get.year_of_birth .< 1940)) |>\n    Select(Get.person_id,\n           :age => 2020 .- Get.year_of_birth)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The next step is to serialize the query object to SQL.  We need to specify the target SQL dialect such as :sqlite or :postgresql:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using FunSQL: render\n\nsql = render(q, dialect = :sqlite)\n\nprint(sql)\n#=>\nSELECT \"person_1\".\"person_id\", (2020 - \"person_1\".\"year_of_birth\") AS \"age\"\nFROM \"person\" AS \"person_1\"\nWHERE ((\"person_1\".\"year_of_birth\" >= 1930) AND (\"person_1\".\"year_of_birth\" < 1940))\n=#","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"At this point, the job of FunSQL is done.  To submit the SQL query to the database engine, we can use the connection object that we created earlier:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"res = DBInterface.execute(conn, sql)\n#-> SQLite.Query( … )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The output of the query could be displayed in a tabular form by converting it to a DataFrame object:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DataFrames\n\nres |> DataFrame |> display\n#=>\n2×2 DataFrame\n Row │ person_id  age\n     │ Int64      Int64\n─────┼──────────────────\n   1 │     30091     88\n   2 │     72120     83\n=#","category":"page"},{"location":"tutorial/#Tabular-operations","page":"Tutorial","title":"Tabular operations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Recall the query demonstrated in the previous section:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"From(person) |>\nWhere(Fun.and(Get.year_of_birth .>= 1930, Get.year_of_birth .< 1940)) |>\nSelect(Get.person_id, :age => 2020 .- Get.year_of_birth)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This query is constructed from tabular operations From, Where, and Select arranged in a pipeline using the pipe (|>) operator.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In SQL, a tabular operation takes a certain number of input datasets and produces an output dataset.  Tabular operations are typically parameterized by row operations, which act on a dataset row and produce a scalar value.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The From operation outputs the content of a database table.  It takes one argument, a SQLTable object describing the table (see section Database Schema for the definition of person).  In the context of a query expression, a SQLTable object is automatically converted to From; thus this query could condensed to:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"person |>\nWhere(Fun.and(Get.year_of_birth .>= 1930, Get.year_of_birth .< 1940)) |>\nSelect(Get.person_id, :age => 2020 .- Get.year_of_birth)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The Select operation allows us to customize the output columns.  Column names are specified with => or using the As constructor, e.g.,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using FunSQL: As\n\n2020 .- Get.year_of_birth |> As(:age)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If the column name is not given explicitly, it is derived from the expression that calculates the column value.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As opposed to SQL, FunSQL does not require that the query has an explicit Select, so that the following expression is a valid and complete query:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"q = From(person) |>\n    Where(Fun.and(Get.year_of_birth .>= 1930, Get.year_of_birth .< 1940))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This query produces all the columns from the person table:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sql = render(q)\n\nprint(sql)\n#=>\nSELECT \"person_1\".\"person_id\", \"person_1\".\"year_of_birth\", \"person_1\".\"location_id\"\nFROM \"person\" AS \"person_1\"\nWHERE ((\"person_1\".\"year_of_birth\" >= 1930) AND (\"person_1\".\"year_of_birth\" < 1940))\n=#","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Neither From is mandatory.  When a tabular operation, such as Select, that expects an input dataset isn't provided with one, it is supplied with the unit dataset containing one row and no columns.  This allows us to create queries that do not depend on the content of any database tables and generate one row of output:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"q = Select(Fun.current_timestamp())\n\nsql = render(q)\n\nprint(sql)\n#-> SELECT CURRENT_TIMESTAMP AS \"current_timestamp\"","category":"page"},{"location":"tutorial/#Row-operations","page":"Tutorial","title":"Row operations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Row operations are assembled from literal values, column references, and applications of SQL functions and operators.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Literal values are created using the Lit constructor, although the values of type Bool, Number, AbstractString and AbstractTime as well as missing are automatically wrapped with Lit when used in a query expression:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using FunSQL: Lit\n\nSelect(Lit(42))\nSelect(42)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The SQL value NULL is represented by missing.  FunSQL makes a reasonable attempt to convert Julia values to their respective SQL equivalents.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Column references are created using the Get constructor, which has several equivalent forms:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Get.year_of_birth\nGet(:year_of_birth)\nGet.\"year_of_birth\"\nGet(\"year_of_birth\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Column references are always resolved at the place of use.  Here, the same reference Get.year_of_birth appears several times:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"From(person) |>\nWhere(Fun.and(Get.year_of_birth .>= 1930, Get.year_of_birth .< 1940)) |>\nSelect(Get.person_id, :age => 2020 .- Get.year_of_birth)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As a part of Where, it refers to the column produced by the From operation, but inside Select it refers to the output of Where.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"FunSQL provides an alternative notation for column references.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"q1 = From(person)\nq2 = q1 |>\n     Where(Fun.and(q1.year_of_birth .>= 1930, q1.year_of_birth .< 1940))\nq3 = q2 |>\n     Select(q1.person_id, :age => 2020 .- q1.year_of_birth)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The unbound references Get.year_of_birth and Get.person_id are replaced with bound references q1.year_of_birth and q1.person_id.  If we use a bound reference, the node to which the reference is bound must be a part of the query.  Note that in Select, we could replace q1 with q2 without changing the meaning of the query:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"q3 = q2 |>\n     Select(q2.person_id, :age => 2020 .- q2.year_of_birth)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Use of unbound references makes query composition more modular.  For example, we could encapsulate the condition on the birth range in a Julia function as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"BirthRange(start, stop) =\n    Fun.and(Get.year_of_birth .>= start, Get.year_of_birth .< stop)\n\nFrom(person) |> Where(BirthRange(1930, 1940))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"On the other hand, bound references sometimes make it easier to disambiguate columns of different tables.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SQL functions and operators are represented using the Fun constructor, which, just like Get, has several equivalent forms:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Fun.and(Get.year_of_birth .>= 1930, Get.year_of_birth .< 1940)\nFun(:and, Get.year_of_birth .>= 1930, Get.year_of_birth .< 1940)\nFun.\"and\"(Get.year_of_birth .>= 1930, Get.year_of_birth .< 1940)\nFun(\"and\", Get.year_of_birth .>= 1930, Get.year_of_birth .< 1940)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Certain SQL operators, notably comparison operators, also support broadcasting notation:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Fun.\">=\"(Get.year_of_birth, 1930)\nGet.year_of_birth .>= 1930","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"FunSQL has support for serializing some of the widely used SQL functions and operators with irregular notation.  For example:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"q = From(person) |>\n    Select(:generation => Fun.case(Get.year_of_birth .<= 1960,\n                                   \"boomer\", \"millenial\"))\n\nprint(render(q))\n#=>\nSELECT (CASE WHEN (\"person_1\".\"year_of_birth\" <= 1960) THEN 'boomer' ELSE 'millenial' END) AS \"generation\"\nFROM \"person\" AS \"person_1\"\n=#","category":"page"},{"location":"test/#Test-Suite","page":"Test Suite","title":"Test Suite","text":"","category":"section"},{"location":"test/","page":"Test Suite","title":"Test Suite","text":"Pages = [\n    \"clauses.md\",\n    \"entities.md\",\n    \"nodes.md\",\n]","category":"page"}]
}
