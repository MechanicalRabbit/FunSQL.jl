<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Two Kinds of SQL Query Builders · FunSQL.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">FunSQL.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guide/">Usage Guide</a></li><li><a class="tocitem" href="../reference/">API Reference</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../test/">Test Suite</a></li><li><span class="tocitem">Articles</span><ul><li class="is-active"><a class="tocitem" href>Two Kinds of SQL Query Builders</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Articles</a></li><li class="is-active"><a href>Two Kinds of SQL Query Builders</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Two Kinds of SQL Query Builders</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MechanicalRabbit/FunSQL.jl/blob/master/docs/src/two-kinds-of-sql-query-builders/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Two-Kinds-of-SQL-Query-Builders"><a class="docs-heading-anchor" href="#Two-Kinds-of-SQL-Query-Builders">Two Kinds of SQL Query Builders</a><a id="Two-Kinds-of-SQL-Query-Builders-1"></a><a class="docs-heading-anchor-permalink" href="#Two-Kinds-of-SQL-Query-Builders" title="Permalink"></a></h1><p>The SQL language has a paradoxical fate.  Although it was deliberately designed to appeal to a human user, nowadays most of SQL code is written—or rather generated—by the computer.  Many computer programs need to query some database, and, for the vast majority of database servers, the only supported query language is SQL.  But generating SQL is difficult because of the complicated and obscure rules of its quasi-English grammar (its original name SEQUEL stands for Structured <em>English</em> Query Language).  For this reason, programs that interact with a database often use specialized libraries for generating SQL queries.</p><p>One of such libraries is FunSQL.  FunSQL is designed with two goals in mind: supporting the full range of SQL&#39;s querying capabilities and exposing these capabilities in a compositional, data-oriented interface.  This combination of goals makes FunSQL a perfect tool for data analysis in SQL and differentiates it from all the other query building libraries.  Many query builders offer good coverage of SQL features, fewer provide data-oriented interface, but only FunSQL combines them in a single package.</p><p>And yet the difference between FunSQL and other query builders is not immediately apparent.  In fact, the interfaces of various query building libraries seem almost identical.  A query that finds <em>100 oldest male patients</em> (in the <a href="https://ohdsi.github.io/CommonDataModel/cdm53.html">OMOP CDM</a> database) is assembled with FunSQL as follows:</p><pre><code class="language-julia hljs">From(:person) |&gt;
Where(Get.gender_concept_id .== 8507) |&gt;
Order(Get.year_of_birth) |&gt;
Limit(100) |&gt;
Select(Get.person_id)</code></pre><p>The same query can be written in Ruby using <a href="https://guides.rubyonrails.org/active_record_querying.html">Active Record Query Interface</a>:</p><pre><code class="language-ruby hljs">Person
.where(&quot;gender_concept_id = ?&quot;, 8507)
.order(:year_of_birth)
.limit(100)
.select(:person_id)</code></pre><p>Or in PHP with <a href="https://laravel.com/docs/9.x/queries">Laravel&#39;s Query Builder</a>:</p><pre><code class="language-php hljs">DB::table(&#39;person&#39;)
-&gt;where(&#39;gender_concept_id&#39;, &#39;=&#39;, 8507)
-&gt;orderBy(&#39;year_of_birth&#39;)
-&gt;limit(100)
-&gt;select(&#39;person_id&#39;)</code></pre><p>In C#&#39;s <a href="https://docs.microsoft.com/en-us/ef/core/querying/">EF/LINQ</a>:</p><pre><code class="language-csharp hljs">Person
.Where(p =&gt; p.gender_concept_id == 8507)
.OrderBy(p =&gt; p.year_of_birth)
.Take(100)
.Select(p =&gt; new { person_id = p.person_id });</code></pre><p>Or in R with <a href="https://dbplyr.tidyverse.org/">dbplyr</a>:</p><pre><code class="language-r hljs">tbl(conn, &quot;person&quot;) %&gt;%
filter(gender_concept_id == 8507) %&gt;%
arrange(year_of_birth) %&gt;%
head(100) %&gt;%
select(person_id)</code></pre><p>In each of these code samples, the query is assembled using essentially the same interface.  Stripped of its syntactic shell, the process of assembling the query can be visualized as a diagram of five processing nodes connected in a pipeline:</p><p><img src="100-oldest-male-patients.drawio.svg" alt="100 oldest male patients"/></p><p>It is precisely the fact that the query is progressively assembled using atomic, independent components that lets us call this interface <em>compositional</em>.</p><p>However we did claim that FunSQL differs from all the other query building libraries, and now apparently proved the opposite?  As a matter of fact, there is a difference, even if it is not reflected in notation.  To demonstrate this, let us rearrange this pipeline, moving the <code>Order</code> and the <code>Limit</code> nodes in front of <code>Where</code>.</p><p><img src="males-among-100-oldest-patients.drawio.svg" alt="100 oldest male patients ⟹ Males among 100 oldest patients"/></p><p>How does this rearrangement affect the output of the query?  Perhaps unexpectedly, the answer depends on the library.  With FunSQL, as well as EF/LINQ and dbplyr, it changes the output from <em>100 oldest male patients</em> to <em>the males among 100 oldest patients</em>.  But not so with the other two libraries, Active Record and Laravel, where rearranging the pipeline has <em>no</em> effect on the output.</p><p>To summarize, the following query builders are sensitive to the order of the pipeline nodes:</p><ul><li>FunSQL</li><li>EF/LINQ</li><li>dbplyr</li></ul><p>And the following are not:</p><ul><li>Active Record</li><li>Laravel</li></ul><p>These are the two kinds of query builders from this article&#39;s title.  But how can these libraries act so differently while sharing the same interface?  To answer this question, we need to focus on what is only implicitly present on the pipeline diagram: the information that is processed by the pipeline nodes.</p><p><img src="where-node.drawio.svg" alt="&quot;Where&quot; node"/></p><p>A node with one incoming and one outgoing arrow symbolizes a processing unit that takes the input data, transforms it, and emits the output data.  While the character of the data is not revealed, it is tempting to assume it to be the tabular data extracted from the database.</p><p><img src="where-node-acting-on-data.drawio.svg" alt="&quot;Where&quot; node acting on data"/></p><p>But this can&#39;t be right, at least not literally, because a SQL query builder cannot read the data in the database.  Instead, the query builder generates a SQL query:</p><pre><code class="language-sql hljs">SELECT &quot;person_1&quot;.&quot;person_id&quot;
FROM &quot;person&quot; AS &quot;person_1&quot;
WHERE (&quot;person_1&quot;.&quot;gender_concept_id&quot; = 8507)
ORDER BY &quot;person_1&quot;.&quot;year_of_birth&quot;
LIMIT 100</code></pre><p>But if we assume for a moment that pipeline nodes could process the data directly, we would expect that both the pipeline and the corresponding SQL query produce the same output.  In other words, the role of the pipeline is to specify the expected output of the SQL query.  This is how pipeline nodes are interpreted by FunSQL and the other two libraries, EF/LINQ and dbplyr.  We can call such query builders <em>data-oriented</em>.</p><p>The conversion of the pipeline to SQL is not always that straightforward.  Even though we could freely reorder the nodes in a pipeline, we cannot do the same to the clauses in a SQL query.  This is because the SQL grammar arranges the clauses in a rigid order:</p><ol><li><code>FROM</code>, followed by zero, one or more</li><li><code>JOIN</code>, followed by</li><li><code>WHERE</code>, followed by</li><li><code>GROUP BY</code>, followed by</li><li><code>HAVING</code>, followed by</li><li><code>ORDER BY</code>, followed by</li><li><code>LIMIT</code>, followed by</li><li><code>SELECT</code>, written at the top of the query, but the last one to perform.</li></ol><p>This order is compatible with the first pipeline, in which the <code>Where</code> node is followed by <code>Order</code> and <code>Limit</code>, but not the second pipeline, where these nodes change their relative positions.  So how could the second pipeline be converted to SQL?  We would be out of options if we were still using the original SQL standard, SQL-86, but the next revision of the language, SQL-92, recognized this limitation.  Regrettably, it did not relax this rigid clause order. Instead, SQL-92 introduced a workaround: a query can be extended by nesting it into the next query&#39;s <code>FROM</code> clause.  This gives us a method for converting an arbitrary pipeline into SQL: break the pipeline into smaller chunks that comply with the SQL clause order, convert each chunk into a SQL query, and then nest all these queries together:</p><pre><code class="language-sql hljs">SELECT &quot;person_2&quot;.&quot;person_id&quot;
FROM (
  SELECT
    &quot;person_1&quot;.&quot;person_id&quot;,
    &quot;person_1&quot;.&quot;gender_concept_id&quot;
  FROM &quot;person&quot; AS &quot;person_1&quot;
  ORDER BY &quot;person_1&quot;.&quot;year_of_birth&quot;
  LIMIT 100
) AS &quot;person_2&quot;
WHERE (&quot;person_2&quot;.&quot;gender_concept_id&quot; = 8507)</code></pre><p>The SQL grammar has a number of deficiencies, including rigid clause order, query nesting, and nonsensical position of the <code>SELECT</code> clause.  The position of <code>SELECT</code> violates the execution flow of the query, and this violation is aggravated by query nesting.  Complex SQL queries often require multiple levels of nesting, which makes such queries bloated and difficult to interpret.  This is where data-oriented query builders, which do not constrain the order of pipeline nodes, offer an improvement over plain SQL.</p><p>What about the other kind of query builders?  Active Record and Laravel employ a pipeline of exactly the same form, but because it is not sensitive to the order of the nodes, it must work on a different principle.  Indeed, this pipeline generates a SQL query by incrementally assembling the SQL syntax tree.  Because of the rigid clause order, a SQL syntax tree can be faithfully represented as a composite data structure with slots specifying the content of the <code>SELECT</code>, <code>FROM</code>, <code>WHERE</code>, and the other clauses:</p><pre><code class="language-julia hljs">struct SQLQuery
    select
    from
    joins
    where
    groupby
    having
    orderby
    limit
end</code></pre><p>Individual slots of this structure are populated by the corresponding pipeline nodes.</p><p><img src="where-node-acting-on-syntax-tree.drawio.svg" alt="&quot;Where&quot; node acting on the syntax tree"/></p><p>This explains why the pipeline is insensitive to the order of the nodes. Indeed, as long as the content of the slots stays the same, it makes no difference in what order the slots are populated.</p><p><img src="pipeline-insensitive-to-node-order.drawio.svg" alt="Pipeline is insensitive to the order of the nodes"/></p><p>This method of incrementally constructing a composite structure is known as the <a href="https://en.wikipedia.org/wiki/Builder_pattern"><em>builder pattern</em></a>.  We can call the query builders that employ this pattern <em>syntax-oriented</em>.</p><p>Both data-oriented and syntax-oriented query builders are compositional: the difference is in the nature of the information processed by the units of composition.  Data-oriented query builders incrementally refine the query output; syntax-oriented query builders incrementally assemble the SQL syntax tree.  Their interfaces look almost identical, but their methods of operation are fundamentally different.</p><p>But which one is better?  Syntax-oriented query builders have two definite advantages: they are easy to implement and they could support the full range of SQL features.  Indeed, the interface of a syntax-oriented query builder is just a collection of builders for the SQL syntax tree.  How complete the representation of the syntax tree determines how well various SQL features are supported.</p><p>On the other hand, syntax-oriented query builders are harder to <em>use</em>.  As they directly represent the SQL grammar, they inherit all of its deficiencies.  In particular, the rigid clause order makes it difficult to assemble complex data processing pipelines, especially when the arrangement of pipeline nodes is not predetermined.</p><p>A data-oriented query builder directly represents data processing nodes, which makes assembling data processing pipelines much more straightforward—as long as we can find the necessary nodes among those offered by the builder.  But where does the builder get its collection of data processing nodes?  And how can we tell if this collection is complete?</p><p>One way to implement a data-oriented query builder is to adapt a general-purpose query framework.  Indeed, this is the origin of EF/LINQ, which is adapted from <a href="https://docs.microsoft.com/en-us/dotnet/standard/using-linq">LINQ</a>, and dbplyr, which is adapted from <a href="https://dplyr.tidyverse.org/">dplyr</a>.  The query framework determines what processing nodes are available and how they operate. In principle, any query framework could be adapted to SQL databases by introducing just one new node, a node that loads the content of a database table.  If we place this node at the beginning of a pipeline and make the rest of it out of regular nodes, we obtain a pipeline that processes data from a SQL database.  However, this pipeline will be very inefficient compared to a SQL engine, which can use indexes to avoid loading the entire table into memory and thus can process the same data much faster.  This is why EF/LINQ and dbplyr generate a SQL query that replaces the pipeline as a whole.  The pipeline itself no longer runs directly, but now serves as a specification, with the assumption that if it <em>were</em> to run, it would produce the same output as the SQL query. This method of transforming a general-purpose query framework to a SQL query builder is called <em>SQL pushdown</em>.</p><p>However, SQL pushdown has a serious limitation.  A general-purpose query framework is not designed with SQL compatibility in mind.  For this reason, some of the pipelines assembled within this framework cannot be converted to SQL. Even worse, many useful SQL queries have no equivalent pipelines and thus cannot be generated using SQL pushdown.  Indeed, SQL accumulated a wide range of features and capabilities since it first appeared in 1974.  The first revision of the SQL standard, SQL-86, already supported Cartesian products, filtering, grouping, aggregation, and correlated subqueries.  The next revision, SQL-92, added many join types and introduced query nesting.  SQL:1999 greatly expanded its analytical capabilities by adding two types of queries: recursive queries, for processing hierarchical data, and data cube queries, which generalize histograms, cross-tabulations, roll-ups, drill-downs, and sub-totals.  The follow-up revision, SQL:2003, added support for aggregate functions over a running window.  Admittedly, SQL is a quintessential <em>enterprise abomination</em>, a hodgepodge of features added to support every imaginable use case, but with inadequate syntax, weird gaps in functionality, and no regards to internal consistency.  Nevertheless, the breadth of SQL&#39;s capabilities has not been matched by any other query framework, including LINQ or dplyr.  So when we generate SQL queries using EF/LINQ or dbplyr, a large subset of these capabilities remains inaccessible.</p><p>FunSQL is a data-oriented query builder created specifically to expose full expressive power of SQL.  Unlike EF/LINQ and dbplyr, FunSQL was not adapted from an existing query framework, but was carefully designed from scratch to match SQL&#39;s capabilities.  These capabilities include, for example, support for correlated subqueries and lateral joins (with <a href="../reference/#FunSQL.Bind-Tuple"><code>Bind</code></a> node), aggregate and window functions (using <a href="../reference/#FunSQL.Group-Tuple"><code>Group</code></a> and <a href="../reference/#FunSQL.Partition-Tuple"><code>Partition</code></a> nodes), as well as recursive queries (with <a href="../reference/#FunSQL.Iterate-Tuple"><code>Iterate</code></a> node).  This comprehensive support for SQL capabilities makes FunSQL the only SQL query builder suitable for assembling complex data processing pipelines.  Moreover, even though FunSQL pipelines cannot be run directly, every FunSQL node has a well-defined data processing semantics, which means that, in principle, FunSQL could be developed into a full-blown query framework.  This potentially opens a path for replacing SQL with an equally powerful, but a more coherent and expressive query language.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../test/">« Test Suite</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 17 August 2023 03:25">Thursday 17 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
